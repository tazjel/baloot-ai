# BALOOT AI: LITE CONTEXT SNAPSHOT
# Generated for Claude Desktop. Mode: LITE

# üß† CRITICAL CONTEXT (Read This First)

### DOC: README.md
# Baloot AI & Game Engine ‚ô†Ô∏è

![Project Status](https://img.shields.io/badge/Status-Active-success)
![Python](https://img.shields.io/badge/Python-3.10+-blue)
![React](https://img.shields.io/badge/React-18-blue)
![Redis](https://img.shields.io/badge/Redis-Enabled-red)
![License](https://img.shields.io/badge/License-MIT-green)

A high-performance, multiplayer **Baloot** game engine featuring an advanced AI opponent ("The Brain"). This project combines traditional game rules with modern AI techniques (Reinforcement Learning & LLMs) to create a challenging and robust gaming experience.

## üåü Key Features

- **Hybrid AI System**:
  - **The Reflex**: Instant heuristic-based decision making for standard plays.
  - **The Brain**: Reinforcement Learning system that learns from game logs via Redis.
  - **The Scout**: Automated daily analysis tool that uses LLMs (Gemini) to find mistakes and generate training data.
- **Voice & Trash Talk**: Dynamic, personality-driven AI dialogue system. Bots speak in Arabic (Hejazi/Najdi dialects) using Text-to-Speech!
  - *Khalid (Aggressive)*, *Saad (Balanced)*, *Abu Fahad (Conservative)*.
- **Robust Multiplayer**: Resilient WebSocket architecture capable of handling disconnects and lag.
- **"The Professor" Mode üéì**: Real-time AI Coach that interrupts the game when you make a strategic blunder, explaining the mistake and offering a better move.
- **War Room Dashboard üìâ**: Live analytics showing Win Probability graphs and Blunder Heatmaps during gameplay.
- **AI Studio**: A dedicated dashboard for analyzing hands, debugging strategies, and replaying scenarios.
- **Premium UI**: Polished React frontend with `framer-motion` physics-based animations, glassmorphism design, and interactive feedback.

## üöÄ Quick Start

### Prerequisites
- **Python 3.10+**
- **Node.js 18+**
- **Docker Desktop** (for Redis)

### Installation

1.  **Clone the Repository**
    ```bash
    git clone https://github.com/tazjel/baloot-ai.git
    cd baloot-ai
    ```

2.  **Environment Setup**
    Copy the example environment file and add your API keys (for AI features).
    ```bash
    cp .env.example .env
    # Edit .env and add your GEMINI_API_KEY
    ```

3.  **Start Infrastructure & Backend**
    ```powershell
    # Start Redis
    docker-compose up -d redis

    # Install Python Dependencies
    pip install -r requirements.txt

    # Run Game Server
    python -m server.main
    ```

    **Pro Tip**: If you are on Windows, use the `/WW` slash command (or run `workflow_scripts/ww.ps1`) to launch everything at once!

4.  **Start Frontend**
    ```bash
    cd frontend
    npm install
    npm start
    ```
    The game will be available at `http://localhost:3000`.

## üìÇ Project Structure

- **`server/`**: Core backend application (Game logic, Socket handlers, Controllers).
- **`game_engine/`**: Reusable game logic engine.
- **`frontend/`**: React-based user interface.
- **`ai_worker/`**: AI Strategy and decision making.
- **`scripts/`**: Development and testing utilities.
- **`docs/`**: In-depth documentation, status reports, and project history.
- **`logs/`**: Application and testing logs.

## üìö Documentation

- **[Architecture Overview](docs/ARCHITECTURE.md)**: Logic separation, AI Flywheel, and Redis integration.
- **[Frontend Guide](docs/FRONTEND_GUIDE.md)**: Architecture, State Management, and UI Systems.
- **[Contributing Guide](docs/CONTRIBUTING.md)**: Setup, testing, and code style.
- **[Codebase Map](CODEBASE_MAP.md)**: Master index for AI Agents.
- **[Game Rules](https://en.wikipedia.org/wiki/Baloot)**: Standard Baloot rules implementation details.

## üõ†Ô∏è Configuration

| Variable | Description | Default |
|----------|-------------|---------|
| `REDIS_HOST` | Redis Host address | `localhost` |
| `REDIS_PORT` | Redis Port | `6379` |
| `OFFLINE_MODE` | Play without Redis | `false` |

## ü§ù Contributing

We welcome contributions! Please check our [Contributing Guide](docs/CONTRIBUTING.md) and [Code of Conduct](docs/CODE_OF_CONDUCT.md) for details.

1.  Fork the Project
2.  Create your Feature Branch (`git checkout -b feature/AmazingFeature`)
3.  Commit your Changes (`git commit -m 'Add some AmazingFeature'`)
4.  Push to the Branch (`git push origin feature/AmazingFeature`)
5.  Open a Pull Request

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## üôè Acknowledgments

- **Py4Web**: For the Python backend framework inspiration.



### DOC: CODEBASE_MAP.md
# Baloot AI Codebase Map

## Directory Structure

### `ai_worker/`
**Purpose**: Contains the autonomous AI logic, including the Bot Agent and its memory.
- `agent.py`: Main `BotAgent` class (formerly `bot_agent.py`). Handles decision making, Redis interaction, and strategy delegation.
- `memory.py`: `CardMemory` class (formerly `bot_memory.py`). Tracks played cards, void suits, and partner signals.
- `dialogue_system.py`: Generates trash talk and dialogue using Gemini.
- `strategies/`: Specific bidding and playing strategies.
- `signals/`: Collaborative Signaling Framework (Manager, Definitions, Emitter/Detector).
- `data/`: Training data and scout analysis results (formerly `backend/data`).
- `visionary/`: (See `game_engine/visionary`)

### `dataset/`
**Purpose**: YOLOv8 Training Data.
- `images/`: Training and Validation images (train/val).
- `labels/`: YOLO-format labels (txt) (train/val).
- `data.yaml`: YOLOv8 Configuration file.

### `models/`
**Purpose**: Trained ML Models.
- `yolo_v8n_baloot.pt`: Fine-tuned YOLOv8 Nano model for card recognition.

### `game_engine/`
**Purpose**: Core game logic independent of the web server.
- `logic/`
    - `game.py`: Main `Game` state machine.
    - `bidding_engine.py`: Handles the auction phase (Sun, Hokum, Gablak, etc.).
    - `trick_manager.py`: Handles trick resolution and validation.
    - `project_manager.py`: Handles declarations (Sira, Baloot, etc.).
    - `project_manager.py`: Handles declarations (Sira, Baloot, etc.).
    - `scoring_engine.py`: Calculates scores at end of round.
- `models/`: Data classes (Card, Deck, Constants).
- `visionary/`: **Visionary Studio** Core.
    - `visionary.py`: `VisionaryProcessor` (Frames), `CardRecognizer` (YOLO), `DatasetGenerator`.

### `server/`
**Purpose**: Web server infrastructure (Socket.IO, Flask/PyDAL).
- `socket_handler.py`: Entry point for WebSocket events. Delegates to `Game` and `BotAgent`.
- `room_manager.py`: Manages active game sessions.
- `models.py`: Database models (User, GameResult).
- `settings.py`: Configuration (Redis URL, etc.).

### `archive/`
**Purpose**: Legacy code and scripts.
- `legacy_server_node/`: Archived Node.js server.
- `legacy_server_node/`: Archived Node.js server.
- `legacy_patch.py`, `old_test_game_phases.py`: Archived scripts.

### `scripts/`
Refactored intofunctional groups:
- `verification/`: Integration tests (`verify_game_flow.py`, `verify_ai_client.py`).
- `visionary/`: **Visionary Studio Tools** (`train_visionary_yolo.py`, `auto_label.py`, `generate_roi_dataset.py`, `test_visionary.py`).
- `debugging/`: Tools for symptom analysis (`repro_crash.py`, `debug_screenshot.py`, `debug_yolo_prediction.py`).
- Root: Workflow entry points (`run_nightly_scout.ps1`, `restart_server.ps1`).

### `frontend/`
**Purpose**: React/Vite Frontend.
- `components/`: UI Components (Card, Table, Hand).
- `services/`: API and Socket services.
- `hooks/`: Custom React hooks (useGame, useSound).

## Key Flows

### Bot Decision Flow
1. `server/socket_handler.py` -> `bot_loop()` triggers `bot_agent.get_decision()`.
2. `ai_worker/agent.py` -> Checks `redis` for "Brain" overrides or delegates to `bidding_strategy` / `playing_strategy`.
3. Returns action to `socket_handler.py`, which calls `game.handle_bid()` or `game.play_card()`.

### Bidding Flow
1. User action `BID` -> `game.handle_bid()`.
2. `game.py` -> delegates to `bidding_engine.process_bid()`.
3. `bidding_engine.py` validates rules (Gablak, etc.) and updates `ContractState`.
4. `game.py` syncs state via `_sync_bid_state()` (for frontend/bot visibility).


### DOC: knowledge/developer_tips.md
# Developer Tips & Tricks (Session Context)

## Critical Context (Session 2026-01-27) - MCTS Upgrade
- **MCTS Integrity**: We fixed the "AI Optimism Bug". The MCTS engine (`mcts.py`) now correctly uses adversarial selection (Minimax-style) during the Selection phase. Without this, the AI assumes opponents will play to help it win.
- **Simulation State**: We fixed the "Suit Identity Bug" in `utils.py`. The simulation generator MUST use `constants.SUITS` (‚ô†, ‚ô•, ‚ô¶, ‚ô£) and NOT string literals ('S', 'H'...). Using the wrong symbols created duplicate cards in memory, breaking the simulation logic.
- **Professor Mode**: Now uses live MCTS analysis. Thresholds are set to 0.20 (Blunder) and 0.10 (Mistake).
- **Professor Debugging**: We added rigorous logging to `professor.py`. If you see "Illegal move" reports, grep `server_manual.log` for "PROFESSOR BUG".
- **Restart Logic**: `socket_handler.py` now explicitly handles `GAMEOVER` phase for "New Game" requests. Ensure any future Game Over logic respects this.

## Workflow Shortcuts
- **Start Stack**: `python -m server.main` (Backend) + `npm run dev` (Frontend).
- **Verify Logic**: `python scripts/verification/verify_game_logic.py`.
- **Verify Professor**: Use `game_engine/logic/game.py` locally or monitor `server_manual.log` for "Professor: Triggering Intervention".
- **Restart Game**: Use `/restart` slash command to cleanly reboot server and client.

## Gotchas
- **State Duplication**: `Table.tsx` is prone to state duplication. Check `WarRoomOverlay` interactions carefully.
- **Lint Errors**: `GameState` interface in `types.ts` must manually match the Python dictionary returned by `Game.get_game_state()`.
- **Card Identity**: `Card('S', '7')` is NOT equal to `Card('‚ô†', '7')`. Always import `SUITS` from `constants.py`.

## Next Session Priorities
1. **YOLO Data Collection**: This is the next major initiative.
2. **Bot Personality Integration**: Connect the dialogue system to these new MCTS insights (e.g., bragging when `win_rate > 0.9`).

## Hybrid AI Architecture (Session 2026-01-28)
- **FastGame Encoding**: We implemented `FeatureExtractor.encode_fast()` to bypass object creation overhead. Use this when running MCTS simulations requiring neural inference.
- **Dependency Injection**: `MCTSSolver` now requires `neural_strategy` for PUCT. This is wired through `BotAgent` -> `PlayingStrategy` -> `CognitiveOptimizer`.

## Collaborative Signaling (Session 2026-01-28)
- **Source of Truth**: `collaborative_signaling_framework.md` is the master doc for all signal definitions.
- **Opposite Color Rule**: We implemented the advanced "Low Card = Opposite Color" signal. If debugging weird leads, check if `check_partner_signals` returned `PREFER_OPPOSITE`.
- **Testing**: Signaling logic is heavily unit tested in `tests/test_signals.py`.

- **Strategy Modes**: `BotAgent` now supports `heuristic`, `neural`, and `hybrid` modes per player via `game_state` config. Use this for A/B testing.

## Connection Management (Session 2026-01-28)
- **Redis Connections**: NEVER create new `redis.Redis()` connections inside high-frequency endpoints (like `get_ai_thoughts`). This exhausts file descriptors.
- **Shared Client**: Always use `server.common.redis_client`. It is initialized once and shared.
- **Symptom**: "Failed to fetch thoughts" or `Connection closed by server` usually means the backend is out of sockets.


## Py4Web / Bottle Integration (Session 2026-01-29)
- **Split Brain Issue**: When using `gevent` and custom runners (`main.py`), `py4web`'s auto-discovery (`bottle.default_app()`) can attach routes to the wrong instance.
- **Fix (Explicit Binding)**: Always pass the active `wsgi_app` to your controllers and manually bind routes:
  ```python
  def bind(app):
      app.route('/my/path', callback=my_func)
  ```
- **Static Files (404)**: `bottle.static_file` defaults the `root` to the current working directory of the *process*, not the file. Always calculate `PROJECT_ROOT` dynamically:
  ```python
  PROJECT_ROOT = os.path.dirname(os.path.dirname(__file__))
  STATIC_FOLDER = os.path.join(PROJECT_ROOT, 'static')
  ```
- **Vite Proxy**: Frontend Dev Server (5173) needs explicit proxy rules for `/static` to handle assets outside the SPA route.

## Visionary Studio AI (Session 2026-01-30)
- **Resolution Trap**: Training YOLO on full 1080p frames (resized to 640px) causes small cards to vanish. **Always train on ROIs (Crops)** that match the inference pipeline (e.g., Hand/Floor crops).
- **Auto-Labeling Config**: When using YOLO-World for auto-labeling full frames, use `imgsz=1280` and `conf=0.05` to ensure small objects are detected.
- **Data Pipeline**:
  1. `generate_roi_dataset.py` -> Extracts & Crops.
  2. `auto_label.py` -> Labels the crops.
  3. `train_visionary_yolo.py` -> Trains on the labeled crops.

## Stitch MCP Integration (Session 2026-01-31)
- **API Key & Refresh**: Stitch MCP works best with `X-Goog-Api-Key` instead of OAuth tokens in some contexts. After updating `mcp_config.json`, a **window reload/refresh** is often required for the IDE to re-handshake with the MCP server.
- **Projects**: Stitch Project IDs are persistent. Always document them (like in `visionary_studio.md`) since `list_projects` might fail if auth is flaky.

## Qayd Freeze Debugging (Session 2026-02-02)
- **Lock State Management**: When adding features that lock the game (e.g., Qayd investigations), ensure ALL timeout/auto-play paths respect `game.is_locked`. Use the `@requires_unlocked` decorator in `game.py`.
- **State Serialization**: Always serialize Card objects to dicts before storing in state that will be JSON-serialized. Use `card.to_dict()` or the new `game_engine/utils/serialization.py` helpers.
- **Dual State Bug**: Beware of multiple state objects for the same feature. The Qayd freeze was caused by `qayd_manager.state` vs `trick_manager.qayd_state` - only one was being updated.
- **Auto-Confirmation**: For Sherlock mode (bot-detected rule violations), implement auto-confirmation to prevent freeze waiting for manual input that bots can't provide.
- **Testing**: New integration tests in `tests/test_qayd_flow.py` cover the Qayd flow. Run them when modifying Qayd/lock logic.

## MCP Configuration (Session 2026-02-02)
- **Package Availability**: Before adding MCP servers to `mcp_config.json`, verify the npm package exists. `@modelcontextprotocol/server-git` does NOT exist (404).
- **Working Servers**: `stitch` (URL-based) and `filesystem` work reliably. Remove problematic servers to avoid blocking all MCP tools.

## Launch Logic & Agent Efficiency (Session 2026-02-02)
- **Headless Mode Pattern**: When launching servers for verification, ALWAYS use `-Headless` (if available) or redirect stdout/stderr to files. Capturing 200MB of log output in the agent's context window destroys token budget.
- **The "Missing Static" Crash**: Python servers (bottle/py4web) serving `index.html` must handle the *absence* of the build directory gracefully. Use `os.path.isfile()` checks and return 404 instead of crashing with `FileNotFoundError` or `ValueError: I/O operation on closed file`.
- **Readiness Probes**: Do NOT ping the root URL (`/`) for health checks if it serves a static file that might not exist. Create and use a dedicated minimal `/health` endpoint that returns a simple string ("OK").
- **Agent Directory Hygiene**: Keep `.agent/knowledge` lean. Large rulebooks (40KB+) should be moved to the Agent's Brain (artifacts) or Knowledge Base (KIs) to prevent them being loaded into every single session context. Use pointers in `.agent` to reference them.



### DOC: knowledge/handoff.md
# Session Handoff (2026-02-04)

**Tool**: Google Antigravity
**Focus**: **Qayd (Forensic) Freeze Fix**

## 1. What Was Accomplished
- **Jules Debugging**: Delegated persistent Qayd freeze issue to Jules (Session `6619761295714518725`).
- **Fix Applied**: 
  - `ChallengePhase.py`: Corrected `GAMEOVER` transition logic during Qayd/Lock resolution.
  - `bot_orchestrator.py`: Added handling for `trigger_next_round` in bot loops.
- **Verification**: 
  - `pytest tests/test_qayd_flow.py`: **PASSED**. No more freezes.
- **Merge**: Changes merged into `debug/qayd-freeze` branch and pushed to origin.

## 2. Current State
- **Branch**: `debug/qayd-freeze`
- **Game State**: Backends running (`/start` executed).
- **Known Issue**: `pytest tests/test_bidding_rules.py` is FAILING with `KeyError: 'success'` (Unrelated regression, pending investigation).

## 3. Next Steps
- **Immediate**: Playtest the Qayd interaction manually via `http://localhost:5173`.
- **Debugging**: Investigate `test_bidding_rules.py` failure.
- **Merge**: Once Bidding tests pass, merge `debug/qayd-freeze` into `main`.

## 4. Key Files
- `game_engine/logic/phases/challenge_phase.py` (Qayd Logic)
- `tests/test_qayd_flow.py` (Qayd Verification)
- `tests/test_bidding_rules.py` (Broken Bidding Test)



# üå≥ PROJECT STRUCTURE (File Tree)

    .env.example
    .gitignore
    claude_context_snapshot.txt
    CODEBASE_MAP.md
    debug_init.py
    debug_state_alias.py
    docker-compose.yml
    LICENSE
    MAJOR_TEST_REPORT.md
    Makefile
    metadata.json
    mypy.ini
    nginx.conf
    pytest.ini
    README.md
    requirements.txt
    run_verify.py
    __init__.py
    ai_worker/
        agent.py
        bot_context.py
        brain_client.py
        cognitive.py
        dialogue_system.py
        llm_client.py
        memory.py
        memory_hall.py
        mind_client.py
        mock_redis.py
        personality.py
        professor.py
        rate_limiter.py
        referee_observer.py
        __init__.py
        benchmarks/
            golden_puzzles.json
        data/
            test_yolo/
                yolo_dataset.jsonl
            training/
                mistakes_extracted.json
        learning/
            dataset_logger.py
            feature_extractor.py
            mind_reader.py
            mind_utils.py
            model.py
            puzzle_generator.py
            train_network.py
        mcts/
            benchmark_fast_game.py
            benchmark_solver.py
            fast_game.py
            mcts.py
            test_fast_game.py
            utils.py
        signals/
            definitions.py
            manager.py
        strategies/
            bidding.py
            neural.py
            oracle_bidding.py
            playing.py
    frontend/
        .gitignore
        index.html
        index.tsx
        metadata.json
        package-lock.json
        package.json
        README.md
        tsconfig.json
        vite.config.ts
        public/
            assets/
            react-py4web/
        src/
            App.test.tsx
            App.tsx
            config.ts
            constants.ts
            index.css
            setupTests.ts
            types.ts
            vite-env.d.ts
            ai/
                IntelligentBot.ts
            assets/
            components/
                ActionBar.tsx
                AIAnalysisPanel.tsx
                AIStudio.tsx
                Card.tsx
                CardPicker.tsx
                CardReal.tsx
                CardV2.tsx
                CardVector.tsx
                DevLogSidebar.tsx
                DirectorOverlay.tsx
                DisputeModal.tsx
                EmoteMenu.tsx
                ErrorBoundary.tsx
                GablakTimer.tsx
                GameLayout.tsx
                GhostCardLayer.tsx
                GlassPanel.tsx
                HandFan.tsx
                index.ts
                LevelUpModal.tsx
                Lobby.tsx
                MatchReviewModal.tsx
                MultiplayerLobby.tsx
                MultiverseTree.tsx
                ProjectSelectionModal.tsx
                RoundResultsModal.tsx
                SawaModal.tsx
                ScenarioTable.tsx
                ScoreSheet.tsx
                SettingsModal.tsx
                Sidebar.tsx
                SpeechBubble.tsx
                StoreModal.tsx
                SuitIcons.tsx
                Table.tsx
                VariantSelectionModal.tsx
                VictoryModal.tsx
                VisionaryStudio.tsx
                VisionaryVerifier.tsx
                Academy/
                    PuzzleArena.tsx
                ai-studio/
                    ActionSelector.tsx
                    BiddingLabView.tsx
                    BrainMemoryView.tsx
                    BuilderView.tsx
                    ReportsListView.tsx
                    TrainingView.tsx
                analytics/
                    BlunderGraph.tsx
                    WinProbabilityGraph.tsx
                effects/
                    HeartbeatLayer.tsx
                overlays/
                    ForensicOverlay.tsx
                    MindMapOverlay.tsx
                    ProfessorOverlay.tsx
                    QaydOverlay.tsx
                    WarRoomOverlay.tsx
                table/
                    ContractIndicator.tsx
                    PlayerAvatar.tsx
                    ScoreBadge.tsx
                    TurnTimer.tsx
                visualizations/
                    MindMapCity.tsx
                __tests__/
                    Table.test.tsx
            hooks/
                useGameRules.ts
                useGameState.ts
                useGameTension.ts
                useVoice.ts
            pages/
                AcademyPage.tsx
                PuzzleBoard.tsx
                PuzzleList.tsx
                ReplayPage.tsx
            services/
                AccountingEngine.ts
                botService.ts
                geminiService.ts
                index.ts
                SocketService.ts
                SoundManager.ts
                trainingService.ts
            utils/
                animationUtils.ts
                devLogger.ts
                gameLogic.test.ts
                gameLogic.ts
                index.ts
                scoring.test.ts
    game_engine/
        arena.py
        __init__.py
        logic/
            bidding_engine.py
            forensic.py
            game.py
            project_manager.py
            qayd_manager.py
            referee.py
            scoring_engine.py
            timer_manager.py
            trick_manager.py
            utils.py
            validation.py
            __init__.py
            phases/
                bidding_phase.py
                challenge_phase.py
                playing_phase.py
                __init__.py
        utils/
            serialization.py
        visionary/
            visionary.py
            __init__.py
    scripts/
        analyze_logs.py
        auto_label.py
        auto_play.py
        cat_logs.py
        check_img.py
        check_puzzles_api.py
        check_puzzle_detail_api.py
        cleanup.ps1
        cleanup_bot.py
        cleanup_bot_2.py
        cli_test_runner.py
        debug_revoke.py
        debug_validation_real.py
        debug_yolo_prediction.py
        diagnose_imports.py
        ensure_docker.ps1
        extract_frames.py
        fix_test_imports.py
        generate_benchmark.py
        generate_cards.py
        generate_codebase_context.py
        generate_mind_data.py
        generate_neural_data.py
        generate_roi_dataset.py
        inspect_py4web.py
        launch_ww.ps1
        lint.py
        list_db.py
        list_models.py
        measure_iq.py
        ping_redis.py
        profile_bots.py
        quick_check.py
        repro_circular.py
        restart_game.ps1
        restart_server.ps1
        run_arena.py
        run_nightly_scout.ps1
        run_test_suite.py
        scout.py
        seed_puzzles.py
        simulate_bot_vision.py
        simulate_game.py
        test_academy_api.py
        test_archival.py
        test_bot_qayd.py
        test_bot_qayd_full.py
        test_bot_qayd_multicard.py
        test_bot_qayd_trick_end.py
        test_db_persist.py
        test_hand_sync.py
        test_rate_limiter.py
        test_screenshot.py
        test_sherlock_trigger.py
        test_validation_logic.py
        test_visionary.py
        train_brain.py
        train_mind.py
        train_visionary_yolo.py
        verify_hybrid_performance.py
        verify_neural_performance.py
        verify_ports_temp.py
        verify_puzzles.py
        verify_schema_fix.py
        verify_with_gemini.py
        visualize_state.py
        verification/
            measure_bot_iq.py
            test_redis.py
            verify_ai_client.py
            verify_bots_e2e.py
            verify_brain.py
            verify_brain_pipeline.py
            verify_compliance.py
            verify_director.py
            verify_forensic_engine.py
            verify_game_flow.py
            verify_identity.py
            verify_mind_integration.py
            verify_multiverse_flow.py
            verify_personality.py
            verify_puzzle_gen.py
            verify_redis_brain.py
            verify_rounding.py
            verify_sawa.py
            verify_smart_bot.py
            verify_strict_legality.py
            verify_timers.py
            verify_time_lord.py
            verify_yolo_logger.py
    server/
        academy_controllers.py
        application.py
        auth_utils.py
        bot_orchestrator.py
        common.py
        controllers.py
        controllers_replay.py
        core_patch.py
        game_logger.py
        game_logic.py
        logging_utils.py
        main.py
        models.py
        puzzle_schema.py
        rate_limiter.py
        README.md
        room_manager.py
        serializers.py
        settings.py
        socket_handler.py
        tasks.py
        test_client.py
        __init__.py
        content/
            puzzles/
                basic_01_revoke.json
                exam_1769835452_d3f85038.json
                exam_1769837385_6794507b.json
                exam_1769837979_4596701f.json
                exam_1769930202_f3f907ba.json
                exam_1769935578_ddd5b8c8.json
                exam_1769936135_490c0ceb.json
                exam_1769937668_f6256c41.json
                exam_1769937697_f6256c41.json
                exam_1769953888_cc5e55a6.json
                exam_1769955637_65a19c94.json
                exam_1769956891_9daafb9d.json
                exam_1769957124_b055bc19.json
                exam_1769957127_b055bc19.json
                exam_1769957138_b055bc19.json
                exam_1769962662_b2ed38a0.json
                exam_1769963606_3376291a.json
                exam_1769964094_af364ff4.json
                exam_1769964099_af364ff4.json
                exam_1769964102_af364ff4.json
                exam_1769964108_af364ff4.json
                exam_1769964111_af364ff4.json
                exam_1769964284_fdba5d3d.json
                exam_1769964291_fdba5d3d.json
                exam_1769964440_207352df.json
                exam_1769972846_6b1a6ffa.json
                exam_1769973119_825e19b2.json
                exam_1769973143_825e19b2.json
                exam_1769987022_b62569fe.json
                exam_1769988803_feed187f.json
                exam_1770070329_cfa4bc90.json
                exam_1770070603_c57c1a0b.json
                exam_1770129452_61046bf4.json
                exam_1770130109_dbb2f496.json
                exam_1770160063_b0010e79.json
                exam_1770200861_b800206a.json
                exam_1770203870_afdbf722.json
                exam_1770209211_68efeed2.json
            puzzles_test/
                exam_1769726116_test_game_XYZ.json
        databases/
            fb87181b96a99be45f5a23f4277867ce_app_user.table
            fb87181b96a99be45f5a23f4277867ce_bot_training_data.table
            fb87181b96a99be45f5a23f4277867ce_foo.table
            fb87181b96a99be45f5a23f4277867ce_game_result.table
            fb87181b96a99be45f5a23f4277867ce_match_archive.table
        schemas/
            base.py
            cards.py
            game.py
            __init__.py
        services/
            archiver.py
        translations/
            it.json
        uploads/
            dataset/
    services/
        geminiService.ts
    tests/
        conftest.py
        headless_debug.py
        repro_qayd_reversion.py
        repro_qayd_score.py
        repro_qayd_user_revoke.py
        test_adaptive_atmosphere.py
        test_advanced_signaling.py
        test_ai_agent.py
        test_ai_queue.py
        test_ai_worker_coverage.py
        test_akka.py
        test_akka_strict.py
        test_ashkal.py
        test_ashkal_rules.py
        test_baloot_project.py
        test_bidding_engine.py
        test_bidding_engine_unit.py
        test_bidding_rules.py
        test_bot_crash.py
        test_bot_kawesh.py
        test_bot_scenarios.py
        test_bot_strategies.py
        test_bot_strategy.py
        test_builder.py
        test_connection.py
        test_data_flywheel.py
        test_dda.py
        test_feature_extractor.py
        test_flywheel.py
        test_full_scenario.py
        test_game_logic.py
        test_holographic_thought.py
        test_kawesh.py
        test_mashaari.py
        test_mcts_solver.py
        test_memory_hall.py
        test_oracle_bidding.py
        test_output.txt
        test_professor_mechanics.py
        test_projects_logic.py
        test_qayd_flow.py
        test_random_dealer.py
        test_rate_limiter.py
        test_resilience.py
        test_room_manager_redis.py
        test_rules_output.txt
        test_sawa.py
        test_scan.py
        test_scenarios.py
        test_scoring_comprehensive.py
        test_scoring_debug.py
        test_screenshot_analysis.py
        test_serialization.py
        test_signals.py
        test_sira.py
        test_socket_flow.py
        test_socket_handler.py
        test_socket_handler_coverage.py
        test_stress_game.py
        test_sun_kaboot.py
        test_timers.py
        test_variant_selection.py
        test_video_analysis.py
        test_waste_ace.json
        verify_sherlock_logic.py
        __init__.py
        ai_iq/
            iq_test_cases.json
        unit/
            test_qayd_trigger.py
            test_sherlock.py

==================================================

# üìù SOURCE CODE (Max Size: 10KB)

### FILE: .env.example
```example
GEMINI_API_KEY=your_gemini_api_key_here

```

### FILE: .gitignore
```
# Secrets
.env
.env.local
.env.*.local
*.pem
*.key

# Python
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
env/
venv/
pip-log.txt
pip-delete-this-directory.txt
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.log
.pytest_cache/

# Node
node_modules/
dist/
build/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.eslintcache

# System
.DS_Store
Thumbs.db

# IDE
.vscode/
!.vscode/extensions.json
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Large video files
.agent/knowledge/*.mp4

uploads/
*.mp4

# Generated Data
backend/data/
.agent/knowledge/video_frames/

# Visionary Studio (ML Artifacts)
dataset/
runs/
*.pt
*.cache
debug_*.jpg
roi_calibration_result.png
*.mp4
*.MOV

```

### FILE: claude_context_FULL.txt (SKIPPED - >10KB)
### FILE: claude_context_LITE.txt (SKIPPED - >10KB)
### FILE: claude_context_snapshot.txt (SKIPPED - >10KB)
### FILE: CODEBASE_MAP.md
```md
# Baloot AI Codebase Map

## Directory Structure

### `ai_worker/`
**Purpose**: Contains the autonomous AI logic, including the Bot Agent and its memory.
- `agent.py`: Main `BotAgent` class (formerly `bot_agent.py`). Handles decision making, Redis interaction, and strategy delegation.
- `memory.py`: `CardMemory` class (formerly `bot_memory.py`). Tracks played cards, void suits, and partner signals.
- `dialogue_system.py`: Generates trash talk and dialogue using Gemini.
- `strategies/`: Specific bidding and playing strategies.
- `signals/`: Collaborative Signaling Framework (Manager, Definitions, Emitter/Detector).
- `data/`: Training data and scout analysis results (formerly `backend/data`).
- `visionary/`: (See `game_engine/visionary`)

### `dataset/`
**Purpose**: YOLOv8 Training Data.
- `images/`: Training and Validation images (train/val).
- `labels/`: YOLO-format labels (txt) (train/val).
- `data.yaml`: YOLOv8 Configuration file.

### `models/`
**Purpose**: Trained ML Models.
- `yolo_v8n_baloot.pt`: Fine-tuned YOLOv8 Nano model for card recognition.

### `game_engine/`
**Purpose**: Core game logic independent of the web server.
- `logic/`
    - `game.py`: Main `Game` state machine.
    - `bidding_engine.py`: Handles the auction phase (Sun, Hokum, Gablak, etc.).
    - `trick_manager.py`: Handles trick resolution and validation.
    - `project_manager.py`: Handles declarations (Sira, Baloot, etc.).
    - `project_manager.py`: Handles declarations (Sira, Baloot, etc.).
    - `scoring_engine.py`: Calculates scores at end of round.
- `models/`: Data classes (Card, Deck, Constants).
- `visionary/`: **Visionary Studio** Core.
    - `visionary.py`: `VisionaryProcessor` (Frames), `CardRecognizer` (YOLO), `DatasetGenerator`.

### `server/`
**Purpose**: Web server infrastructure (Socket.IO, Flask/PyDAL).
- `socket_handler.py`: Entry point for WebSocket events. Delegates to `Game` and `BotAgent`.
- `room_manager.py`: Manages active game sessions.
- `models.py`: Database models (User, GameResult).
- `settings.py`: Configuration (Redis URL, etc.).

### `archive/`
**Purpose**: Legacy code and scripts.
- `legacy_server_node/`: Archived Node.js server.
- `legacy_server_node/`: Archived Node.js server.
- `legacy_patch.py`, `old_test_game_phases.py`: Archived scripts.

### `scripts/`
Refactored intofunctional groups:
- `verification/`: Integration tests (`verify_game_flow.py`, `verify_ai_client.py`).
- `visionary/`: **Visionary Studio Tools** (`train_visionary_yolo.py`, `auto_label.py`, `generate_roi_dataset.py`, `test_visionary.py`).
- `debugging/`: Tools for symptom analysis (`repro_crash.py`, `debug_screenshot.py`, `debug_yolo_prediction.py`).
- Root: Workflow entry points (`run_nightly_scout.ps1`, `restart_server.ps1`).

### `frontend/`
**Purpose**: React/Vite Frontend.
- `components/`: UI Components (Card, Table, Hand).
- `services/`: API and Socket services.
- `hooks/`: Custom React hooks (useGame, useSound).

## Key Flows

### Bot Decision Flow
1. `server/socket_handler.py` -> `bot_loop()` triggers `bot_agent.get_decision()`.
2. `ai_worker/agent.py` -> Checks `redis` for "Brain" overrides or delegates to `bidding_strategy` / `playing_strategy`.
3. Returns action to `socket_handler.py`, which calls `game.handle_bid()` or `game.play_card()`.

### Bidding Flow
1. User action `BID` -> `game.handle_bid()`.
2. `game.py` -> delegates to `bidding_engine.process_bid()`.
3. `bidding_engine.py` validates rules (Gablak, etc.) and updates `ContractState`.
4. `game.py` syncs state via `_sync_bid_state()` (for frontend/bot visibility).

```

### FILE: debug_init.py
```py

import sys
sys.path.append('c:\\Users\\MiEXCITE\\Projects\\baloot-ai')
from game_engine.logic.game import Game

try:
    g = Game("room")
    print(f"Has qayd_state: {hasattr(g, 'qayd_state')}")
    if hasattr(g, 'qayd_state'):
        print(f"qayd_state: {g.qayd_state}")
except Exception as e:
    print(f"Error: {e}")

```

### FILE: debug_state_alias.py
```py

import sys
import os

# Add project root to path
sys.path.append('c:\\Users\\MiEXCITE\\Projects\\baloot-ai')

from game_engine.logic.game import Game
from game_engine.logic.trick_manager import TrickManager

def test_alias():
    print("Initializing Game...")
    game = Game("debug_room")
    game.start_game()
    
    print(f"Game Qayd State ID: {id(game.qayd_state)}")
    print(f"TrickManager Qayd State ID: {id(game.trick_manager.qayd_state)}")
    
    if game.qayd_state is game.trick_manager.qayd_state:
        print("‚úÖ SUCCESS: Objects are aliased (Same Object).")
    else:
        print("‚ùå FAILURE: Objects are DIFFERENT (Split Brain).")
        
    # Simulate Challenge Phase trigger
    print("\nTriggering Challenge Phase...")
    game.phase = "CHALLENGE"
    
    # Simulate Divergence
    print("Modifying TrickManager state...")
    game.trick_manager.qayd_state['active'] = False
    
    print(f"Game Active: {game.qayd_state.get('active')}")
    print(f"TrickManager Active: {game.trick_manager.qayd_state.get('active')}")
    
    if game.qayd_state.get('active') == False:
        print("‚úÖ Sync check passed.")
    else:
        print("‚ùå Sync check FAILED.")

if __name__ == "__main__":
    test_alias()

```

### FILE: docker-compose.yml
```yml


services:
  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - baloot_net

  # AI Worker (The Brain) - To be implemented later
  # ai_worker:
  #   build: .
  #   command: python -m ai_worker.worker
  #   depends_on:
  #     - redis
  #   environment:
  #     - REDIS_URL=redis://redis:6379/0
  #     - GEMINI_API_KEY=${GEMINI_API_KEY}
  #   networks:
  #     - baloot_net

networks:
  baloot_net:
    driver: bridge

volumes:
  redis_data:

```

### FILE: LICENSE
```
MIT License

Copyright (c) 2026 Baloot AI Team

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

### FILE: MAJOR_TEST_REPORT.md
```md
# Major Test Report
**Date:** Feb 1, 2026
**Status:** ‚úÖ PASSED

## Executive Summary
The Major System Verification workflow (`Verify Game Flow`) was executed successfully against the full Citadel architecture (Redis + Python Backend).

## Test Details
*   **Workflow:** `/major-test`
*   **Script:** `scripts/verification/verify_game_flow.py`
*   **Duration:** ~45 seconds
*   **Participants:** 4 Simulated Bots

## Results
| Component | Status | Notes |
| :--- | :--- | :--- |
| **Connectivity** | ‚úÖ PASSED | Clients connected to port 3005 without issue. |
| **Room Creation** | ‚úÖ PASSED | Room `8b7031ff` created. |
| **Game Logic** | ‚úÖ PASSED | 119 turns played. Round completed. |
| **Rate Limiting** | ‚úÖ PASSED | **0 False Positives**. Logs audited: No `Rate Limit Exceeded` warnings during bot spam. |
| **State Persistence**| ‚úÖ PASSED | Redis verified via successful game state transitions. |

## Conclusion
The system is stable and ready for deployment or further manual testing. The Rate Limiter configuration (20/sec) is tuned correctly for safe but active gameplay.

```

### FILE: Makefile
```
# Makefile for managing a project with py4web and React

# Configuration
REACT_APP_FOLDER = frontend
REACT_BUILD_FOLDER = static/build

# Command to build the React app and move it to the py4web static folder
.PHONY: build-react
build-react:
	@echo "Building React app..."
	cd $(REACT_APP_FOLDER) && npm run build
	@echo "Moving build to py4web static folder..."
	rm -rf $(REACT_BUILD_FOLDER)/*
	cp -R $(REACT_APP_FOLDER)/build/* $(REACT_BUILD_FOLDER)/

```

### FILE: metadata.json
```json
{
  "name": "Baloot Master",
  "description": "A high-fidelity recreation of the popular Saudi Arabian card game Baloot, featuring an authentic Sadu-themed table, Arabic interface, and AI opponents powered by Google Gemini.",
  "requestFramePermissions": []
}
```

### FILE: mypy.ini
```ini
[mypy]
ignore_missing_imports = True
check_untyped_defs = True
disallow_untyped_defs = False
warn_return_any = True
warn_unused_ignores = True

[mypy-game_engine.logic.*]
disallow_untyped_defs = True

```

### FILE: nginx.conf
```conf
worker_processes 1;

events {
    worker_connections 1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;

    upstream py4web_backend {
        server 127.0.0.1:3005; # Gevent Server
    }

    server {
        listen       80;
        server_name  localhost;

        # 1. SERVE STATIC FILES DIRECTLY (Fast!)
        location /static/ {
            alias C:/Users/MiEXCITE/Projects/baloot-ai/server/static/;
            expires 30d;
            add_header Cache-Control "public, no-transform";
        }

        # 2. PROXY SOCKET.IO (WebSockets)
        location /socket.io/ {
            proxy_pass http://py4web_backend/socket.io/;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "Upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        # 3. PROXY API & DYNAMIC CONTENT
        location / {
            proxy_pass http://py4web_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}

```

### FILE: pytest.ini
```ini
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*

```

### FILE: README.md
```md
# Baloot AI & Game Engine ‚ô†Ô∏è

![Project Status](https://img.shields.io/badge/Status-Active-success)
![Python](https://img.shields.io/badge/Python-3.10+-blue)
![React](https://img.shields.io/badge/React-18-blue)
![Redis](https://img.shields.io/badge/Redis-Enabled-red)
![License](https://img.shields.io/badge/License-MIT-green)

A high-performance, multiplayer **Baloot** game engine featuring an advanced AI opponent ("The Brain"). This project combines traditional game rules with modern AI techniques (Reinforcement Learning & LLMs) to create a challenging and robust gaming experience.

## üåü Key Features

- **Hybrid AI System**:
  - **The Reflex**: Instant heuristic-based decision making for standard plays.
  - **The Brain**: Reinforcement Learning system that learns from game logs via Redis.
  - **The Scout**: Automated daily analysis tool that uses LLMs (Gemini) to find mistakes and generate training data.
- **Voice & Trash Talk**: Dynamic, personality-driven AI dialogue system. Bots speak in Arabic (Hejazi/Najdi dialects) using Text-to-Speech!
  - *Khalid (Aggressive)*, *Saad (Balanced)*, *Abu Fahad (Conservative)*.
- **Robust Multiplayer**: Resilient WebSocket architecture capable of handling disconnects and lag.
- **"The Professor" Mode üéì**: Real-time AI Coach that interrupts the game when you make a strategic blunder, explaining the mistake and offering a better move.
- **War Room Dashboard üìâ**: Live analytics showing Win Probability graphs and Blunder Heatmaps during gameplay.
- **AI Studio**: A dedicated dashboard for analyzing hands, debugging strategies, and replaying scenarios.
- **Premium UI**: Polished React frontend with `framer-motion` physics-based animations, glassmorphism design, and interactive feedback.

## üöÄ Quick Start

### Prerequisites
- **Python 3.10+**
- **Node.js 18+**
- **Docker Desktop** (for Redis)

### Installation

1.  **Clone the Repository**
    ```bash
    git clone https://github.com/tazjel/baloot-ai.git
    cd baloot-ai
    ```

2.  **Environment Setup**
    Copy the example environment file and add your API keys (for AI features).
    ```bash
    cp .env.example .env
    # Edit .env and add your GEMINI_API_KEY
    ```

3.  **Start Infrastructure & Backend**
    ```powershell
    # Start Redis
    docker-compose up -d redis

    # Install Python Dependencies
    pip install -r requirements.txt

    # Run Game Server
    python -m server.main
    ```

    **Pro Tip**: If you are on Windows, use the `/WW` slash command (or run `workflow_scripts/ww.ps1`) to launch everything at once!

4.  **Start Frontend**
    ```bash
    cd frontend
    npm install
    npm start
    ```
    The game will be available at `http://localhost:3000`.

## üìÇ Project Structure

- **`server/`**: Core backend application (Game logic, Socket handlers, Controllers).
- **`game_engine/`**: Reusable game logic engine.
- **`frontend/`**: React-based user interface.
- **`ai_worker/`**: AI Strategy and decision making.
- **`scripts/`**: Development and testing utilities.
- **`docs/`**: In-depth documentation, status reports, and project history.
- **`logs/`**: Application and testing logs.

## üìö Documentation

- **[Architecture Overview](docs/ARCHITECTURE.md)**: Logic separation, AI Flywheel, and Redis integration.
- **[Frontend Guide](docs/FRONTEND_GUIDE.md)**: Architecture, State Management, and UI Systems.
- **[Contributing Guide](docs/CONTRIBUTING.md)**: Setup, testing, and code style.
- **[Codebase Map](CODEBASE_MAP.md)**: Master index for AI Agents.
- **[Game Rules](https://en.wikipedia.org/wiki/Baloot)**: Standard Baloot rules implementation details.

## üõ†Ô∏è Configuration

| Variable | Description | Default |
|----------|-------------|---------|
| `REDIS_HOST` | Redis Host address | `localhost` |
| `REDIS_PORT` | Redis Port | `6379` |
| `OFFLINE_MODE` | Play without Redis | `false` |

## ü§ù Contributing

We welcome contributions! Please check our [Contributing Guide](docs/CONTRIBUTING.md) and [Code of Conduct](docs/CODE_OF_CONDUCT.md) for details.

1.  Fork the Project
2.  Create your Feature Branch (`git checkout -b feature/AmazingFeature`)
3.  Commit your Changes (`git commit -m 'Add some AmazingFeature'`)
4.  Push to the Branch (`git push origin feature/AmazingFeature`)
5.  Open a Pull Request

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## üôè Acknowledgments

- **Py4Web**: For the Python backend framework inspiration.


```

### FILE: requirements.txt
```txt
anyio==3.7.1
bcrypt==4.1.2
certifi==2023.11.17
cffi==1.16.0
charset-normalizer==3.3.2
click==8.1.7
colorama==0.4.6
cryptography==41.0.7
exceptiongroup==1.2.0
idna==3.6
ombott==1.0.0
pluralize==20231008.1
portalocker==2.8.2
py4web==1.20231115.1
pycparser==2.21
pycryptodome==3.19.0
pydal==20231114.3
PyJWT==2.8.0
renoir==1.7.0
requests==2.31.0
rocket3==20231022.2
sniffio==1.3.0
threadsafevariable==20230507.1
tornado==6.4
urllib3==2.1.0
watchgod==0.8.2
yatl==20230507.3
python-socketio==5.11.0
greenlet==3.0.3
gevent==23.9.1
simple-websocket==1.0.0
google-generativeai==0.3.2
python-dotenv==1.0.0
pytest==7.4.3
redis==5.0.1
google-generativeai==0.3.2

```

### FILE: run_verify.py
```py

import subprocess
import os

try:
    with open('logs/verify_output.txt', 'w', encoding='utf-8') as f:
        subprocess.call(['python', 'tests/verify_sherlock_logic.py'], stdout=f, stderr=subprocess.STDOUT)
    print("Verification complete. Check logs/verify_output.txt")
except Exception as e:
    print(f"Error: {e}")

```

### FILE: __init__.py
```py
# check compatibility
import py4web

assert py4web.check_compatible("0.1.20190709.1")

# by importing db you expose it to the _dashboard/dbadmin
try:
    from .models import db
    # by importing controllers you expose the actions defined in it
    from . import controllers
except ImportError:
    pass # Running in loose script/test mode


# optional parameters
__version__ = "0.0.0"
__author__ = "you <you@example.com>"
__license__ = "anything you want"





```

### FILE: ai_worker\agent.py (SKIPPED - >10KB)
### FILE: ai_worker\bot_context.py
```py
from game_engine.models.card import Card
from game_engine.models.constants import ORDER_SUN, ORDER_HOKUM, BiddingPhase, BidType
from ai_worker.personality import PersonalityProfile, BALANCED
import functools

class BotContext:
    """Typed wrapper for game state to simplify bot logic."""
    def __init__(self, game_state: dict, player_index: int, personality: PersonalityProfile = BALANCED):
        self.raw_state = game_state
        self.player_index = player_index
        self.personality = personality
        
        # Parse Player
        p_data = game_state['players'][player_index]
        self.hand = [Card(c['suit'], c['rank']) for c in p_data['hand']]
        self.position = p_data.get('position', 'Unknown')
        self.name = p_data.get('name', f"Player {player_index}")
        self.team = p_data.get('team', 'Unknown')
        self.avatar = p_data.get('avatar', 'bot_1')

        
        # Parse Game Info
        self.phase = game_state.get('phase')
        self.mode = game_state.get('gameMode')
        self.trump = game_state.get('trumpSuit')
        self.dealer_index = game_state.get('dealerIndex', 0)
        self.bidding_round = game_state.get('biddingRound', 1)
        self.floor_card = None
        if game_state.get('floorCard'):
             fc = game_state['floorCard']
             self.floor_card = Card(fc['suit'], fc['rank'])
             
        # Parse Table
        self.table_cards = []
        for tc in game_state.get('tableCards', []):
             c = tc['card']
             self.table_cards.append({
                  'card': Card(c['suit'], c['rank']),
                  'playedBy': tc['playedBy']
             })
             
        # Derived
        self.is_dealer = (self.player_index == self.dealer_index)
        self.akka_state = game_state.get('akkaState', None)
        
        # Core Components
        from ai_worker.memory import CardMemory
        from ai_worker.mind_client import mind_client
        self.memory = CardMemory()
        self.memory.populate_from_state(self.raw_state)
        self.mind = mind_client # Use singleton
        
        # Play State
        self.played_cards = self.memory.played_cards # Delegate to robust memory
        # ... table_cards parsing remains for immediate context ...
             
        self.lead_suit = None
        self.lead_card = None
        self.winning_card = None
        self.winner_pos = None
        
        if self.table_cards:
             self.lead_card = self.table_cards[0]['card']
             self.lead_suit = self.lead_card.suit
             
             # Determine current winner
             best_idx = 0
             best_card = self.lead_card
             for i, tc in enumerate(self.table_cards):
                  c = tc['card']
                  beats = False
                  # Simple beat check
                  if self.mode == 'HOKUM':
                       if c.suit == self.trump and best_card.suit != self.trump: beats = True
                       elif c.suit == self.trump and best_card.suit == self.trump:
                            beats = self._compare_ranks(c.rank, best_card.rank, 'HOKUM')
                       elif c.suit == self.lead_suit and best_card.suit == self.lead_suit:
                            beats = self._compare_ranks(c.rank, best_card.rank, 'SUN')
                  else: # SUN
                       if c.suit == self.lead_suit:
                            beats = self._compare_ranks(c.rank, best_card.rank, 'SUN')
                            
                  if beats:
                       best_card = c
                       best_idx = i
             
             self.winning_card = best_card
             self.winner_pos = self.table_cards[best_idx]['playedBy']

    @property
    def bidding_phase(self) -> BiddingPhase:
        """Typed accessor for bidding phase."""
        try:
             val = self.raw_state.get('biddingPhase')
             return BiddingPhase(val) if val else None
        except ValueError:
             return None

    @property
    def bid_winner(self):
        """Returns the position of the player who won the bid."""
        return self.raw_state.get('bid', {}).get('bidder')

    def _compare_ranks(self, r1, r2, mode):
        # Return True if r1 > r2
        ord_list = ORDER_HOKUM if mode == 'HOKUM' else ORDER_SUN
        try:
             idx1 = ord_list.index(r1)
             idx2 = ord_list.index(r2)
             return idx1 > idx2
        except ValueError:
             return False

    def is_master_card(self, card):
        # Delegate to memory
        return self.memory.is_master(card.rank, card.suit, self.mode, self.trump)
        
    def is_opponent_void(self, suit):
        # Check if ANY opponent is void in this suit?
        # Or check specific players?
        # Usually we want to know if *current winner* is void?
        # Or if *next player* is void (to avoid them cutting)?
        # For simplicity, let's expose specific check.
        return False # Placeholder if needed, but direct memory access preferred

    def is_player_void(self, position, suit):
        """Checks if a player is known to be void in a suit based on memory."""
        # Map Position Name (Bottom) to Index (for memory lookups if needed)
        # But memory stores by Position Name/Ref?
        # populate_from_state handles this.
        return self.memory.is_void(position, suit)
        
    def get_legal_moves(self):
        """
        Returns a list of indices of legal cards to play from hand.
        Uses shared validation logic.
        """
        from game_engine.logic.validation import is_move_legal
        
        
    @functools.cached_property
    def players_team_map(self) -> dict[str, str]:
        """Performance: Cache team map to avoid repeated list comprehensions in MCTS."""
        return {p['position']: p['team'] for p in self.raw_state['players']}

    def get_legal_moves(self):
        """
        Returns a list of indices of legal cards to play from hand.
        Uses shared validation logic.
        """
        from game_engine.logic.validation import is_move_legal
        
        legal_indices = []
        players_team_map = self.players_team_map
        table_cards = self.raw_state.get('tableCards', [])
        
        # Parse table cards to match what validator expects (dicts of Card/playedBy)
        # Assuming raw_state tableCards are already dicts with 'card' as dict?
        # Validator expects 'card' to be Card OBJECT.
        # We need to convert them.
        
        # Convert table cards to objects for validation
        real_table_cards = []
        for tc in table_cards:
             c_dict = tc['card']
             c_obj = Card(c_dict['suit'], c_dict['rank'])
             real_table_cards.append({'card': c_obj, 'playedBy': tc['playedBy']})
             
        contract_variant = None
        bid = self.raw_state.get('bid', {})
        # Assuming 'variant' is in bid? Or do we need to check strict structure?
        # Usually bid is just {type: 'HOKUM', suit...}
        # If 'variant' key exists (for Magfool), use it.
        # Currently the game state might not expose variant directly in simple bid dict?
        # But let's assume standard closed/open if HOKUM.
        
        # If not present, assume OPEN for now unless we can find it.
        # Actually, bidding_engine.contract has variant.
        # raw_state might need to be enriched if missing.
        
        for i, card in enumerate(self.hand):
             is_legal = is_move_legal(
                 card=card,
                 hand=self.hand,
                 table_cards=real_table_cards,
                 game_mode=self.mode, # Corrected from self.game_mode
                 trump_suit=self.trump, # Corrected from self.trump_suit
                 my_team=self.team,
                 players_team_map=players_team_map,
                 contract_variant=bid.get('variant') # Pass variant if available
             )
             if is_legal:
                  legal_indices.append(i)
                  
                  
        return legal_indices

    def guess_hands(self):
        """
        Uses the MindReader AI to predict opponent hands based on game history.
        Returns: { player_id: { card_idx: probability } }
        """
        if self.mind and self.mind.active:
             return self.mind.infer_hands(self.raw_state)
        return None

```

### FILE: ai_worker\brain_client.py
```py
import os
import time
import json
import logging
import hashlib
import traceback

# Settings
try:
    from server.settings import REDIS_URL, OFFLINE_MODE
except ImportError:
    REDIS_URL = "redis://localhost:6379/0"
    OFFLINE_MODE = False

# Redis
try:
    import redis
except ImportError:
    redis = None

logger = logging.getLogger(__name__)

class BrainClient:
    """
    Handles all interactions with 'The Brain' (Redis Layer).
    - Looks up learned moves.
    - Queues game states for analysis (The Scout).
    - Captures data for the Flywheel.
    """
    def __init__(self):
        self.redis_client = None
        self._connect()

    def _connect(self):
        if OFFLINE_MODE:
             logger.info("[BRAIN] OFFLINE_MODE. Redis disabled.")
             return

        if redis:
            try:
                self.redis_client = redis.from_url(REDIS_URL, decode_responses=True, socket_timeout=1.0)
                logger.info("[BRAIN] Connected to Redis.")
            except Exception as e:
                logger.error(f"[BRAIN] Redis connection failed: {e}")

    def lookup_move(self, context_hash: str):
        """
        Check if The Brain has a correct move for this exact context.
        Returns the move dict if found, else None.
        """
        if not self.redis_client: return None

        try:
            start = time.perf_counter()
            # 1. Check for "Certified Correct" move
            key = f"brain:correct:{context_hash}"
            move_json = self.redis_client.get(key)

            # 2. Fallback: Check for "Manual Test Override" (for debugging)
            if not move_json:
                manual_key = "brain:move:FORCE_OVERRIDE_TEST"
                move_json = self.redis_client.get(manual_key)
                if move_json:
                     logger.info(f"[BRAIN] Force Override Triggered for {context_hash}")

            duration = (time.perf_counter() - start) * 1000
            if duration > 50: # strict perf log
                 logger.debug(f"[BRAIN] Lookup took {duration:.2f}ms")

            if move_json:
                return json.loads(move_json)
            
            return None

        except Exception as e:
            logger.error(f"[BRAIN] Lookup Error: {e}")
            return None

    def queue_analysis(self, ctx_payload: dict):
        """
        Push current context to the analysis queue for asynchronous processing.
        """
        if not self.redis_client: return

        try:
            self.redis_client.lpush("bot:analyze_queue", json.dumps(ctx_payload))
        except Exception as e:
            # Silent fail for fire-and-forget
            pass

    def capture_round_data(self, round_snapshot: dict):
        """
        Push finished round data to the analytics stream.
        """
        if not self.redis_client: return

        try:
            # Cap stream length to prevent memory leaks
            self.redis_client.xadd("analytics:hand_finished", {'data': json.dumps(round_snapshot)}, maxlen=1000)
        except Exception as e:
            self.redis_client.xadd("analytics:hand_finished", {'data': json.dumps(round_snapshot)}, maxlen=1000)
        except Exception as e:
            logger.error(f"[BRAIN] Failed to capture data: {e}")

    def publish_mind_map(self, game_id, player_index, probs):
        """
        Publish "Theory of Mind" probabilities to Redis for frontend visualization.
        probs: { opponent_idx: [32 floats] }
        """
        if not self.redis_client: return
        
        try:
             # Convert numpy to list/float
             serializable_probs = {}
             for k, v in probs.items():
                 # v is numpy array usually
                 if hasattr(v, 'tolist'):
                     serializable_probs[k] = v.tolist()
                 else:
                     serializable_probs[k] = v
                     
             key = f"bot:mind_map:{game_id}:{player_index}"
             self.redis_client.set(key, json.dumps(serializable_probs), ex=60) # 1 min TTL
        except Exception as e:
             logger.error(f"[BRAIN] Failed to publish mind map: {e}")

```

### FILE: ai_worker\cognitive.py
```py

import logging
from ai_worker.bot_context import BotContext
from ai_worker.mcts.mcts import MCTSSolver
from ai_worker.mcts.utils import generate_random_distribution
from ai_worker.mcts.fast_game import FastGame
from ai_worker.learning.dataset_logger import DatasetLogger

logger = logging.getLogger(__name__)

class CognitiveOptimizer:
    """
    The 'Brain' of the AI: Handles simulation-based decision making.
    Encapsulates MCTS, Hand Estimation, and Fast Simulation.
    """
    def __init__(self, use_inference=True, neural_strategy=None):
        self.solver = MCTSSolver(neural_strategy=neural_strategy)
        self.use_inference = use_inference
        self.enabled = True
        # YOLO Configuration: Only log highly confident moves (95%)
        # Buffer 50 moves before writing to disk
        self.dataset_logger = DatasetLogger(min_confidence=0.95, buffer_size=50)

    def get_decision(self, ctx: BotContext) -> dict:
        """
        Attempts to find the optimal move using MCTS.
        """
        if not self.enabled: return None
        
        # Trigger Condition: Run always for data collection
        if len(ctx.hand) == 0:
            return None
            
        try:
            # 1. Probabilistic Inference (Hand Estimation)
            # Guess opponent hands based on voids and played cards
            hands = generate_random_distribution(ctx)
            
            # 2. Simulation Environment Setup
            # Map BotContext (Rich State) -> FastGame (Lite State)
            
            # Note: FastGame expects hands[0] to be the current player's hand?
            # generate_random_distribution puts ctx.hand at index 0.
            # And FastGame simulation starts from 'current_turn'.
            # If it's MY turn (Bot), then current_turn should be 0 (relative to hands[0]).
            
            # Ideally, FastGame is initialized with absolute positions and turn.
            # But FastGame logic is simplified.
            # Let's align with the confirmed working logic in playing.py:
            # "current_turn=0 # Bot is acting now"
            
            fast_game = FastGame(
                players_hands=hands,
                trump=ctx.trump,
                mode=ctx.mode,
                current_turn=0, # Bot perspective: I am 0, and it is my turn.
                dealer_index=ctx.raw_state.get('dealerIndex', 0), # This might need mapping if dealer relative to bot?
                table_cards=ctx.raw_state.get('tableCards', [])
            )
            
            # 3. Execution (The Oracle)
            # Calculate Adaptive Budget
            budget = self._calculate_budget(ctx)
            
            # 3. Execution (The Oracle)
            best_idx, details = self.solver.search_with_details(
                fast_game, 
                timeout_ms=500, # Increased timeout
                max_iterations=budget
            )
            
            # DATASET LOGGING (Neural Net Training)
            try:
                if self.dataset_logger:
                    self.dataset_logger.log_sample(ctx, best_idx, details)
            except: 
                pass
            
            return {
                "cardIndex": best_idx,
                "reasoning": f"Oracle (MCTS) - Budget {budget} - Verified {len(ctx.hand)} cards"
            }
            
        except Exception as e:
            logger.error(f"Cognitive Engine Failed: {e}", exc_info=False)
            # Ideally minimal logging to avoid spam in production, or verbose if debugging.
            return None

    def _calculate_budget(self, ctx: BotContext) -> int:
        """
        Dynamic Difficulty Adjustment (DDA).
        Adjusts simulation budget based on score difference.
        """
        base_budget = 2000
        
        # Get scores
        scores = ctx.raw_state.get('matchScores', {'us': 0, 'them': 0})
        us_score = scores.get('us', 0)
        them_score = scores.get('them', 0)
        
        diff = us_score - them_score
        
        # MERCY RULE: If we are winning big, play dumb.
        if diff > 50:
            return 500
            
        # PANIC RULE: If we are losing big, try harder.
        if diff < -50:
            return 5000
            
        return base_budget

    def analyze_position(self, ctx: BotContext) -> dict:
        """
        Returns detailed analysis of the current position using MCTS.
        Returns dict with keys: 'best_move', 'move_values' (dict of move_idx -> stats).
        """
        if not self.enabled: return None
        
        try:
            # 1. Probabilistic Inference
            hands = generate_random_distribution(ctx)
            
            # 2. Simulation Environment Setup
            fast_game = FastGame(
                players_hands=hands,
                trump=ctx.trump,
                mode=ctx.mode,
                current_turn=0,
                dealer_index=ctx.raw_state.get('dealerIndex', 0),
                table_cards=ctx.raw_state.get('tableCards', [])
            )
            
            # 3. Execution
            best_idx, details = self.solver.search_with_details(fast_game, timeout_ms=300)
            
            return {
                "best_move": best_idx,
                "move_values": details
            }
            
        except Exception as e:
            logger.error(f"Cognitive Analysis Failed: {e}", exc_info=False)
            return None

```

### FILE: ai_worker\dialogue_system.py
```py
import os
import random
import logging
import time
import google.generativeai as genai
from dotenv import load_dotenv
from typing import Optional
from ai_worker.personality import PersonalityProfile, BALANCED

# Load env variables
# Load env variables
# Strategy: Look up 2 dirs from here (project root)
env_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), '.env')
load_dotenv(dotenv_path=env_path)

GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
GEMINI_ENABLED = False # User requested disable

class DialogueSystem:
    def __init__(self):
        self.logger = logging.getLogger("DialogueSystem")
        self.model = None
        self.logger = logging.getLogger("DialogueSystem")
        self.model = None
        # self._last_call_time = 0 # DEPRECATED: Using TokenBucket
        self._setup_model()

    def _setup_model(self):
        if not GEMINI_ENABLED:
             self.logger.warning("Gemini Integration DISABLED by configuration. Using fallback responses.")
             return

        if not GEMINI_API_KEY:
            self.logger.warning("GEMINI_API_KEY not found. DialogueSystem disabled (fallback only).")
            return

        try:
            genai.configure(api_key=GEMINI_API_KEY)
            # Use gemini-flash-latest as verified in Scout phase
            self.model = genai.GenerativeModel('gemini-flash-latest',
                generation_config=genai.GenerationConfig(
                    temperature=1.1,
                    top_p=0.95,
                    max_output_tokens=40,
                )
            )
            self.logger.info("DialogueSystem initialized with Gemini 1.5 Flash")
        except Exception as e:
            self.logger.error(f"Failed to initialize Gemini: {e}")

    def generate_reaction(self, player_name: str, personality: PersonalityProfile, context: str, game_state: dict = None, rivalry_summary: dict = None) -> Optional[str]:
        """
        Generates a reaction line. Returns None if generation fails or is rate-limited.
        This method is BLOCKING and should be run in a thread.
        """
        # Rate Limit: Use Token Bucket (Global)
        from ai_worker.rate_limiter import global_gemini_limiter
        
        if not global_gemini_limiter.acquire(blocking=False):
             self.logger.warning(f"Rate Limit Hit (Tokens exhausted). Using fallback for {player_name}.")
             return self._get_fallback_message(personality)

        # 50% Chance to just use fallback/silence to avoid noise?
        # Let's say for "Trash Talk" feature verification, we want high frequency: 100%
        
        if not self.model:
            return self._get_fallback_message(personality)

        prompt = self._construct_prompt(player_name, personality, context, rivalry_summary)

        try:
            # self._last_call_time = time.time() # Managed by TokenBucket
            # Safety settings to allow banter
            safety_settings = [
                {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
            ]
            
            response = self.model.generate_content(prompt, safety_settings=safety_settings)
            
            text = ""
            if response.candidates and response.candidates[0].content.parts:
                text = response.candidates[0].content.parts[0].text
            else:
                 # Try direct text accessor if possible, but safe logic above covers most
                 try:
                     text = response.text
                 except:
                     pass

            if text:
                text = text.strip().replace('"', '').replace("'", "")
                # remove prefixes like "Reaction:" if any
                if ":" in text:
                    text = text.split(":", 1)[1].strip()
                return text
            return self._get_fallback_message(personality)
        except Exception as e:
            if "429" in str(e):
                 self.logger.error(f"Gemini QUOTA EXCEEDED (429). Check Billing/Plan. Fallback used.")
            else:
                 self.logger.error(f"Gemini generation error: {e}")
            return self._get_fallback_message(personality)

    def _construct_prompt(self, player_name: str, personality: PersonalityProfile, context: str, rivalry_summary: dict = None) -> str:
        rivalry_text = ""
        if rivalry_summary:
            if rivalry_summary.get('status') == 'novice':
                 rivalry_text = "Opponent is a NOVICE. Be condescending."
            elif rivalry_summary.get('wins_vs_ai', 0) > rivalry_summary.get('total_losses', 0):
                 rivalry_text = "Opponent is WINNING the rivalry. Act jealous or vengeful."
            else:
                 rivalry_text = "You are DOMINATING this opponent. Mock them."
                 
            if rivalry_summary.get('nemesis') == player_name:
                 rivalry_text += " You are their NEMESIS. Rub it in."

        return f"""
Roleplay: You are {player_name}, a Baloot card game player in Saudi Arabia.
Personality: {personality.description} (Key traits: {personality.name})
Language: Arabic (Saudi Hejazi/Najdi Dialect). Use terms like "Sira", "Hakam", "Kaboot", "Akal", "Ya Ghashim", "Bunt", "Ikka".
Current Situation: {context}
Relationship: {rivalry_text}

Task: Shout a short, reactive 1-sentence comment (max 6 words). 
- If you are winning/aggressive, trash talk in Arabic.
- If you are losing/conservative, complain or apply "Hasad" in Arabic.
- Be funny, authentic, and use common Saudi interjections (Wallah, Ya Akhi, etc.).
- OUTPUT ARABIC TEXT ONLY.
"""

    def _get_fallback_message(self, personality: PersonalityProfile) -> str:
        # Simple Arabic fallbacks
        fallbacks = ["ŸäŸÑÿß ÿßŸÑÿπÿ®!", "Ÿàÿ¥ ÿ∞ÿß ÿßŸÑŸÑÿπÿ®ÿü", "ÿ≥ÿ±ÿß!", "Ÿäÿß ŸáŸàŸàŸà", "ÿ®ÿ≥ÿ±ÿπÿ© Ÿäÿß ŸÉÿßÿ®ÿ™ŸÜ"]
        return random.choice(fallbacks)

```

### FILE: ai_worker\llm_client.py
```py

import os
import google.generativeai as genai
import logging
# from server.settings import GEMINI_API_KEY # Removed
from server.common import logger
from dotenv import load_dotenv

# Ensure env is loaded
if not os.environ.get("GEMINI_API_KEY"):
    load_dotenv(os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".env")))

# Configure API
api_key = os.environ.get("GEMINI_API_KEY")
GEMINI_ENABLED = False # User requested disable

if GEMINI_ENABLED and api_key:
    genai.configure(api_key=api_key)
else:
    logger.warning("GEMINI_API_KEY not found in environment!")

class GeminiClient:
    def __init__(self, model_name="gemini-flash-latest"):
        self.model_name = model_name
        if GEMINI_ENABLED:
            self.model = genai.GenerativeModel(model_name)
        else:
            self.model = None
            logger.info("GeminiClient initialized in DISABLED mode.")
        
    def analyze_image(self, image_bytes, mime_type="image/jpeg"):
        """Analyze an image byte stream."""
        try:
            if not self.model: return None
            
            prompt = "Analyze this screenshot of a Baloot game. Identify the cards on the table, the user's hand, the scores, and the current bid/trump. Return JSON."
            
            response = self.model.generate_content([
                prompt,
                {"mime_type": mime_type, "data": image_bytes}
            ])
            return response.text
        except Exception as e:
            logger.error(f"Gemini Image Analysis Failed: {e}")
            return None

    def analyze_video(self, video_path, mime_type="video/mp4"):
        """Analyze a video file."""
        try:
            if not self.model: return None
            
            # File API upload is required for video
            video_file = genai.upload_file(path=video_path)
            
            # Wait for processing? Usually quick for small calls, but loop might be needed.
            # For now, simplistic implementation.
            
            prompt = "Analyze this video of a Baloot game. Describe the flow of the game, any mistakes made, and the final outcome."
            
            response = self.model.generate_content([prompt, video_file])
            return response.text
        except Exception as e:
            logger.error(f"Gemini Video Analysis Failed: {e}")
            return None

    def analyze_hand(self, context, examples=None):
        """
        Analyze a hand and recommend a move.
        context: Dict containing hand, table, scores, etc.
        examples: List of few-shot examples.
        """
        try:
            if not self.model: return None
            
            prompt_parts = []
            
            # System Prompt
            system_prompt = """You are a Baloot Grandmaster. Analyze the current game state and recommend the best move. 
            Consider:
            1. The Game Mode (Sun/Hokum).
            2. The Trump Suit (if Hokum).
            3. The cards on the table.
            4. Your hand.
            5. The scores and potential risks (eating lots of points).
            
            Response Format: JSON { "action": "PLAY", "card": "RankSuit", "reasoning": "..." }
            """
            prompt_parts.append(system_prompt)
            
            # Few-Shot Examples (RAG)
            if examples:
                prompt_parts.append("Here are some examples of correct play in similar situations:\n")
                for ex in examples:
                    prompt_parts.append(f"State: {ex['state']}\nCorrect Move: {ex['correct_move']}\nReasoning: {ex['reason']}\n---\n")
            
            # Current Context
            import json
            prompt_parts.append(f"Current Game State:\n{json.dumps(context, indent=2)}")
            
            response = self.model.generate_content(prompt_parts)
            return response.text
        except Exception as e:
            logger.error(f"Gemini Hand Analysis Failed: {e}")
            return None

    def generate_scenario_from_text(self, text):
        """Generate a Baloot game scenario JSON from natural language."""
        try:
            if not self.model: return None

            prompt = f"""Generate a valid Baloot Game State JSON from this description: "{text}".
            Include players, hands, table cards, bid, and trump.
            JSON:
            """
            response = self.model.generate_content(prompt)
            return response.text
        except Exception as e:
            logger.error(f"Gemini Scenario Generation Failed: {e}")
            return None

    def analyze_match_history(self, history):
        """Analyze a full match history."""
        try:
            if not self.model: return None

            import json
            history_str = json.dumps(history[:50]) # Truncate to avoid token limits if huge
            
            prompt = f"""Analyze this Baloot match history. Identify the turning point and any mistakes.
            Return a purely JSON response with this structure:
            {{
                "summary": "text summary",
                "moments": [
                    {{
                        "context_hash": "hash_if_available", 
                        "description": "Critical moment description",
                        "correct_move": "CardRank+Suit", 
                        "reasoning": "Why this was the mistake/turning point"
                    }}
                ]
            }}
            Do NOT use markdown code blocks. Just raw JSON.
            History: {history_str}
            """
             
            response = self.model.generate_content(prompt)
            return response.text
        except Exception as e:
            logger.error(f"Gemini Match Analysis Failed: {e}")
            return None

```

### FILE: ai_worker\memory.py
```py
import logging

logger = logging.getLogger(__name__)

SUITS = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£']
RANKS = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A']

class CardMemory:
    def __init__(self):
        self.reset()

    def is_card_played(self, rank, suit):
        return f"{rank}{suit}" in self.played_cards

    def get_remaining_cards(self):
        remaining = []
        for s in SUITS:
            for r in RANKS:
                c_str = f"{r}{s}"
                if c_str not in self.played_cards:
                    remaining.append({'rank': r, 'suit': s})
        return remaining

    def get_remaining_in_suit(self, suit):
        return [c for c in self.get_remaining_cards() if c['suit'] == suit]

    def reset(self):
        self.played_cards = set()
        self.voids = {} # Player Ref -> Set of Suits
        self.discards = {} # Player Ref -> List of Discard Events
        self.partners_aces = set() 
        self.turn_history = [] 
        # Proof-Based Qayd: Track suspected crimes until proof is found
        # Structure: [{'player': 'Right', 'trick_idx': 2, 'crime_card': {...}, 'void_suit': 'H'}, ...]
        self.suspected_crimes = [] 

    def mark_played(self, card_str):
        self.played_cards.add(card_str)

    def populate_from_state(self, game_state):
        """
        Rebuilds memory from the full game history provided in the state.
        Critically, this infers VOIDS based on player actions.
        
        TODO: Upgrade to "Mind's Eye" Probabilistic Memory.
        Current implementation uses binary voids (Has Suit / Void).
        Future: self.hand_distributions = {player: {suit: prob}}
        """
        self.reset()
        
        # 1. Mark Table Cards as Played
        for tc in game_state.get('tableCards', []):
             c = tc['card']
             self.mark_played(f"{c['rank']}{c['suit']}")
             
        # 2. Process Round History (Tricks)
        # Assuming round_history / currentRoundTricks structure:
        # [{'winner': 'Bottom', 'cards': [{'suit': 'S', 'rank': 'A', 'playedBy': 'Bottom'}, ...]}, ...]
        
        history = game_state.get('currentRoundTricks', [])
        # Also check 'pastRoundResults' for previous rounds if we wanted long-term memory?
        # No, Baloot memory is per-round (cards are reshuffled).
        
        trump = game_state.get('trumpSuit')
        mode = game_state.get('gameMode')
        
        for trick in history:
            led_suit = None
            if trick.get('cards'):
                 # Need to handle if cards are objects or dicts
                 first_card = trick['cards'][0]
                 # first_card might be wrapper dict {card: {suit, rank}, playedBy: ...} or just {suit, rank}
                 # Standardize access
                 c_dict = first_card if 'rank' in first_card else first_card.get('card', {})
                 led_suit = c_dict.get('suit')
                 
            involved_players = trick.get('playedBy', []) # Parallel list
                 
            for i, c_data in enumerate(trick.get('cards', [])):
                 # Normalize card data
                 c_inner = c_data if 'rank' in c_data else c_data.get('card', {})
                 rank = c_inner.get('rank')
                 suit = c_inner.get('suit')
                 
                 # Robust Player Position Extraction
                 player_pos = c_data.get('playedBy')
                 if not player_pos and i < len(involved_players):
                      player_pos = involved_players[i]
                 
                 if not player_pos or not rank or not suit:
                      continue

                 # Mark Played
                 self.mark_played(f"{rank}{suit}")
                 
                 # PROOF-BASED QAYD: Check if this play proves a suspected crime
                 # If player is playing a suit they previously claimed void in -> PROOF!
                 trick_idx = history.index(trick)
                 proven_crime = self.check_for_proof(player_pos, suit, trick_idx)
                 if proven_crime:
                      # Store the proof card
                      proven_crime['proof_card'] = {'rank': rank, 'suit': suit}
                 
                 # Infer Voids
                 if led_suit and suit != led_suit:
                      # Player failed to follow suit -> VOID in led_suit
                      self.mark_void(player_pos, led_suit)
                      logger.info(f"[MEMORY] Inferring VOID: Player {player_pos} has no {led_suit} (Played {suit} on {led_suit})")
                      
                      # Track Discard for Signaling History
                      if player_pos not in self.discards: self.discards[player_pos] = []
                      self.discards[player_pos].append({
                          'rank': rank,
                          'suit': suit,
                          'trick_idx': history.index(trick)
                      })
                      
                      # PROOF-BASED QAYD: Record suspected crime
                      # The crime card is what they played (wrong suit)
                      # The void_suit is the suit they claimed not to have
                      self.record_suspected_crime(
                          player_pos=player_pos,
                          trick_idx=history.index(trick),
                          crime_card={'rank': rank, 'suit': suit},
                          void_suit=led_suit
                      )
                      
                      if mode == 'HOKUM' and led_suit != trump and suit != trump:
                           self.mark_void(player_pos, trump)
                           logger.info(f"[MEMORY] Inferring VOID: Player {player_pos} has no {trump} (Failed to cut {led_suit})")

    def mark_void(self, player_ref, suit):
        # player_ref can be int index or string position
        if suit in SUITS:
            self.voids.setdefault(player_ref, set()).add(suit)

    def is_void(self, player_ref, suit):
        return suit in self.voids.get(player_ref, set())

    def get_remaining_trumps(self, trump_suit):
        return [c for c in self.get_remaining_in_suit(trump_suit)]

    def check_contradiction(self, player_ref, card_obj):
        """
        Sherlock's Magnifying Glass:
        Checks if playing 'card_obj' contradicts previously known voids.
        Returns a Reason string if contradictory, else None.
        """
        suit = card_obj.suit
        if self.is_void(player_ref, suit):
             return f"Player {player_ref} played {suit} but previously showed VOID in {suit}."
        return None

    # ========= PROOF-BASED QAYD METHODS =========
    
    def record_suspected_crime(self, player_pos, trick_idx, crime_card, void_suit):
        """
        Record a suspected revoke (player claimed void but might have lied).
        This is tracked until proof is found.
        """
        suspect = {
            'player': player_pos,
            'trick_idx': trick_idx,
            'crime_card': crime_card,  # The card they played (wrong suit)
            'void_suit': void_suit,     # The suit they claimed not to have
            'proven': False,
            'proof_card': None,
            'proof_trick_idx': None
        }
        self.suspected_crimes.append(suspect)
        logger.info(f"[SHERLOCK] Recorded suspected crime: {player_pos} may have revoked on {void_suit} (played {crime_card})")
        
    def check_for_proof(self, player_pos, played_card_suit, current_trick_idx):
        """
        Check if a player just revealed proof of a previous crime.
        If player previously claimed void in a suit, and now plays that suit -> PROOF FOUND!
        Returns the proven crime dict or None.
        """
        for suspect in self.suspected_crimes:
            if suspect['player'] == player_pos and suspect['void_suit'] == played_card_suit and not suspect['proven']:
                # PROOF FOUND!
                suspect['proven'] = True
                suspect['proof_trick_idx'] = current_trick_idx
                logger.info(f"[SHERLOCK] PROOF FOUND! {player_pos} played {played_card_suit} but claimed void in trick {suspect['trick_idx']}")
                return suspect
        return None
    
    def get_proven_crimes(self):
        """Get all crimes that have been proven (have both crime card and proof card)."""
        return [s for s in self.suspected_crimes if s['proven']]
    
    def get_unproven_suspects(self):
        """Get suspected crimes that haven't been proven yet."""
        return [s for s in self.suspected_crimes if not s['proven']]

    def is_master(self, rank, suit, mode, trump):
        """
        Check if a card is the highest remaining in its suit.
        """
        remaining = self.get_remaining_in_suit(suit)
        if not remaining: return True 
        
        order = []
        if mode == 'HOKUM':
            if suit == trump:
                order = ['J', '9', 'A', '10', 'K', 'Q', '8', '7']
            else:
                order = ['A', 'K', 'Q', 'J', '10', '9', '8', '7']
        else: # SUN
             order = ['A', '10', 'K', 'Q', 'J', '9', '8', '7']
             
        my_idx = -1
        try:
            my_idx = order.index(rank)
        except ValueError:
            return False 
            
        for c in remaining:
            if c['rank'] == rank: continue 
            try:
                op_idx = order.index(c['rank'])
                if op_idx < my_idx:
                    return False # Found a stronger card
            except ValueError:
                continue

        return True

```

### FILE: ai_worker\memory_hall.py
```py
import logging
import json
import time

# Settings
try:
    from server.settings import REDIS_URL, OFFLINE_MODE
except ImportError:
    REDIS_URL = "redis://localhost:6379/0"
    OFFLINE_MODE = False

# Redis
try:
    import redis
except ImportError:
    redis = None

logger = logging.getLogger(__name__)

class MemoryHall:
    """
    The 'Memory Hall' stores long-term narrative data about players.
    - Rivalries (Wins/Losses vs specific Bots)
    - Play Styles
    - Past Glories/Shames
    """
    def __init__(self):
        self.redis_client = None
        self._connect()

    def _connect(self):
        if OFFLINE_MODE:
             return

        if redis:
            try:
                self.redis_client = redis.from_url(REDIS_URL, decode_responses=True, socket_timeout=1.0)
                logger.info("[MEMORY_HALL] Connected to Redis.")
            except Exception as e:
                logger.error(f"[MEMORY_HALL] Redis connection failed: {e}")

    def remember_match(self, user_id: str, player_name: str, match_data: dict):
        """
        Updates the rivalry stats for a user after a match.
        match_data: {
          'winner': 'us' | 'them',
          'my_partner': 'Khalid',
          'opponents': ['Saad', 'Fahad'],
          'score_us': 152,
          'score_them': 100
        }
        """
        if not self.redis_client or not user_id:
            return

        try:
            key = f"rivalry:{user_id}"
            
            # 1. Update Basic Stats
            self.redis_client.hincrby(key, "games_played", 1)
            
            if match_data['winner'] == 'us':
                self.redis_client.hincrby(key, "wins_vs_ai", 1)
            else:
                self.redis_client.hincrby(key, "losses_vs_ai", 1)
                
            # 2. Update Specific Bot Relationships
            rel_key = f"rivalry:{user_id}:relationships"
            
            # Partner
            partner = match_data.get('my_partner')
            if partner:
                res = "won_with" if match_data['winner'] == 'us' else "lost_with"
                self.redis_client.hincrby(rel_key, f"{partner}:{res}", 1)
                
            # Opponents
            for opp in match_data.get('opponents', []):
                res = "won_against" if match_data['winner'] == 'us' else "lost_to"
                self.redis_client.hincrby(rel_key, f"{opp}:{res}", 1)

            logger.info(f"[MEMORY_HALL] Remembered match for {player_name} ({user_id})")

        except Exception as e:
            logger.error(f"[MEMORY_HALL] Failed to remember match: {e}")

    def get_rivalry_summary(self, user_id: str) -> dict:
        """
        Returns a summary of the user's history for dialogue injection.
        """
        if not self.redis_client or not user_id:
            return {}

        try:
            key = f"rivalry:{user_id}"
            stats = self.redis_client.hgetall(key)
            
            if not stats: 
                return {"status": "stranger"}
            
            games = int(stats.get('games_played', 0))
            wins = int(stats.get('wins_vs_ai', 0))
            losses = int(stats.get('losses_vs_ai', 0))
            
            win_rate = 0
            if games > 0:
                win_rate = (wins / games) * 100
                
            # Calculate Nemesis (Most 'lost_to')
            rel_key = f"rivalry:{user_id}:relationships"
            rels = self.redis_client.hgetall(rel_key)
            
            nemesis = None
            max_losses = 0
            
            for k, v in rels.items():
                if k.endswith(":lost_to"):
                    bot_name = k.split(":")[0]
                    count = int(v)
                    if count > max_losses:
                        max_losses = count
                        nemesis = bot_name
                        
            return {
                "status": "regular" if games > 5 else "novice",
                "games_played": games,
                "win_rate": round(win_rate, 1),
                "nemesis": nemesis,
                "total_wins": wins,
                "total_losses": losses
            }
            
        except Exception as e:
            logger.error(f"[MEMORY_HALL] Failed to get summary: {e}")
            return {}

# Singleton
memory_hall = MemoryHall()

```

### FILE: ai_worker\mind_client.py
```py

import torch
import logging
from pathlib import Path
from ai_worker.learning.mind_reader import MindReaderNet
from ai_worker.learning.mind_utils import MindVocab
import os

logger = logging.getLogger(__name__)

class MindClient:
    _instance = None
    
    def __init__(self, model_path=None):
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        
        # Load Model
        self.model = MindReaderNet().to(self.device)
        
        if model_path is None:
            # Default location
            base = Path(__file__).parent
            model_path = base / "models" / "mind_reader_v1.pth"
            
        try:
            if os.path.exists(model_path):
                self.model.load_state_dict(torch.load(model_path, map_location=self.device))
                self.model.eval()
                self.active = True
                logger.info(f"MindReader loaded from {model_path} on {self.device}")
            else:
                logger.warning(f"MindReader model not found at {model_path}. Inference disabled.")
                self.active = False
        except Exception as e:
            logger.error(f"Failed to load MindReader: {e}")
            self.active = False
            
    def _vectorize_history(self, game_state, perspective_idx=0):
        """
        Convert LIVE game state to tensor sequence.
        Reconstructs sequence from:
        1. Bidding (game_state['bid'])
        2. Completed Tricks (game_state['tricks'])
        3. Current Trick (game_state['tableCards'])
        """
        tokens = [MindVocab.START]
        
        # 1. Bidding
        # In live state, we might only have the winning bid info easily accessible
        # Ideally we want full bidding history. 
        # If 'bids' list exists in state, use it. Else use winning bid as proxy.
        bid_info = game_state.get('bid', {})
        if bid_info:
            bid_type = bid_info.get('type', 'PASS')
            if bid_type:
                t = MindVocab.get_bid_token(bid_type)
                if t: tokens.append(t)
                
        # 2. Completed Tricks
        tricks = game_state.get('tricks', [])
        for trick in tricks:
            # Trick is dict: {cards: [..], playedBy: [..], winner: ..}
            # We need to interleave them correctly.
            # Assuming 'cards' and 'playedBy' are aligned lists.
            t_cards = trick.get('cards', [])
            # t_players = trick.get('playedBy', []) # Names or Indices?
            # In live state playedBy is usually list of names/indices.
            # For Tokenization, we just need the CARD token. Player ID is implicit in turn order?
            # Actually MindVocab only encodes Card/Bid. It doesn't encode Player ID.
            # So just sequence of cards is enough for V1.
            
            for c_obj in t_cards:
                 # c_obj might be dict or Card object
                 if isinstance(c_obj, dict):
                     c_str = self._card_to_str(c_obj)
                 else:
                     c_str = f"{c_obj.suit}{c_obj.rank}"
                     
                 t = MindVocab.get_card_token(c_str)
                 if t: tokens.append(t)
                 
        # 3. Current Trick (Table Cards)
        table = game_state.get('tableCards', [])
        for tc in table:
             c_obj = tc.get('card')
             if isinstance(c_obj, dict):
                 c_str = self._card_to_str(c_obj)
             else:
                 c_str = f"{c_obj.suit}{c_obj.rank}"

             t = MindVocab.get_card_token(c_str)
             if t: tokens.append(t)
                
        return torch.tensor(tokens, dtype=torch.long).unsqueeze(0).to(self.device)

    def _card_to_str(self, c_dict):
        # Helper to convert {'suit': 'H', 'rank': 'A'} to 'HA'
        # Suit might be symbol or letter.
        s = c_dict.get('suit', '')
        r = c_dict.get('rank', '')
        # Normalize suit symbols
        suit_map = {'‚ô•': 'H', '‚ô¶': 'D', '‚ô†': 'S', '‚ô£': 'C'}
        s_char = suit_map.get(s, s) # Default to itself if already 'H'
        return f"{s_char}{r}"

    def infer_hands(self, game_history):
        """
        Returns probability distribution of hidden cards.
        Output: { player_id (0-3): { card_idx (0-31): probability } }
        """
        if not self.active: return None
        
        try:
            # Prepare Input
            x = self._vectorize_history(game_history, 0) # Perspective 0 for now
            
            with torch.no_grad():
                # pred_l (Left), pred_p (Partner), pred_r (Right) relative to Perspective 0
                # Our Model outputs: [Batch, 32] logits
                # output is (out_left, out_partner, out_right) - Tuple of tensors
                # Wait, training collate masked it?
                # Actually model returns: out_left, out_partner, out_right
                
                out_l, out_p, out_r = self.model(x)
                
                # Sigmoid for probabilities
                prob_l = torch.sigmoid(out_l).squeeze(0).cpu().numpy()
                prob_p = torch.sigmoid(out_p).squeeze(0).cpu().numpy()
                prob_r = torch.sigmoid(out_r).squeeze(0).cpu().numpy()
                
                # Map to Absolute Players (assuming P0 is viewpoint)
                # Right = 1, Partner = 2, Left = 3
                return {
                    1: prob_r,
                    2: prob_p,
                    3: prob_l
                }
                
        except Exception as e:
            logger.error(f"MindReader Inference Error: {e}")
            return None

    def get_heatmap(self, game_history):
        """
        Returns user-friendly heatmap for visualization.
        """
        probs = self.infer_hands(game_history)
        if not probs: return {}
        
        # Convert to dictionary keyed by player index -> list of card probabilities
        # UI expects specific format? Let's just return raw probabilities for now.
        return {
            "right": probs[1].tolist(),
            "partner": probs[2].tolist(),
            "left": probs[3].tolist()
        }

# Singleton
mind_client = MindClient()

```

### FILE: ai_worker\mock_redis.py
```py

class MockRedis:
    def __init__(self):
        self._data = {}
        
    def from_url(self, url, **kwargs):
        return self
        
    def get(self, key):
        return self._data.get(key)
        
    def set(self, key, value):
        self._data[key] = value
        return True
    
    def mget(self, keys):
        return [self._data.get(k) for k in keys]
        
    def keys(self, pattern):
        import fnmatch
        # Convert redis pattern to python fnmatch
        # Redis: * -> *, ? -> ?
        # This is rough, but enough for "brain:correct:*"
        return fnmatch.filter(self._data.keys(), pattern)
        
    def lpush(self, key, value):
        if key not in self._data:
             self._data[key] = []
        if not isinstance(self._data[key], list):
             return False
        self._data[key].insert(0, value)
        return True
    
    def delete(self, key):
        if key in self._data:
            del self._data[key]
            return 1
        return 0
        
    def pipeline(self):
        return self
        
    def execute(self):
        return []

    def ping(self):
        return True

```

### FILE: ai_worker\personality.py
```py
from dataclasses import dataclass

@dataclass
class PersonalityProfile:
    name: str
    description: str
    sun_bias: int = 0
    hokum_bias: int = 0
    ashkal_bias: int = 0
    can_gamble: bool = False
    avatar_id: str = "bot_1" # Default avatar
    voice_lines: list = None

# Presets
# Bias > 0 means MORE likely to bid (Lower threshold)
# Bias < 0 means LESS likely to bid (Higher threshold)

BALANCED = PersonalityProfile(
    name="Saad",
    description="Standard play style.",
    sun_bias=0,
    hokum_bias=0,
    ashkal_bias=0,
    can_gamble=False,
    avatar_id="avatar_saad",
    voice_lines=["Thinking...", "Let's play."]
)

AGGRESSIVE = PersonalityProfile(
    name="Khalid",
    description="Takes risks, bids on weaker hands.",
    sun_bias=3,    # Will bid Sun on 15 instead of 18
    hokum_bias=3,  # Will bid Hokum on 11 instead of 14
    ashkal_bias=2,
    can_gamble=True,
    avatar_id="avatar_khalid",
    voice_lines=["I'm going for it!", "Hokum!"]
)

CONSERVATIVE = PersonalityProfile(
    name="Abu Fahad",
    description="Plays safe, only bids on strong hands.",
    sun_bias=-3,   # Will bid Sun on 21
    hokum_bias=-2, # Will bid Hokum on 16
    ashkal_bias=-2,
    can_gamble=False,
    avatar_id="avatar_abu_fahad",
    voice_lines=["Too risky.", "Pass."]
)

PROFILES = {
    'Balanced': BALANCED,
    'Aggressive': AGGRESSIVE,
    'Conservative': CONSERVATIVE
}

```

### FILE: ai_worker\professor.py
```py
import logging
import random
from ai_worker.agent import BotAgent, bot_agent
from ai_worker.cognitive import CognitiveOptimizer
from ai_worker.bot_context import BotContext
from game_engine.logic.game import Game
from game_engine.models.card import Card

logger = logging.getLogger(__name__)

class Professor:
    def __init__(self):
        self.agent = bot_agent # Reuse the existing singleton agent
        self.cognitive = CognitiveOptimizer(use_inference=True)
        self.enabled = True 
        # Thresholds
        self.blunder_threshold = 0.20 # EV Difference triggering a "Blunder"
        self.mistake_threshold = 0.10 # EV Difference triggering a "Mistake"
        self.minor_threshold = 0.05   # EV Difference triggering a "Note"
        
        # Responses
        self.responses = {
            "BLUNDER": [
                "Whoa! That move is risky.",
                "I wouldn't recommend that.",
                "Are you sure? That loses significant value."
            ],
            "MISTAKE": [
                "There is a better option.",
                "Think twice about that.",
                "I see a stronger play."
            ]
        }
        
    def check_move(self, game: Game, player_index: int, card_index: int) -> dict | None:
        """
        Analyzes the human's intended move using MCTS.
        Returns None if move is fine.
        Returns dict with { 'warning': str, 'better_move': str } if it's a blunder.
        """
        if not self.enabled:
            return None
            
        try:
            player = game.players[player_index]
            if card_index < 0 or card_index >= len(player.hand):
                return None 
            
            human_card = player.hand[card_index]
            
            # 1. Create Context for Human
            game_state = game.get_game_state()
            ctx = BotContext(game_state, player_index) # Personality checks not needed for MCTS
            
            # 2. Run MCTS Analysis
            logger.debug(f"PROFESSOR: Analyzing for {player.name} ({player_index}). Hand: {[str(c) for c in player.hand]}")
            logger.debug(f"PROFESSOR: Table Context: {[f'{tc.get('playedBy')}:{str(tc.get('card'))}' for tc in game.table_cards]}")
            
            analysis = self.cognitive.analyze_position(ctx)
            
            if not analysis:
                logger.warning("PROFESSOR: MCTS returned NO analysis.")
                return None
                
            best_move_idx = analysis['best_move']
            move_values = analysis['move_values']
            
            # DEBUG LOG: Dump all considered moves and their legality
            if hasattr(game, 'is_valid_move'):
                 for m_idx, stats in move_values.items():
                      c_card = player.hand[m_idx]
                      is_real_legal = game.is_valid_move(c_card, player.hand)
                      suffix = " (ILLEGAL in Real Game!)" if not is_real_legal else ""
                      if not is_real_legal:
                           logger.error(f"PROFESSOR BUG: MCTS considers ILLEGAL move {c_card} as valid candidate! Stats: {stats}")
                      else:
                           logger.debug(f"MCTSCandidate: {c_card} -> WinRate: {stats['win_rate']:.2f} ({stats['visit_count'] if 'visit_count' in stats else stats.get('visits')}v)")

            
            if card_index == best_move_idx:
                return None # Human played the optimal move!
                
            # 3. Compare EV (Expected Value)
            human_stats = move_values.get(card_index)
            best_stats = move_values.get(best_move_idx)
            
            if not human_stats or not best_stats:
                return None
                
            human_ev = human_stats['win_rate'] # Normalized 0-1 (Wins / Visits)
            best_ev = best_stats['win_rate']
            human_visits = human_stats['visits']
            best_visits = best_stats['visits']
            
            diff = best_ev - human_ev
            
            if diff > 0.05:
                logger.info(f"PROFESSOR: Opportunity Detected! Human={human_card} ({human_ev:.2f}) vs Best={player.hand[best_move_idx]} ({best_ev:.2f}). Diff={diff:.2f}")
            
            # 4. Determine Blunder Level
            blunder_type = None
            if diff >= self.blunder_threshold:
                blunder_type = "BLUNDER"
            elif diff >= self.mistake_threshold:
                blunder_type = "MISTAKE"
            # elif diff >= self.minor_threshold:
            #     blunder_type = "NOTE" 
            
            if not blunder_type:
                return None
            
            # [NEW] Generate Puzzle for Blunders
            best_card = player.hand[best_move_idx]
            
            if blunder_type == "BLUNDER":
                try:
                    # Lazy init to avoid circular deps if any
                    from ai_worker.learning.puzzle_generator import PuzzleGenerator
                    pgen = PuzzleGenerator()
                    pgen.create_from_blunder(ctx, human_card, best_card, analysis)
                except Exception as e:
                    logger.error(f"Professor failed to generate puzzle: {e}")

            # 5. Construct Message
            # Safety Check: Is the "Better Card" actually legal?
            if hasattr(game, 'is_valid_move') and not game.is_valid_move(best_card, player.hand):
                 logger.critical(f"PROFESSOR FATAL: Suggested ILLEGAL MOVE {best_card} as better option! Aborting intervention.")
                 return None

            intro = random.choice(self.responses[blunder_type])
            percentage = int(diff * 100)
            reason = f"Playing {best_card} is {percentage}% better."
            
            # ... rest of code (Candidate extraction) ...
            
            # 4b. Extract Candidate Moves (Holographic Thought)
            candidates = []
            sorted_moves = sorted(move_values.items(), key=lambda item: item[1]['win_rate'], reverse=True)
            
            for rank, (m_idx, stats) in enumerate(sorted_moves[:3]):
                # Skip if it is the played card
                if m_idx == card_index:
                    continue
                    
                c_card = player.hand[m_idx]
                
                # Double check candidate legality
                if hasattr(game, 'is_valid_move') and not game.is_valid_move(c_card, player.hand):
                     continue # Skip illegal candidates from UI suggestion

                c_diff = stats['win_rate'] - human_ev
                
                candidates.append({
                    "card": c_card.to_dict(),
                    "win_rate": stats['win_rate'],
                    "visits": stats['visits'],
                    "diff": c_diff,
                    "rank": rank + 1
                })

            intervention = {
                "type": blunder_type,
                "message": f"Professor: {intro} {reason}",
                "better_card": best_card.to_dict(),
                "reason": reason,
                "diff": diff,
                "candidates": candidates
            }
            logger.info(f"Professor: Triggering Intervention: {intervention}")
            return intervention
            
        except Exception as e:
            logger.error(f"Professor Error: {e}", exc_info=True)
            return None

# Singleton
professor = Professor()

```

### FILE: ai_worker\rate_limiter.py
```py
import time
import threading
import logging

logger = logging.getLogger(__name__)

class TokenBucketRateLimiter:
    """
    Thread-safe Token Bucket Rate Limiter.
    Enforces a strict limit of `refill_rate` requests per minute.
    """
    def __init__(self, capacity: int = 10, refill_rate_per_minute: int = 10):
        self.capacity = float(capacity)
        self.tokens = float(capacity)
        self.refill_rate = refill_rate_per_minute / 60.0 # tokens per second
        self.last_refill = time.time()
        self.lock = threading.Lock()
        
    def _refill(self):
        now = time.time()
        elapsed = now - self.last_refill
        
        if elapsed > 0:
            added_tokens = elapsed * self.refill_rate
            self.tokens = min(self.capacity, self.tokens + added_tokens)
            self.last_refill = now
            
    def acquire(self, blocking: bool = False) -> bool:
        """
        Attempt to acquire a token.
        Returns True if successful, False otherwise (unless blocking=True, which waits).
        """
        with self.lock:
            self._refill()
            
            if self.tokens >= 1.0:
                self.tokens -= 1.0
                return True
                
            if not blocking:
                return False
                
        # Blocking logic (simple sleep loop outside lock)
        while True:
            time.sleep(1.0 / self.refill_rate) # Sleep for time to generate 1 token
            with self.lock:
                self._refill()
                if self.tokens >= 1.0:
                    self.tokens -= 1.0
                    return True
                    
    def get_status(self):
        with self.lock:
            self._refill()
            return {
                "tokens": self.tokens,
                "capacity": self.capacity,
                "refill_rate_sec": self.refill_rate
            }

# Singleton instance for Global Limiting
# 10 RPM = 1 request every 6 seconds. Very safe for Free Tier (15 RPM limit).
global_gemini_limiter = TokenBucketRateLimiter(capacity=10, refill_rate_per_minute=10)

```

### FILE: ai_worker\referee_observer.py
```py
import logging
from game_engine.models.constants import ORDER_SUN, ORDER_HOKUM

logger = logging.getLogger(__name__)

class RefereeObserver:
    """
    Enforces rules and handles mandatory responses (Sawa, Qayd).
    """

    def check_qayd(self, ctx, game_state, memory=None):
        """
        PROOF-BASED QAYD DETECTION (Kammelna-style)
        
        Instead of triggering immediately on 'is_illegal' flag,
        we wait for PROOF: when the cheater later plays a card of the
        suit they previously claimed not to have.
        
        Args:
            ctx: Bot context with position, hand, etc.
            memory: CardMemory instance for tracking suspected crimes
            
        Returns:
            dict with 'action': 'QAYD_ACCUSATION' if proven crime found, else None
        """
        if ctx.phase != 'PLAYING' or not memory:
            return None
            
        # Check if memory has any proven crimes from opponents
        proven_crimes = memory.get_proven_crimes()
        
        for crime in proven_crimes:
            offender_pos = crime['player']
            
            # Only accuse opponents (not teammate)
            my_team = 'us' if ctx.position in ['Bottom', 'Top'] else 'them'
            offender_team = 'us' if offender_pos in ['Bottom', 'Top'] else 'them'
            
            if my_team != offender_team:
                # Found a proven crime by opponent!
                logger.info(f"[SHERLOCK] {ctx.position} found PROVEN crime by {offender_pos}: revoked on {crime['void_suit']}")
                
                return {
                    "action": "QAYD_ACCUSATION",
                    "qayd_type": "REVOKE",  # ŸÇÿßÿ∑ÿπ
                    "crime": {
                        "player": offender_pos,
                        "crime_card": crime['crime_card'],
                        "crime_trick_idx": crime['trick_idx'],
                        "proof_card": crime.get('proof_card'),
                        "proof_trick_idx": crime.get('proof_trick_idx'),
                        "void_suit": crime['void_suit']
                    },
                    "reasoning": f"{offender_pos} revoked on {crime['void_suit']} in trick {crime['trick_idx']}, proven in trick {crime.get('proof_trick_idx')}"
                }
        
        return None

    def check_sawa(self, ctx, game_state):
        """
        Check if a Sawa claim is pending and generate a response.
        """
        sawa_state = game_state.get('sawaState') or game_state.get('sawa_state')
        
        # Validate Sawa State
        if not sawa_state or not sawa_state.get('active') or sawa_state.get('status') != 'PENDING':
            return None

        claimer_pos = sawa_state['claimer']
        my_pos = ctx.position
        
        # Check Teams
        my_team = 'us' if my_pos in ['Bottom', 'Top'] else 'them'
        claimer_team = 'us' if claimer_pos in ['Bottom', 'Top'] else 'them'
        
        # Only opponents respond
        if my_team == claimer_team:
            return None

        # Check if already responded
        if my_pos in sawa_state.get('responses', {}):
            return None

        # Calculate Response
        response_data = self._evaluate_sawa_refusal(ctx)
        logger.info(f"[REFEREE] Responding to Sawa from {claimer_pos} with {response_data['response']}")
        
        return {
            "action": "SAWA_RESPONSE", 
            "response": response_data['response'], 
            "reasoning": response_data['reasoning']
        }

    def _evaluate_sawa_refusal(self, ctx):
        """
        Evaluate if we have a Master Card to refuse Sawa.
        """
        refusal_card = None
        
        for i, c in enumerate(ctx.hand):
             # Is this card a Master?
             if ctx.is_master_card(c):
                  # Logic for HOKUM Trumps vs Non-Trumps
                  if ctx.mode == 'HOKUM':
                       # Safe Strategy: Refuse if I can potentially win a trick
                       refusal_card = c
                       break
                  else:
                       # SUN Mode -> Any master wins.
                       refusal_card = c
                       break
                       
        if refusal_card:
             return {"response": "REFUSE", "reasoning": f"I hold Master Card: {refusal_card}"}
        else:
             return {"response": "ACCEPT", "reasoning": "No guaranteed winning cards"}

```

### FILE: ai_worker\__init__.py
```py
from .agent import bot_agent
from .memory import CardMemory

```

### FILE: ai_worker\benchmarks\golden_puzzles.json
```json
[
  {
    "id": "puzzle_3",
    "context_hash": "seed-a2e13ab2",
    "description": "Your partner has already captured the trick with the Ace of Spades. Playing your King (10 points) is a waste because the Ace is the highest. Save your King for a future trick or throw 10/K on a winning trick to add points.",
    "game_state": {
      "players": [
        {
          "position": "Bottom",
          "hand": [
            {
              "suit": "S",
              "rank": "K"
            },
            {
              "suit": "S",
              "rank": "7"
            },
            {
              "suit": "H",
              "rank": "10"
            }
          ],
          "name": "Me"
        },
        {
          "position": "Right",
          "hand": [],
          "name": "Bot"
        },
        {
          "position": "Top",
          "hand": [],
          "name": "Partner"
        },
        {
          "position": "Left",
          "hand": [],
          "name": "Bot"
        }
      ],
      "bid": {
        "type": "SUN",
        "bidder": "Top"
      },
      "currentTurnIndex": 0,
      "playedCards": {
        "2": {
          "suit": "S",
          "rank": "A",
          "playedBy": "Top"
        },
        "3": {
          "suit": "H",
          "rank": "7",
          "playedBy": "Left"
        }
      },
      "floorCard": null
    },
    "solution": {
      "suit": "S",
      "rank": "7"
    },
    "difficulty": "Hard"
  },
  {
    "id": "puzzle_4",
    "context_hash": "seed-c106ccea",
    "description": "The opponent is winning with an Ace. You have a Trump (Diamond). You should 'cut' the trick to win it for your team.",
    "game_state": {
      "players": [
        {
          "position": "Bottom",
          "hand": [
            {
              "suit": "D",
              "rank": "7"
            },
            {
              "suit": "C",
              "rank": "J"
            }
          ],
          "name": "Me"
        },
        {
          "position": "Right",
          "hand": [],
          "name": "Bot"
        },
        {
          "position": "Top",
          "hand": [],
          "name": "Partner"
        },
        {
          "position": "Left",
          "hand": [],
          "name": "Bot"
        }
      ],
      "bid": {
        "type": "HOKUM",
        "suit": "D",
        "bidder": "Right"
      },
      "currentTurnIndex": 0,
      "playedCards": {
        "1": {
          "suit": "S",
          "rank": "A",
          "playedBy": "Right"
        }
      },
      "floorCard": {
        "suit": "D",
        "rank": "7"
      }
    },
    "solution": {
      "suit": "D",
      "rank": "7"
    },
    "difficulty": "Hard"
  }
]
```

### FILE: ai_worker\data\test_yolo\yolo_dataset.jsonl
```jsonl
{"ts": 1769725812, "game_id": "test_game_123", "mode": "SUN", "vector": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0], "target_idx": 1, "target_card": "\u2665A", "confidence": 0.9, "visits": 1000}
{"ts": 1769725812, "game_id": "test_game_123", "mode": "SUN", "vector": [1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0], "target_idx": 2, "target_card": "\u266610", "confidence": 0.95, "visits": 1200}

```

### FILE: ai_worker\data\training\mistakes_extracted.json
```json
[]
```

### FILE: ai_worker\learning\dataset_logger.py
```py

import logging
import os
import json
import time
from typing import List, Dict
from ai_worker.bot_context import BotContext
from ai_worker.learning.feature_extractor import FeatureExtractor

logger = logging.getLogger(__name__)

class DatasetLogger:
    """
    Logs game states and MCTS decisions to a JSONL dataset.
    Features:
    - Buffering (flush every N records)
    - Thresholding (only log high-confidence moves)
    - JSONL format (efficient for ML)
    """
    def __init__(self, data_dir="ai_worker/data/training", min_confidence=0.95, buffer_size=50):
        self.data_dir = data_dir
        self.file_path = os.path.join(data_dir, "yolo_dataset.jsonl")
        self.extractor = FeatureExtractor()
        
        self.min_confidence = min_confidence
        self.buffer_size = buffer_size
        self.buffer = []
        
        # Ensure dir exists
        os.makedirs(data_dir, exist_ok=True)

    def log_sample(self, ctx: BotContext, mcts_move_idx: int, details: Dict):
        """
        Logs a single training sample if it meets criteria.
        mcts_move_idx: Index in HAND (0..N).
        """
        try:
            # 1. Check Confidence Threshold
            move_stats = details.get(mcts_move_idx, {})
            # Use 'win_rate' or visit count ratio as confidence?
            # Win rate is better for 'correctness', visit ratio for 'certainty'.
            # MCTS details usually has: {'visits': N, 'wins': M, 'win_rate': 0.X}
            
            # Let's use visit_ratio if available, else win_rate?
            # Actually, standard MCTS: visits = confidence.
            # But details here might just be win_rate derived.
            # Let's assume 'win_rate' is the Q-value.
            
            # If win_rate > threshold (e.g. 0.95), it's a "forced/obvious" move.
            win_rate = move_stats.get('win_rate', 0.0)
            visits = move_stats.get('visits', 0)
            
            if win_rate < self.min_confidence:
                return # Skip low confidence moves

            # 2. Extract Features
            vector = self.extractor.encode(ctx)
            # JSON-serializable list
            vector_list = [round(v, 4) for v in vector]
            
            # 3. Target info
            target_card = ctx.hand[mcts_move_idx] if mcts_move_idx < len(ctx.hand) else None
            # target_str = str(target_card) if target_card else "None" # Redundant if index is reliable, but good for debug
            
            # 4. Construct Record
            record = {
                "ts": int(time.time()),
                "game_id": ctx.raw_state.get('gameId', 'unknown'),
                "mode": ctx.mode,
                "vector": vector_list,
                "target_idx": mcts_move_idx,
                "target_card": str(target_card),
                "confidence": win_rate,
                "visits": visits
            }
            
            # 5. Buffer & Flush
            self.buffer.append(record)
            if len(self.buffer) >= self.buffer_size:
                self.flush()
                
        except Exception as e:
            logger.error(f"Dataset Logging Error: {e}", exc_info=False)
            pass

    def flush(self):
        """Writes buffer to disk."""
        if not self.buffer: return
        
        try:
            with open(self.file_path, 'a', encoding='utf-8') as f:
                for record in self.buffer:
                    f.write(json.dumps(record) + '\n')
            
            self.buffer.clear()
        except Exception as e:
            logger.error(f"Failed to flush Yolo Buffer: {e}")

```

### FILE: ai_worker\learning\feature_extractor.py
```py

import logging
from typing import List
from ai_worker.bot_context import BotContext
from game_engine.models.card import Card
from game_engine.models.constants import SUITS, RANKS, ORDER_SUN, ORDER_HOKUM

logger = logging.getLogger(__name__)

class FeatureExtractor:
    """
    Converts BotContext into a fixed-size numerical vector.
    Vector Size: 32 (Hand) + 32 (Table) + 32 (Played) + 32 (Legal) + 10 (Context) = 138 Features.
    """
    
    def __init__(self):
        # Card Map: (Suit, Rank) -> Index 0-31
        self.card_to_idx = {}
        
        # Mapping S/H/D/C to standard SUITS indices 
        # Standard constants.SUITS = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'] (0, 1, 2, 3)
        # We want S->0, H->1, D->2, C->3 as well.
        
        self.suit_map = {
            'S': '‚ô†', 's': '‚ô†', '‚ô†': '‚ô†',
            'H': '‚ô•', 'h': '‚ô•', '‚ô•': '‚ô•',
            'D': '‚ô¶', 'd': '‚ô¶', '‚ô¶': '‚ô¶',
            'C': '‚ô£', 'c': '‚ô£', '‚ô£': '‚ô£'
        }
        
        raw_suits_order = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£']
        
        idx = 0
        for s in raw_suits_order:
            for r in RANKS:
                # Key using standardized suit
                key = f"{s}{r}"
                self.card_to_idx[key] = idx
                idx += 1

    def encode(self, ctx: BotContext, legal_moves_indices: List[int] = None) -> List[float]:
        # Initialize zero vector
        # Size = 32*4 + 10 = 138
        vec = [0.0] * 138
        
        # 1. Hand (0-31)
        # Note: ctx.hand is a list of Card objects
        for i, card in enumerate(ctx.hand):
            c_idx = self._get_card_index(card)
            if c_idx >= 0:
                vec[0 + c_idx] = 1.0
                
        # 2. Table (32-63)
        # ctx.raw_state['tableCards'] = [{'card': {suit, rank}, playedBy: ...}]
        table_cards = ctx.raw_state.get('tableCards', [])
        for item in table_cards:
            c_data = item.get('card')
            if c_data:
                # Handle dict or obj
                if isinstance(c_data, dict):
                    c_obj = Card(c_data['suit'], c_data['rank'])
                else:
                    c_obj = c_data
                c_idx = self._get_card_index(c_obj)
                if c_idx >= 0:
                    vec[32 + c_idx] = 1.0
                    
        # 3. Played History (64-95)
        # Assuming ctx.memory.played_cards contains string representations from __str__ or similar
        # Ideally we iterate over all possible cards and check if they are in memory.
        # But for MVP we can skip expensive loop if needed. 
        # Let's keep it simple for now and leave it as zeros unless we want to iterate.
        pass 
            
        # 4. Legal Moves Mask (96-127)
        if legal_moves_indices and ctx.hand:
            for idx in legal_moves_indices:
                if idx < len(ctx.hand):
                    card = ctx.hand[idx]
                    c_idx = self._get_card_index(card)
                    if c_idx >= 0:
                        vec[96 + c_idx] = 1.0
        
        # 5. Context (128-137)
        base = 128
        
        trump = ctx.trump
        mode = ctx.mode 
        
        # Normalize Trump String
        norm_trump = self.suit_map.get(trump, None)
        if norm_trump and norm_trump in SUITS:
            t_idx = SUITS.index(norm_trump)
            vec[base + t_idx] = 1.0
            
        if mode == 'SUN':
            vec[base + 4] = 1.0
        else:
            vec[base + 5] = 1.0
            
        # Scores (Normalized / 152)
        scores = ctx.raw_state.get('matchScores', {})
        us = scores.get('us', 0) / 152.0
        them = scores.get('them', 0) / 152.0
        vec[base + 6] = us
        vec[base + 7] = them
        
        # Is Leading? (Table empty)
        if not table_cards:
            vec[base + 8] = 1.0
            
        return vec

    def _get_card_index(self, card: Card) -> int:
        normalized_suit = self.suit_map.get(card.suit, card.suit)
        key = f"{normalized_suit}{card.rank}"
        return self.card_to_idx.get(key, -1)

    def encode_fast(self, game, legal_moves_indices: List[int] = None) -> List[float]:
        """
        Optimized encoder for FastGame state (MCTS).
        'game' is typed as 'FastGame' but dynamic here to avoid circular imports.
        """
        # Initialize zero vector
        vec = [0.0] * 138
        
        # 1. Hand (0-31)
        # FastGame Hands are List[Card]
        # Current Turn Player's Hand
        hand = game.hands[game.current_turn]
        for i, card in enumerate(hand):
            c_idx = self._get_card_index(card)
            if c_idx >= 0:
                vec[0 + c_idx] = 1.0
                
        # 2. Table (32-63)
        # FastGame table is List[Tuple[player_idx, Card]]
        for p_idx, card in game.played_cards_in_trick:
            c_idx = self._get_card_index(card)
            if c_idx >= 0:
                vec[32 + c_idx] = 1.0
                    
        # 3. Played History (64-95)
        # FastGame doesn't track full history strictly in a hashset for lookup?
        # It has tricks_history.
        # Check game.tricks_history: List of previous ticks?
        # FastGame definition: self.tricks_history = tricks_history if tricks_history else []
        # Usually empty in lightweight clones unless we copy it.
        # Skip for speed in MCTS.
        pass
            
        # 4. Legal Moves Mask (96-127)
        if legal_moves_indices:
            for idx in legal_moves_indices:
                if idx < len(hand):
                    card = hand[idx]
                    c_idx = self._get_card_index(card)
                    if c_idx >= 0:
                        vec[96 + c_idx] = 1.0
        
        # 5. Context (128-137)
        base = 128
        
        trump = game.trump
        mode = game.mode 
        
        # Normalize Trump String
        norm_trump = self.suit_map.get(trump, None)
        if norm_trump and norm_trump in SUITS:
            t_idx = SUITS.index(norm_trump)
            vec[base + t_idx] = 1.0
            
        if mode == 'SUN':
            vec[base + 4] = 1.0
        else:
            vec[base + 5] = 1.0
            
        # Scores (Normalized / 152)
        # FastGame uses 'us'/'them'
        us = game.scores.get('us', 0) / 152.0
        them = game.scores.get('them', 0) / 152.0
        vec[base + 6] = us
        vec[base + 7] = them
        
        # Is Leading? (Table empty)
        if not game.played_cards_in_trick:
            vec[base + 8] = 1.0
            
        return vec


```

### FILE: ai_worker\learning\mind_reader.py
```py
import torch
import torch.nn as nn
import torch.nn.functional as F
import math

class MindReaderNet(nn.Module):
    """
    Transformer-based 'Theory of Mind' engine.
    Reads a sequence of game events and infers the hidden hands of opponents.
    """
    def __init__(self, vocab_size=128, embed_dim=64, num_heads=4, num_layers=2, num_cards=32):
        super(MindReaderNet, self).__init__()
        
        # 1. Embedding Layer
        # Represent game state as sequence of tokens (Card Played, Bid Made, etc.)
        self.embedding = nn.Embedding(vocab_size, embed_dim)
        self.pos_encoder = PositionalEncoding(embed_dim)
        
        # 2. Transformer Encoder (The "Brain")
        encoder_layer = nn.TransformerEncoderLayer(d_model=embed_dim, nhead=num_heads, batch_first=True)
        self.transformer = nn.TransformerEncoder(encoder_layer, num_layers=num_layers)
        
        # 3. Prediction Heads (3 Opponents * 32 Cards)
        # We predict the probability of EACH card being in EACH player's hand.
        # Output shape: [Batch, 3, 32]
        self.head_left = nn.Linear(embed_dim, num_cards)
        self.head_partner = nn.Linear(embed_dim, num_cards)
        self.head_right = nn.Linear(embed_dim, num_cards)
        
    def forward(self, x, mask=None):
        # x: [Batch, SeqLen] (Indices)
        
        # Embed
        x = self.embedding(x) * math.sqrt(64) # Scaling
        x = self.pos_encoder(x)
        
        # Transform
        # Output: [Batch, SeqLen, Embed]
        # We only care about the context at the LAST token (current state)
        feature_seq = self.transformer(x, src_key_padding_mask=mask)
        
        # Pooling: Take the last valid token's embedding as the summary vector
        # Ideally we use the last index, for simplicity here use max-pool or last
        summary_vec = feature_seq[:, -1, :] 
        
        # Predict
        out_left = self.head_left(summary_vec)
        out_partner = self.head_partner(summary_vec)
        out_right = self.head_right(summary_vec)
        
        return out_left, out_partner, out_right

class PositionalEncoding(nn.Module):
    def __init__(self, d_model, max_len=500):
        super().__init__()
        import math
        pe = torch.zeros(max_len, d_model)
        position = torch.arange(0, max_len, dtype=torch.float).unsqueeze(1)
        div_term = torch.exp(torch.arange(0, d_model, 2).float() * (-math.log(10000.0) / d_model))
        pe[:, 0::2] = torch.sin(position * div_term)
        pe[:, 1::2] = torch.cos(position * div_term)
        self.register_buffer('pe', pe)

    def forward(self, x):
        # x: [Batch, Seq, Dim]
        return x + self.pe[:x.size(1), :]

if __name__ == "__main__":
    # Smoke Test
    import math
    model = MindReaderNet()
    dummy_input = torch.randint(0, 100, (1, 50)) # Batch 1, Seq 50
    l, p, r = model(dummy_input)
    print("Model Output Shapes:", l.shape, p.shape, r.shape)
    print("MindReaderNet initialized successfully.")

```

### FILE: ai_worker\learning\mind_utils.py
```py

# Vocabulary Manager for MindReader

class MindVocab:
    PAD = 0
    START = 1
    
    # Offsets
    BID_OFFSET = 10
    PLAY_OFFSET = 50
    PLAYER_OFFSET = 100
    
    @staticmethod
    def get_card_token(card_str):
        # Card Format: 'S7', 'D10', 'HA', etc.
        # Suit: S=0, H=1, D=2, C=3
        # Rank: 7,8,9,10,Q,K,10,A -> 0..7
        # Total 32 cards.
        # Token = PLAY_OFFSET + Suit*8 + Rank
        if not card_str: return 0
        suits = {'S':0, 'H':1, 'D':2, 'C':3}
        ranks = {'7':0, '8':1, '9':2, '1':3, 'Q':4, 'K':5, '0':6, 'A':7} # '1' handles '10' usually if sliced 0
        # Handle '10' specifically 
        s = card_str[0]
        r = card_str[1:]
        if r == '10': r = '0' # use '0' key for 10
        
        if s not in suits or r not in ranks: return 0
        return MindVocab.PLAY_OFFSET + (suits[s] * 8) + ranks[r]

    @staticmethod
    def get_bid_token(bid_name):
        # SUN, HOKUM, PASS, etc.
        bids = {'PASS':0, 'SUN':1, 'HOKUM':2, 'ASHKAL':3}
        bn = bid_name.upper()
        if bn in bids:
            return MindVocab.BID_OFFSET + bids[bn]
        return 0
        
    @staticmethod
    def get_action_token(action_type, details):
        if action_type == 'BID':
            return MindVocab.get_bid_token(details)
        if action_type == 'PLAY':
            return MindVocab.get_card_token(details)
        return 0

    @staticmethod
    def card_to_index(card_str):
        # 0-31 index for output targets (NOT Tokens)
        # Same logic as token but 0-indexed
        return MindVocab.get_card_token(card_str) - MindVocab.PLAY_OFFSET

```

### FILE: ai_worker\learning\model.py
```py

import torch
import torch.nn as nn
import torch.nn.functional as F

class StrategyNet(nn.Module):
    """
    Feed-Forward Neural Network to predict optimal card to play.
    Input: 138 Features (Hand, Table, Context)
    Output: 32 Logits (One per Card in Deck)
    """
    def __init__(self, input_size=138, num_classes=32):
        super(StrategyNet, self).__init__()
        
        self.fc1 = nn.Linear(input_size, 256)
        self.bn1 = nn.BatchNorm1d(256)
        
        self.fc2 = nn.Linear(256, 128)
        self.bn2 = nn.BatchNorm1d(128)
        
        self.fc3 = nn.Linear(128, 64)
        self.bn3 = nn.BatchNorm1d(64)
        
        self.head_policy = nn.Linear(64, num_classes)
        
        self.dropout = nn.Dropout(0.3)
        
    def forward(self, x):
        # Layer 1
        x = self.fc1(x)
        x = self.bn1(x)
        x = F.relu(x)
        x = self.dropout(x)
        
        # Layer 2
        x = self.fc2(x)
        x = self.bn2(x)
        x = F.relu(x)
        x = self.dropout(x)
        
        # Layer 3
        x = self.fc3(x)
        x = self.bn3(x)
        x = F.relu(x)
        
        # Output Head
        logits = self.head_policy(x)
        return logits

    def save(self, path):
        torch.save(self.state_dict(), path)
        
    def load(self, path):
        self.load_state_dict(torch.load(path))
        self.eval()

```

### FILE: ai_worker\learning\puzzle_generator.py
```py

import os
import json
import time
import copy
import logging
from game_engine.models.card import Card

logger = logging.getLogger(__name__)

class PuzzleGenerator:
    """
    Converts live game blunders into Academy Puzzles.
    """
    def __init__(self, puzzle_dir="server/content/puzzles"):
        self.puzzle_dir = puzzle_dir
        os.makedirs(puzzle_dir, exist_ok=True)
        
    def create_from_blunder(self, ctx, human_card, best_card, analysis):
        """
        Creates a JSON puzzle from a detected blunder.
        
        Args:
            ctx (BotContext): The state when the blunder occurred.
            human_card (Card): The suboptimal card played.
            best_card (Card): The optimal card suggested.
            analysis (dict): MCTS analysis details.
        """
        try:
            # 1. Unique ID
            ts = int(time.time())
            game_id = ctx.raw_state.get('gameId', 'unknown')
            round_num = len(ctx.raw_state.get('roundHistory', [])) + 1
            # Sanitized ID
            safe_game_id = "".join(c for c in game_id if c.isalnum() or c in '_-')
            puzzle_id = f"exam_{ts}_{safe_game_id}"
            
            # 2. Sanitize State (Hide Opponent Info)
            initial_state = copy.deepcopy(ctx.raw_state)
            
            # Identify "Me" (The Human at ctx.player_index)
            # ctx.player_index is the human who blundered
            human_idx = ctx.player_index
            
            for p in initial_state.get('players', []):
                # BotContext players usually have 'index' or we infer from position order?
                # GameState players: { "id", "name", "position", "hand": [...], "score"... }
                # We can't rely on 'id' matching ctx.player_index directly without strict logic.
                # However, ctx.player_index matches the index in game.players list.
                # Let's hope initial_state['players'] is ordered list? YES (game.py line 91).
                
                # Logic: If this is NOT the human, clear their hand.
                # Find index of this player dict
                try:
                    p_idx = initial_state['players'].index(p)
                    if p_idx != human_idx:
                         p['hand'] = [] # Hide cards
                         # We could populate 'faceDown' placeholders if frontend supports it
                except ValueError:
                    pass
            
            # 3. Description
            mode = ctx.mode
            desc = f"You played {human_card}. The Professor found a better line. Can you find it?"
            
            # 4. Construct Puzzle
            puzzle = {
                "id": puzzle_id,
                "title": f"Professor's Exam: {mode} Blunder",
                "description": desc,
                "difficulty": "Intermediate", 
                "tags": ["Professor", mode, "Blunder"],
                "initial_state": initial_state,
                "solution": {
                    "type": "sequence",
                    "data": [str(best_card)]
                }
            }
            
            self.save_puzzle(puzzle)
            return True
            
        except Exception as e:
            logger.error(f"Failed to generate puzzle: {e}", exc_info=True)
            return False

    def save_puzzle(self, puzzle_dict):
        fname = f"{puzzle_dict['id']}.json"
        path = os.path.join(self.puzzle_dir, fname)
        with open(path, 'w', encoding='utf-8') as f:
            json.dump(puzzle_dict, f, indent=4)
        logger.info(f"Generated Puzzle: {path}")

```

### FILE: ai_worker\learning\train_network.py
```py

import sys
import os
import csv
import ast
import random
import time
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader

# Add parent directory
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from ai_worker.learning.feature_extractor import FeatureExtractor
from ai_worker.learning.model import StrategyNet

# Determine Device
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"Training on: {DEVICE}")

class BalootDataset(Dataset):
    def __init__(self, csv_file):
        self.samples = []
        self.extractor = FeatureExtractor()
        
        print(f"Loading dataset from {csv_file}...")
        
        try:
            with open(csv_file, 'r', encoding='utf-8') as f:
                reader = csv.reader(f)
                header = next(reader, None) # Skip header
                for row in reader:
                    if not row: continue
                    # row: [ts, game_id, vector_str, mcts_move_idx, target_str, win_rate]
                    if len(row) < 5: continue
                    
                    vector_str = row[2]
                    target_str = row[4] # "7S" (RankSuit)
                    
                    # Parse Input Vector
                    # vector_str is comma separated floats "0.00,1.00,..."
                    vector = [float(x) for x in vector_str.split(',')]
                    
                    # Parse Target (Card Label)
                    label_idx = self._parse_target_to_idx(target_str)
                    
                    if label_idx != -1 and len(vector) == 138:
                        self.samples.append({
                            'vector': torch.tensor(vector, dtype=torch.float32),
                            'label': torch.tensor(label_idx, dtype=torch.long)
                        })
                        
            print(f"Loaded {len(self.samples)} valid samples.")
            
        except Exception as e:
            print(f"Error loading dataset: {e}")

    def _parse_target_to_idx(self, target_str):
        # Format "7S", "10H", "AD" -> Rank + Suit
        if not target_str or target_str == 'None': return -1
        
        # Extract Suit (Last char)
        suit_char = target_str[-1]
        
        # Extract Rank (Rest)
        rank_str = target_str[:-1]
        
        # Normalize Suit
        norm_suit = self.extractor.suit_map.get(suit_char)
        if not norm_suit: return -1
        
        # Construct Key for FeatureExtractor map (SuitRank e.g. "‚ô†7")
        key = f"{norm_suit}{rank_str}"
        
        return self.extractor.card_to_idx.get(key, -1)

    def __len__(self):
        return len(self.samples)

    def __getitem__(self, idx):
        return self.samples[idx]

def train():
    # Paths
    project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    dataset_path = os.path.join(project_root, "ai_worker", "data", "training", "dataset.csv")
    models_dir = os.path.join(project_root, "ai_worker", "models")
    os.makedirs(models_dir, exist_ok=True)
    
    if not os.path.exists(dataset_path):
        print(f"Dataset not found at {dataset_path}")
        return

    # Hyperparameters
    BATCH_SIZE = 64
    EPOCHS = 20 # Start small
    LR = 0.001
    
    # Data
    full_dataset = BalootDataset(dataset_path)
    if len(full_dataset) == 0:
        print("Dataset empty. Run generate_neural_data.py first.")
        return
        
    train_size = int(0.8 * len(full_dataset))
    val_size = len(full_dataset) - train_size
    train_dataset, val_dataset = torch.utils.data.random_split(full_dataset, [train_size, val_size])
    
    train_loader = DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True)
    val_loader = DataLoader(val_dataset, batch_size=BATCH_SIZE, shuffle=False)
    
    # Model
    model = StrategyNet().to(DEVICE)
    optimizer = optim.Adam(model.parameters(), lr=LR)
    criterion = nn.CrossEntropyLoss()
    
    print(f"Starting Training: {EPOCHS} Epochs")
    
    best_acc = 0.0
    
    for epoch in range(EPOCHS):
        model.train()
        total_loss = 0
        correct = 0
        total = 0
        
        for batch in train_loader:
            x = batch['vector'].to(DEVICE)
            y = batch['label'].to(DEVICE)
            
            optimizer.zero_grad()
            outputs = model(x)
            loss = criterion(outputs, y)
            
            loss.backward()
            optimizer.step()
            
            total_loss += loss.item()
            
            _, predicted = torch.max(outputs.data, 1)
            total += y.size(0)
            correct += (predicted == y).sum().item()
            
        avg_loss = total_loss / len(train_loader)
        train_acc = 100 * correct / total
        
        # Validation
        val_acc = evaluate(model, val_loader)
        
        print(f"Epoch {epoch+1}/{EPOCHS} | Loss: {avg_loss:.4f} | Train Acc: {train_acc:.2f}% | Val Acc: {val_acc:.2f}%")
        
        if val_acc > best_acc:
            best_acc = val_acc
            save_path = os.path.join(models_dir, "strategy_net_best.pth")
            model.save(save_path)
            # print(f"Saved Best Model: {save_path}")

    print(f"Training Complete. Best Validation Accuracy: {best_acc:.2f}%")
    
    # Save Final
    final_path = os.path.join(models_dir, "strategy_net_final.pth")
    model.save(final_path)

def evaluate(model, loader):
    model.eval()
    correct = 0
    total = 0
    with torch.no_grad():
        for batch in loader:
            x = batch['vector'].to(DEVICE)
            y = batch['label'].to(DEVICE)
            outputs = model(x)
            _, predicted = torch.max(outputs.data, 1)
            total += y.size(0)
            correct += (predicted == y).sum().item()
    return 100 * correct / total

if __name__ == "__main__":
    train()

```

### FILE: ai_worker\mcts\benchmark_fast_game.py
```py

import time
import random
import sys
import os

# Placeholder for the FastGame class we plan to build
# For this benchmark, we'll simulate the operations it performs to estimate overhead.

class MockFastGame:
    def __init__(self):
        # State: 4 players, 5-8 cards each, trump, etc.
        self.hands = [[random.randint(0, 31) for _ in range(8)] for _ in range(4)]
        self.current_turn = 0
        self.trump = 'S'
        self.tricks_played = 0
        
    def get_legal_moves(self, player_idx):
        # Simulating logic: Check suit, check rank...
        hand = self.hands[player_idx]
        return [0, 1] if len(hand) > 1 else [0] # fast filtering
        
    def apply_move(self, player_idx, card_idx):
        # Simulating state update: Pop card, update turn
        card = self.hands[player_idx].pop(card_idx)
        self.current_turn = (self.current_turn + 1) % 4
        return card

    def is_terminal(self):
        return len(self.hands[0]) == 0

def run_benchmark():
    print("--- BENCHMARKING SIMULATION SPEED ---")
    
    start_time = time.time()
    iterations = 10000
    
    for _ in range(iterations):
        game = MockFastGame()
        # Simulate a full payout (32 moves)
        moves = 0
        while not game.is_terminal() and moves < 32:
            legal = game.get_legal_moves(game.current_turn)
            # Random Choice (MCTS Selection)
            chosen = legal[0] 
            game.apply_move(game.current_turn, chosen)
            moves += 1
            
    end_time = time.time()
    duration = end_time - start_time
    
    print(f"Iterations: {iterations}")
    print(f"Total Time: {duration:.4f}s")
    print(f"Games/Sec: {iterations / duration:.2f}")
    
    # Requirement: > 1000 Games/Sec for good MCTS
    if (iterations / duration) > 1000:
        print("RESULT: ‚úÖ VIABLE (Python is fast enough)")
    else:
        print("RESULT: ‚ö†Ô∏è CAUTION (Optimization needed)")

if __name__ == "__main__":
    run_benchmark()

```

### FILE: ai_worker\mcts\benchmark_solver.py
```py

import time
import sys
import os
sys.path.append(os.getcwd())

from game_engine.models.card import Card
from ai_worker.mcts.fast_game import FastGame
from ai_worker.mcts.mcts import MCTSSolver

def run_solver_benchmark():
    print("--- BENCHMARKING MCTS SOLVER ---")
    
    # Setup: 2 Cards left (Endgame trivial)
    # Bottom: [AS, KS]
    # Right: [QS, JS]
    # Top: [9S, 8S]
    # Left: [7S, AD] 
    
    # Logic: Bottom should play AS first to win securely.
    
    hands = [
        [Card('S','A'), Card('S','K')],
        [Card('S','Q'), Card('S','J')],
        [Card('S','9'), Card('S','8')],
        [Card('S','7'), Card('D','A')] 
    ]
    
    game = FastGame(hands, trump='S', mode='HOKUM', current_turn=0, dealer_index=0)
    
    solver = MCTSSolver()
    
    start = time.time()
    best_move_idx = solver.search(game, timeout_ms=200) # 200ms budget
    end = time.time()
    
    print(f"Time Taken: {(end-start)*1000:.2f}ms")
    print(f"Best Move Index: {best_move_idx}")
    
    # Index 0 is AS, Index 1 is KS. Both are winning, but let's see stats.
    # (Actually in MCTS stats printing handles debugging usually)
    
    print("MCTS Solver completed.")

if __name__ == "__main__":
    run_solver_benchmark()

```

### FILE: ai_worker\mcts\fast_game.py (SKIPPED - >10KB)
### FILE: ai_worker\mcts\mcts.py (SKIPPED - >10KB)
### FILE: ai_worker\mcts\test_fast_game.py
```py

import unittest
import sys
import os

# Path hack
sys.path.append(os.getcwd())

from game_engine.models.card import Card
from ai_worker.mcts.fast_game import FastGame

class TestFastGame(unittest.TestCase):
    
    def test_sun_logic(self):
        # Setup: Sun Game, 1 Cards each
        hands = [
            [Card('S','A')], # Bottom
            [Card('S','10')], # Right
            [Card('S','K')], # Top
            [Card('S','7')]  # Left
        ]
        
        game = FastGame(hands, trump=None, mode='SUN', current_turn=0, dealer_index=0)
        
        # Bottom Plays A
        moves = game.get_legal_moves()
        self.assertEqual(moves, [0])
        game.apply_move(0)
        
        # Right Plays 10
        game.apply_move(0)
        # Top Plays K
        game.apply_move(0)
        # Left Plays 7
        game.apply_move(0)
        
        # Bottom should win (A > 10 > K > 7)
        # Points: A(11) + 10(10) + K(4) + 7(0) = 25
        # Last Trick Bonus = 10 -> Total 35
        
        self.assertTrue(game.is_terminal())
        self.assertEqual(game.scores['us'], 35)
        self.assertEqual(game.scores['them'], 0)

    def test_hokum_trump_logic(self):
        # Trump is Spades
        hands = [
            [Card('D','A')],  # Bottom (Leads Diamond)
            [Card('D','7')],  # Right (Has D)
            [Card('H','7')],  # Top (Void D, No Trump)
            [Card('S','7')]   # Left (Void D, Has Trump 7)
        ]
        game = FastGame(hands, trump='S', mode='HOKUM', current_turn=0, dealer_index=0)
        
        # Bottom Plays DA
        game.apply_move(0)
        
        # Right follows D7
        game.apply_move(0)
        
        # Top discards H7
        game.apply_move(0)
        
        # Left Trumps with S7
        game.apply_move(0)
        
        # Left should win
        self.assertTrue(game.is_terminal())
        self.assertEqual(game.tricks_collected['them'], 1)
        # Points: A(11) + 10(Last) = 21 (Assuming others are 0)
        self.assertEqual(game.scores['them'], 21)

if __name__ == '__main__':
    unittest.main()

```

### FILE: ai_worker\mcts\utils.py
```py
import random
from typing import List, Set
from game_engine.models.card import Card
from ai_worker.bot_context import BotContext
from game_engine.models.constants import SUITS

def generate_random_distribution(ctx: BotContext) -> List[List[Card]]:
    """
    Generates a random distribution of remaining cards to other players,
    respecting known voids and played cards.
    Returns list of 4 Hands (indices 0..3).
    """
    # 1. Identify Remaining Cards
    # We need a full deck set
    all_cards = []
    for s in SUITS:
        ranks = ['7','8','9','10','J','Q','K','A']
        for r in ranks:
            all_cards.append(Card(s, r))
            
    # Remove My Hand
    # Defensive: Ensure ctx.hand contains Card objects
    sanitized_hand = []
    for c in ctx.hand:
        if isinstance(c, dict):
            # Reconstruct Card from dict if needed
            sanitized_hand.append(Card(c['suit'], c['rank']))
        elif hasattr(c, 'suit'):
             sanitized_hand.append(c)
        else:
             # Fallback or error?
             pass
             
    my_hand_str = [str(c) for c in sanitized_hand]
    
    # Remove Played Cards (from Memory)
    played = ctx.memory.played_cards # Set of strings like "7H"

        
    remaining = []
    for c in all_cards:
        if str(c) not in my_hand_str and str(c) not in played:
            remaining.append(c)
            
    # 2. Identify Player Current Counts
    # We need to know how many cards each opponent SHOULD have.
    # Total cards = 32. 4 players. 8 each.
    # Round number? 
    # Current trick size tells us who played.
    
    tricks_history = ctx.raw_state.get('currentRoundTricks', [])
    current_trick_size = len(ctx.raw_state.get('tableCards', []))
    
    # Ideally, track cards per player.
    # Simplified: Assume all start with 8. Subtract plays.
    
    # 3. Allocator
    # Shuffle remaining
    random.shuffle(remaining)
    
    # Distribute (Blindly for now - ignoring voids logic for MVP)
    # Map to positions
    hands = [[], [], [], []] # Bottom, Right, Top, Left
    
    # Fill Bottom (Self)
    hands[0] = [c for c in sanitized_hand] # Copy
    
    # Fill Others
    # This naive distribution assumes equal counts. 
    # In endgame, counts MUST be precise.
    # TODO: Implement precise counting in BotContext/Memory.
    
    # Temporary: Just distribute remaining equally to 1, 2, 3
    # This will FAIL if counts are uneven (someone played out of turn or different trick counts?)
    # Valid assumption: In Baloot, everyone plays 1 card per trick.
    # So everyone has equal cards unless trick is in progress.
    
    # Who has played in current trick?
    played_in_current = [p['playedBy'] for p in ctx.raw_state.get('tableCards', [])]
    
    target_counts = {}
    total_tricks = len(tricks_history)
    start_count = 8
    
    positions = ['Bottom', 'Right', 'Top', 'Left']
    
    for i, pos in enumerate(positions):
        cards_left = start_count - total_tricks
        if pos in played_in_current:
             cards_left -= 1
        target_counts[i] = cards_left
        
    # --- CONSTRAINT-BASED DISTRIBUTION ---
    # We have 'remaining' cards and 'target_counts' per player.
    # We have 'ctx.memory.voids' (Map: pos_string -> Set[suits]).
    
    player_positions = ['Bottom', 'Right', 'Top', 'Left']
    
    # Filter valid slots for each card
    # Simplest approach: Shuffle cards, try to assign to valid player with space. If stuck, restart.
    
    max_attempts = 10
    success = False
    
    for attempt in range(max_attempts):
         random.shuffle(remaining)
         
         # Reset Hands (Keep Bottom fixed)
         temp_hands = [[], [], [], []]
         temp_hands[0] = [c for c in ctx.hand]
         
         current_counts = {i: 0 for i in range(4)}
         
         # Identify who needs cards
         needs_cards = [] # List of player_idx
         for i in range(1, 4): # Right, Top, Left
              count_needed = target_counts[i]
              for _ in range(count_needed):
                   needs_cards.append(i)
         
         # Optimize: needs_cards list is what we iterate? 
         # No, iterate CARDS and find home.
         
         fail_attempt = False
         
         # Count check
         if len(needs_cards) != len(remaining):
              # Mismatch in tracking (e.g. played cards not synced)
              # Just force fill to avoid crash
              pass
              
         # To simplify: We cycle through players and give cards, checking constraints.
         # But specific players might be constrained on specific suits.
         # Hard constraints first?
         
         # Let's map Card -> [Valid Players]
         card_options = []
         for card in remaining:
              options = []
              for p_idx in range(1, 4): # 1, 2, 3
                   pos_str = player_positions[p_idx]
                   if target_counts[p_idx] > len(temp_hands[p_idx]):
                        # Has room
                        # Check Void
                        is_void = ctx.memory.is_void(pos_str, card.suit)
                        if not is_void:
                             options.append(p_idx)
                             
              if not options:
                   fail_attempt = True
                   break
              card_options.append((card, options))
              
         if fail_attempt: continue
         
         # Distribution (Greedy with some randomness)
         # Sort by "Most Constrained" (Fewest Options) first to avoid getting stuck?
         card_options.sort(key=lambda x: len(x[1]))
         
         for card, options in card_options:
              # Filter options to those who STILL have room
              valid_opts = [idx for idx in options if len(temp_hands[idx]) < target_counts[idx]]
              
              if not valid_opts:
                   fail_attempt = True
                   break
                   
              chosen_idx = random.choice(valid_opts)
              temp_hands[chosen_idx].append(card)
              
         if not fail_attempt:
              hands = temp_hands
              success = True
              break
              
    if not success:
         # Fallback to naive distribution (Constraint Violation is better than Crash)
         # Re-run strict naive
         return _naive_distribution(remaining, target_counts, ctx.hand)
         
    return hands

def _naive_distribution(remaining, target_counts, my_hand):
    hands = [[], [], [], []]
    
    # Defensive: Ensure my_hand contains Card objects even here (if passed directly)
    sanitized_my_hand = []
    for c in my_hand:
        if isinstance(c, dict):
            sanitized_my_hand.append(Card(c['suit'], c['rank']))
        elif hasattr(c, 'suit'):
             sanitized_my_hand.append(c)
             
    hands[0] = [c for c in sanitized_my_hand]
    
    current_idx_for_dist = 1
    for card in remaining:
        while current_idx_for_dist < 4 and len(hands[current_idx_for_dist]) >= target_counts[current_idx_for_dist]:
             current_idx_for_dist += 1
             
        if current_idx_for_dist < 4:
             hands[current_idx_for_dist].append(card)
    return hands


```

### FILE: ai_worker\signals\definitions.py
```py
from enum import Enum

class SignalType(Enum):
    ENCOURAGE = "ENCOURAGE"    # "Play this suit!" (Call)
    DISCOURAGE = "DISCOURAGE"  # "Don't play this suit" (Trash)
    PREFER_OPPOSITE_COLOR = "PREFER_OPPOSITE_COLOR" # "Play opposite color" (Suit Preference)
    NEGATIVE_DISCARD = "NEGATIVE_DISCARD" # "I definitely don't want this suit" (Tahreeb)
    URGENT_CALL = "URGENT_CALL" # "Play this suit NOW!" (Barqiya)
    PREFER_SAME_COLOR = "PREFER_SAME_COLOR" # "Play the *other* suit of the same color"
    CONFIRMED_POSITIVE = "CONFIRMED_POSITIVE" # "Low to High" sequence (Strong Encourage)
    CONFIRMED_NEGATIVE = "CONFIRMED_NEGATIVE" # "High to Low" sequence (Absolute Rejection)
    NONE = "NONE"              # No signal intended

class SignalStrength(Enum):
    HIGH = 3   # Explicit signal (e.g., discarding a 10)
    MEDIUM = 2 # Likely signal (e.g., discarding a King)
    LOW = 1    # Weak signal (e.g., discarding a 9)

```

### FILE: ai_worker\signals\manager.py
```py
from ai_worker.signals.definitions import SignalType, SignalStrength
from game_engine.models.constants import POINT_VALUES_SUN, POINT_VALUES_HOKUM, SUITS
import logging

logger = logging.getLogger(__name__)

class SignalManager:
    """
    Manages the emission and detection of collaborative signals.
    """
    
    def __init__(self):
        pass

    def get_signal_for_card(self, card, is_partner_winning, mode='SUN'):
        """
        Analyzes a discarded card to see what signal it sends.
        Advanced Tahreeb/Tanfeer Logic:
        - If Partner Winning (Tahreeb): 
             - Discard = NEGATIVE (Don't want this).
             - Implies PREFER_SAME_COLOR (Want the other suit of same color).
        - If Enemy Winning (Tanfeer):
             - Discard = POSITIVE (Encourage).
             - Ace Discard = URGENT_CALL (Barqiya).
        """
        rank = card.rank
        
        if is_partner_winning:
             # TAHREEB (Negative Signaling)
             # "Any card you discard means you don't want it."
             # Also implies "Same Color, Opposite Shape" -> PREFER_SAME_COLOR
             return SignalType.NEGATIVE_DISCARD
             
        else:
             # TANFEER (Positive Signaling)
             # "If you 'shun' (discard), it means you want the suit."
             
             # BARQIYA (The Telegraph) - Ultra High Urgency
             if rank == 'A':
                  return SignalType.URGENT_CALL
             
             # Standard Encouragement
             if rank in ['10', 'K', 'Q', 'J']: # Even J/Q can be signals in Tanfeer
                  return SignalType.ENCOURAGE
             
             # Low cards in Tanfeer?
             # Usually Tanfeer requires a "Power Card" to show strength.
             # Discarding a 7 in Tanfeer might just be trash/ducking.
             # Research: "If you 'Tanfeer,' it means you want that suit OR you have the Ace"
             # So usually high cards. 
             # Let's keep 7,8,9 as NONE or maybe weak encourage?
             # Implementation Plan said: "Enemy plays Ace (Wins). Bot discards 10s -> Encourage".
             # Bot discards 7 -> Probably just trash.
             pass
             
        return SignalType.NONE

    def analyze_directional_signal(self, discards, suit_of_interest):
        """
        Analyzes a sequence of discards (same suit) to detect Directional Signaling.
        
        Args:
            discards: List of dicts [{'rank': '7', 'suit': 'S', 'trick_idx': 1}, ...]
                      Must be sorted by trick_idx.
            suit_of_interest: The suit we are checking signals for.
            
        Returns:
            SignalType.CONFIRMED_POSITIVE (Low -> High)
            SignalType.CONFIRMED_NEGATIVE (High -> Low)
            SignalType.NONE
        """
        relevant_discards = [d for d in discards if d['suit'] == suit_of_interest]
        
        # We need at least 2 cards to form a directional signal
        if len(relevant_discards) < 2:
            return SignalType.NONE
            
        # Get the first two discards of this suit
        # Note: 'discards' list passed in should be chronological.
        d1 = relevant_discards[0]
        d2 = relevant_discards[1]
        
        # Check Ranks
        # We need a rank comparison helper. 
        # Since this is generic signaling (usually applied in Sun or Hokum indiscriminately for directional logic),
        # we'll use Sun Order (A > 10 > K...) or just simple ordering?
        # Research says: "Small to Big" means "7 then J" or "7 then 9".
        # It usually implies standard geometric size, but in Baloot "Big" usually means Power (A, 10, K).
        # Let's use the standard Sun Order indices for "Value".
        # But wait, 7 is smaller than 8? Yes.
        # A (Index 0) is Biggest. 7 (Index 7) is Smallest.
        # So "Low to High" means: Small Card (High Index) -> Big Card (Low Index).
        
        from game_engine.models.constants import ORDER_SUN
        
        try:
            val1 = ORDER_SUN.index(d1['rank']) # Lower index = Higher Power
            val2 = ORDER_SUN.index(d2['rank'])
            
            # Logic:
            # ORDER_SUN is Ascending Power (0=7, 7=A).
            # Low (Index 0) -> High (Index 7)
            # So if val1 < val2 (First card was weaker), then SIGNAL IS INCREASING POWER.
            # "Low to High" = "Small then Big" = CONFIRMED_POSITIVE.
            
            if val1 < val2:
                return SignalType.CONFIRMED_POSITIVE
                
            # Logic:
            # High (Index 7) -> Low (Index 0)
            # So if val1 > val2 (First card was stronger), then SIGNAL IS DECREASING POWER.
            # "High to Low" = "Big then Small" = CONFIRMED_NEGATIVE.
            
            if val1 > val2:
                return SignalType.CONFIRMED_NEGATIVE
                
        except ValueError:
            pass
            
        return SignalType.NONE

    def get_discard_signal_card(self, hand, target_suit, mode='SUN'):
        """
        Selects the best card to discard to signal ENCOURAGE for target_suit.
        """
        # Find cards of target_suit
        candidates = [c for c in hand if c.suit == target_suit]
        if not candidates:
            return None
            
        # Preference Order for Signaling "Come Here":
        # 1. Ten (10) - Classic "Call". High value but not Master (usually).
        # 2. King (K) - Strong but safer than 10.
        # 3. Queen (Q)
        # 4. Ace (A) - risky to discard Master unless we have others.
        
        # Sort candidates by suitability for signaling
        # We need a scoring function based on Rank
        
        best_c = None
        max_score = -1
        
        # Analyze Hand Strength for Signal Selection
        ranks = [c.rank for c in candidates]
        has_ace = 'A' in ranks
        has_ten = '10' in ranks
        has_king = 'K' in ranks
        
        is_solid_run = has_ace and has_ten and (has_king or 'Q' in ranks)
        
        for c in candidates:
            score = 0
            
            # SIGNAL PRIORITY SCORING
            
            # Ace (Master)
            if c.rank == 'A':
                 if is_solid_run:
                      # If we have the rest, Ace is the BEST PRO signal.
                      score = 200 
                 else:
                      # Risky to throw Ace if we don't have the rest.
                      score = 20 
                      
            # Ten (Standard Call)
            elif c.rank == '10':
                 if has_ace: score = 100 # Standard "I have Ace"
                 else: score = 50 # Strong card, but risky signal if no Ace
            
            # King
            elif c.rank == 'K': 
                 if has_ace: score = 90 # Good backup signal
                 elif has_ten and 'Q' in ranks: score = 80 # Signal sequence
                 # In Tanfeer, K signal means "I have A" or "I want this".
                 else: score = 40
                 
            # Queen     
            elif c.rank == 'Q': score = 60
            
            # Low Cards (Opposite Color Signal)
            # They don't signal ENCOURAGE for *this* suit.
            # But the manager might be asked: "What is best card to signal X?"
            # If we want to signal X, we shouldn't return a low card of X?
            # Correct. get_discard_signal_card is for "ENCOURAGE TARGET SUIT".
            # So low cards should have score 0 here.
            else: score = 0 
            
            if score > max_score:
                max_score = score
                best_c = c
                
        if max_score > 0:
            return best_c
            
        return None

    def should_signal_encourage(self, hand, suit, mode='SUN'):
        """
        Determines if we hold a hand strong enough to warrant a signal.
        """
        # We should only signal if we have the Master (Ace) OR valid control
        # e.g. A, K... or A, 10... or K, Q, J (if Ace is gone?)
        
        cards = [c for c in hand if c.suit == suit]
        ranks = [c.rank for c in cards]
        
        has_ace = 'A' in ranks
        has_ten = '10' in ranks
        has_king = 'K' in ranks
        
        # Logic: Signal "Encourage" if we have strong control.
        
        # Scenario 1: "I have the rest" (Ace Signal)
        # Requires: Ace AND (10 AND King) OR (Ace AND 10 AND Q/J etc)
        # Basically a very strong run.
        if has_ace and has_ten and (has_king or 'Q' in ranks):
            return True
            
        # Scenario 2: "I have the Ace" (Standard Call)
        # Use 10 or King to signal.
        # Requires: Ace AND (King OR Queen OR J) to justify saving it?
        # Actually any Ace + backup is worth signaling.
        if has_ace and (has_king or has_ten or 'Q' in ranks):
            return True
            
        # Scenario 3: Sequence without Ace (K, Q, J, 10)
        # Signal to draw out the Ace?
        if has_king and 'Q' in ranks and 'J' in ranks:
             return True
            
        return False

```

### FILE: ai_worker\strategies\bidding.py (SKIPPED - >10KB)
### FILE: ai_worker\strategies\neural.py
```py

import logging
import random
import torch
import os
from ai_worker.bot_context import BotContext
from ai_worker.learning.model import StrategyNet
from ai_worker.learning.feature_extractor import FeatureExtractor

logger = logging.getLogger(__name__)

class NeuralStrategy:
    def __init__(self, model_path=None):
        self.extractor = FeatureExtractor()
        self.model = StrategyNet()
        self.device = torch.device("cpu") # Inference on CPU is fine/safer for now
        self.model.to(self.device)
        self.model.eval()
        self.enabled = False
        
        # Load Model if exists
        if model_path and os.path.exists(model_path):
            try:
                self.model.load(model_path)
                self.enabled = True
                logger.info(f"Neural Strategy Loaded: {model_path}")
            except Exception as e:
                logger.error(f"Failed to load Neural Model: {e}")
                self.enabled = False
        else:
             logger.warning(f"Neural Model not found at {model_path}. Strategy Disabled.")

    def get_decision(self, ctx: BotContext) -> dict:
        if not self.enabled:
             return None
             
        try:
            # 1. Encode State
            # Pass legal moves mask? The net output is 32 cards.
            # We can mask output instead of input for now.
            vec = self.extractor.encode(ctx)
            tensor_in = torch.tensor(vec, dtype=torch.float32).unsqueeze(0).to(self.device)
            
            # 2. Inference
            with torch.no_grad():
                logits = self.model(tensor_in).squeeze(0) # [32]
                
            # 3. Mask Illegal Moves
            legal_indices = ctx.get_legal_moves()
            if not legal_indices:
                 return None
                 
            # Convert hand indices to Deck Indices (0-31)
            # The model predicts distinct cards 0-31.
            # We map: Model Output (0-31) -> Card Object -> Index in Hand
            
            # Create a simplified map: {DeckIndex: HandIndex}
            legal_map = {} # deck_idx -> hand_idx
            
            # Start with -Inf for all
            masked_logits = torch.full_like(logits, -1e9)
            
            for hand_idx in legal_indices:
                 card = ctx.hand[hand_idx]
                 deck_idx = self.extractor._get_card_index(card)
                 if deck_idx != -1:
                      masked_logits[deck_idx] = logits[deck_idx]
                      legal_map[deck_idx] = hand_idx
            
            # 4. Select Best
            best_deck_idx = torch.argmax(masked_logits).item()
            
            if best_deck_idx in legal_map:
                 best_hand_idx = legal_map[best_deck_idx]
                 
                 # Debug Score
                 score = logits[best_deck_idx].item()
                 
                 return {
                     "action": "PLAY",
                     "cardIndex": best_hand_idx,
                     "reasoning": f"Neural Network (Score: {score:.2f})"
                 }
            
            # Fallback (Should not happen unless empty mask)
            return None
            
        except Exception as e:
            logger.error(f"Neural Inference Failed: {e}")
            return None

    def predict_policy(self, ctx_or_game) -> dict:

        """
        Returns a dictionary mapping hand_index -> probability.
        Sum of probabilities will be 1.0 (Softmax).
        Calculates P(s, a) for PUCT MCTS.
        Supports both BotContext and FastGame.
        """
        if not self.enabled:
             # Fallback: Uniform distribution over legal moves
             legal = ctx_or_game.get_legal_moves()
             if not legal: return {}
             prob = 1.0 / len(legal)
             return {idx: prob for idx in legal}

        try:
            # 1. Encode
            is_fast = hasattr(ctx_or_game, 'played_cards_in_trick') # Duck type FastGame
            legal_indices = ctx_or_game.get_legal_moves()
            if not legal_indices: return {}

            if is_fast:
                 vec = self.extractor.encode_fast(ctx_or_game, legal_indices)
            else:
                 vec = self.extractor.encode(ctx_or_game, legal_indices)
                 
            tensor_in = torch.tensor(vec, dtype=torch.float32).unsqueeze(0).to(self.device)
            
            with torch.no_grad():
                logits = self.model(tensor_in).squeeze(0) # [32]

            # 2. Mask Illegal Moves (Indices)
            # Map Hand Indices to Deck Indices for Logit Lookup
            
            # Context Switch:
            # BotContext: self.hand[idx] -> Card Object
            # FastGame: self.hands[self.current_turn][idx] -> Card Object
            
            curr_hand = None
            if is_fast:
                 curr_hand = ctx_or_game.hands[ctx_or_game.current_turn]
            else:
                 curr_hand = ctx_or_game.hand
            
            masked_logits = []
            
            for hand_idx in legal_indices:
                 card = curr_hand[hand_idx]
                 deck_idx = self.extractor._get_card_index(card)
                 if deck_idx != -1:
                      masked_logits.append(logits[deck_idx])
                 else:
                      masked_logits.append(torch.tensor(-10.0))

            if not masked_logits: return {}

            # 3. Softmax
            masked_logits_tensor = torch.stack(masked_logits)
            probs = torch.nn.functional.softmax(masked_logits_tensor, dim=0)
            
            # 4. Build Result
            policy = {}
            for i, hand_idx in enumerate(legal_indices):
                 policy[hand_idx] = probs[i].item()
                 
            return policy

        except Exception as e:
            logger.error(f"Neural Policy Prediction Failed: {e}")
            # Fallback
            legal = ctx_or_game.get_legal_moves()
            if not legal: return {}
            return {idx: 1.0/len(legal) for idx in legal}

```

### FILE: ai_worker\strategies\oracle_bidding.py
```py

import logging
import statistics
from ai_worker.bot_context import BotContext
from ai_worker.mcts.utils import generate_random_distribution
from ai_worker.mcts.fast_game import FastGame
from game_engine.models.constants import SUITS, BidType

logger = logging.getLogger(__name__)

class OracleBiddingStrategy:
    """
    Experimental PIMC (Perfect Information Monte Carlo) Bidding Engine.
    Estimates hand strength by simulating double-dummy games.
    """
    
    def evaluate_hand(self, ctx: BotContext) -> dict:
        """
        Runs simulations to estimate points for SUN and HOKUM.
        Returns detailed stats including Win Probability.
        """
        debug_logs = []
        debug_logs.append(f"[ORACLE] Evaluating Hand: {[str(c) for c in ctx.hand]}")
        
        # 1. Identify candidate suits
        candidates = ['SUN']
        for s in SUITS:
            # Only test suits we have some presence in (heuristic optimization)
            count = sum(1 for c in ctx.hand if c.suit == s)
            if count >= 2: candidates.append(s)
             
        # 2. Generate Worlds
        world_count = 15 # Increased for better stability
        worlds = []
        for _ in range(world_count):
             try:
                hands = generate_random_distribution(ctx)
                worlds.append(hands)
             except Exception as e:
                logger.warning(f"World Gen Failed: {e}")
                
        if not worlds:
             return {"best_bid": None, "error": "Failed to generate worlds"}
             
        # 3. Simulate
        # Store (Score, WinBool) for each simulation
        results = { k: [] for k in candidates }
        
        dealer_idx = ctx.raw_state.get('dealerIndex', 0)
        # Leader is always player after Dealer
        start_turn = (dealer_idx + 1) % 4
        
        for world in worlds:
             for mode in candidates:
                  curr_trump = mode if mode in SUITS else None
                  curr_mode = 'SUN' if mode == 'SUN' else 'HOKUM'
                  
                  # Create FastGame
                  game = FastGame(
                      players_hands=[h[:] for h in world], 
                      trump=curr_trump,
                      mode=curr_mode,
                      current_turn=start_turn,
                      dealer_index=dealer_idx
                  )
                  
                  try:
                      game.play_greedy()
                  except Exception as e:
                      # If simulation fails (e.g. empty hand bug), skip
                      continue
                  
                  # Score from 'us' perspective
                  my_score = game.scores['us']
                  their_score = game.scores['them']
                  
                  # Did we win the bid? (Strict win > them)
                  # In Baloot, if equal, Taker usually loses (Khasara).
                  # So we need MyScore > TheirScore.
                  win = (my_score > their_score)
                  
                  results[mode].append({
                      'score': my_score,
                      'win': win
                  })
                  
        # 4. Aggregate & Decide
        best_bid = "PASS"
        best_metric = 0 # Can be EV or WinProb mix
        details = {}
        
        for k in candidates:
             runs = results[k]
             if not runs: continue
             
             avg_score = statistics.mean([r['score'] for r in runs])
             win_prob = sum(1 for r in runs if r['win']) / len(runs)
             
             details[k] = {
                 'ev': avg_score,
                 'win_prob': win_prob,
                 'samples': len(runs)
             }
             
             debug_logs.append(f"[ORACLE] {k}: WinProb {win_prob:.2%} (EV {avg_score:.1f})")
             
             # Decision Logic
             # Safe Threshold: WinProb > 60% AND EV > Safe Margin
             # Sun Safe: > 76 points (Half of 152) roughly.
             # Hokum Safe: > 81 points (Half of 162).
             # UPDATE: FastGame returns raw points.
             # Sun Max: 130 + 10 = 140. Majority = 70.
             # Hokum Max: 152 + 10 = 162. Majority = 81.
             
             threshold_prob = 0.60 
             
             if k == 'SUN':
                 # Using 65 as baseline (slightly risky but aggressive for strong hands)
                 if win_prob > threshold_prob and avg_score > 65:
                     if win_prob > best_metric:
                         best_metric = win_prob
                         best_bid = "SUN"
                         
             elif k in SUITS:
                 if win_prob > threshold_prob and avg_score > 75: # Hokum usually higher points
                     if win_prob > best_metric:
                         best_metric = win_prob
                         best_bid = "HOKUM"
                         details['best_suit'] = k

        print("\n[ORACLE DEBUG]\n" + "\n".join(debug_logs))
        logger.info("\n".join(debug_logs))
        
        return {
            "best_bid": best_bid,
            "best_suit": details.get('best_suit'),
            "confidence": best_metric,
            "details": details
        }

```

### FILE: ai_worker\strategies\playing.py (SKIPPED - >10KB)
### FILE: frontend\.gitignore
```
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

```

### FILE: frontend\index.html
```html
<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Baloot Master</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;500;700;800&family=Roboto+Slab:wght@700;900&family=Cairo:wght@400;700&display=swap"
    rel="stylesheet">

</head>

<body>
  <div id="root"></div>
  <script type="module" src="/index.tsx"></script>
</body>

</html>
```

### FILE: frontend\index.tsx
```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './src/App';
import './src/index.css';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}


const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

### FILE: frontend\metadata.json
```json
{
  "name": "Baloot Master",
  "description": "A high-fidelity recreation of the popular Saudi Arabian card game Baloot, featuring an authentic Sadu-themed table, Arabic interface, and AI opponents powered by Google Gemini.",
  "requestFramePermissions": []
}
```

### FILE: frontend\package-lock.json (SKIPPED - >10KB)
### FILE: frontend\package.json
```json
{
  "name": "baloot-master",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "vitest"
  },
  "dependencies": {
    "@fontsource/cairo": "^5.2.7",
    "@fontsource/roboto-slab": "^5.2.8",
    "@google/genai": "^1.31.0",
    "@react-three/drei": "^10.7.7",
    "@react-three/fiber": "^9.5.0",
    "@types/d3": "^7.4.3",
    "@types/three": "^0.182.0",
    "canvas-confetti": "^1.9.4",
    "d3": "^7.9.0",
    "framer-motion": "^12.29.0",
    "leva": "^0.10.1",
    "lucide-react": "^0.555.0",
    "maath": "^0.10.8",
    "onnxruntime-web": "^1.23.2",
    "react": "^19.2.1",
    "react-dom": "^19.2.1",
    "recharts": "^3.7.0",
    "socket.io-client": "^4.8.1",
    "three": "^0.182.0",
    "use-sound": "^5.0.0"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.1",
    "@types/canvas-confetti": "^1.9.0",
    "@types/jest": "^30.0.0",
    "@types/node": "^22.14.0",
    "@types/testing-library__jest-dom": "^5.14.9",
    "@vitejs/plugin-react": "^5.0.0",
    "jsdom": "^27.3.0",
    "prettier": "^3.8.1",
    "typescript": "~5.8.2",
    "vite": "^6.2.0",
    "vitest": "^4.0.16"
  }
}

```

### FILE: frontend\README.md
```md
<div align="center">
<img width="1200" height="475" alt="GHBanner" src="https://github.com/user-attachments/assets/0aa67016-6eaf-458a-adb2-6e31a0763ed6" />
</div>

# Run and deploy your AI Studio app

This contains everything you need to run your app locally.

> **Developers**: Please read the [Frontend Guide](../docs/FRONTEND_GUIDE.md) for architecture details.

View your app in AI Studio: https://ai.studio/apps/drive/1qd78wkWM5c8pZUc-MaZyx3VsewehTTQm

## Run Locally

**Prerequisites:**  Node.js


1. Install dependencies:
   `npm install`
2. Set the `GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key
3. Run the app:
   `npm run dev`

```

### FILE: frontend\tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./src/*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
```

### FILE: frontend\vite.config.ts
```ts
import path from 'path';
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, '.', '');
  return {
    server: {
      port: 5173,
      strictPort: true, // Fail if port is in use, don't auto-switch
      host: '0.0.0.0',
      proxy: {
        '/socket.io': {
          target: 'http://127.0.0.1:3005',
          ws: true
        },
        '/react-py4web': {
          target: 'http://127.0.0.1:3005',
          changeOrigin: true,
          secure: false,
          bypass: (req) => {
            // Bypass proxy for the app's static assets and index.html
            // The app is served at /react-py4web/static/build/
            if (req.url && (req.url.startsWith('/react-py4web/static/build/') ||
              req.url.includes('/src/') ||
              req.url.includes('/@vite/') ||
              req.url.includes('/node_modules/'))) {
              return req.url;
            }
          },
        },
        '/static': {
          target: 'http://127.0.0.1:3005',
          changeOrigin: true,
          secure: false,
        },
        '/user': 'http://127.0.0.1:3005',
        '/signup': 'http://127.0.0.1:3005',
        '/signin': 'http://127.0.0.1:3005',
        '/save_score': 'http://127.0.0.1:3005',
        '/leaderboard': 'http://127.0.0.1:3005',
        '/training_data': 'http://127.0.0.1:3005',
        '/submit_training': 'http://127.0.0.1:3005',
        '/brain': 'http://127.0.0.1:3005',
        '/analyze_screenshot': 'http://127.0.0.1:3005',
        '/ask_strategy': 'http://127.0.0.1:3005',
        '/generate_scenario': 'http://127.0.0.1:3005',
        '/analyze_match': 'http://127.0.0.1:3005',
        '/ai_thoughts': 'http://127.0.0.1:3005',
        '/match_history': 'http://127.0.0.1:3005',
        '/replay': 'http://127.0.0.1:3005',
        '/puzzles': 'http://127.0.0.1:3005',
      },
    },
    plugins: [react()],
    base: '/react-py4web/static/build/',
    build: {
      outDir: '../static/build',
      emptyOutDir: true
    },
    define: {
      'process.env.API_KEY': JSON.stringify(env.GEMINI_API_KEY),
      'process.env.GEMINI_API_KEY': JSON.stringify(env.GEMINI_API_KEY)
    },
    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src'),
      }
    },
    test: {
      globals: true,
      environment: 'jsdom',
      setupFiles: './src/setupTests.ts',
    }
  };
});

```

### FILE: frontend\src\App.test.tsx
```tsx
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import App from '../App';
import React from 'react';

// Mocking required contexts or components if App depends on them and they fail directly
// For now, let's just try to render if possible. If App has logic that fails, we might need a simpler test first.
// But user requested "automated tests for this application", so App test is good.

describe('App Component', () => {
    it('renders without crashing', () => {
        // Note: App often requires providers (Router, Context, etc.)
        // If App fails, we might need to wrap it.
        // Let's create a dummy test first to verify the runner works.
        expect(true).toBe(true);
    });
});

```

### FILE: frontend\src\App.tsx (SKIPPED - >10KB)
### FILE: frontend\src\config.ts
```ts
export const API_BASE_URL = window.location.hostname === 'localhost'
    ? 'http://localhost:3005'
    : 'http://localhost:3005'; // Default to localhost for now, adjust for prod 

```

### FILE: frontend\src\constants.ts
```ts
import { CardModel, Rank, Suit } from './types';

export const RANKS_ORDER = [Rank.Seven, Rank.Eight, Rank.Nine, Rank.Jack, Rank.Queen, Rank.King, Rank.Ten, Rank.Ace];

export const generateDeck = (): CardModel[] => {
  const suits = [Suit.Hearts, Suit.Diamonds, Suit.Clubs, Suit.Spades];
  const ranks = [Rank.Seven, Rank.Eight, Rank.Nine, Rank.Ten, Rank.Jack, Rank.Queen, Rank.King, Rank.Ace];

  let deck: CardModel[] = [];
  let idCounter = 0;

  suits.forEach(suit => {
    ranks.forEach((rank, index) => {
      deck.push({
        id: `card-${idCounter++}`,
        suit,
        rank,
        value: index
      });
    });
  });

  // Shuffle
  for (let i = deck.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [deck[i], deck[j]] = [deck[j], deck[i]];
  }

  return deck;
};

export const AVATARS = {
  ME: "https://picsum.photos/id/64/100/100",
  RIGHT: "https://picsum.photos/id/65/100/100",
  TOP: "https://picsum.photos/id/66/100/100",
  LEFT: "https://picsum.photos/id/67/100/100"
};

export const VISUAL_ASSETS = {
  CARDS: [
    { id: 'card_default', name: 'Royal Back', type: 'image', value: '/assets/royal_card_back.png' },
    { id: 'card_classic_blue', name: 'Classic Blue', type: 'css', value: 'linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%)' },
    { id: 'card_classic_red', name: 'Classic Red', type: 'css', value: 'linear-gradient(135deg, #991b1b 0%, #ef4444 100%)' },
    { id: 'card_modern_black', name: 'Modern Black', type: 'css', value: 'linear-gradient(135deg, #000000 0%, #444444 100%)' },
  ],
  TABLES: [
    { id: 'table_default', name: 'Premium Wood', type: 'image', value: 'PREMIUM_ASSETS' }, // Special handling for our complex wood+felt
    { id: 'table_classic_green', name: 'Classic Green', type: 'css', value: '#1a472a' },
    { id: 'table_royal_blue', name: 'Royal Blue', type: 'css', value: '#1e3a8a' },
    { id: 'table_midnight', name: 'Midnight', type: 'css', value: '#0f172a' },
  ]
};

```

### FILE: frontend\src\index.css (SKIPPED - >10KB)
### FILE: frontend\src\setupTests.ts
```ts
import '@testing-library/jest-dom';

```

### FILE: frontend\src\types.ts
```ts
export enum Suit {
  Hearts = '‚ô•',
  Diamonds = '‚ô¶',
  Clubs = '‚ô£',
  Spades = '‚ô†'
}

export enum Rank {
  Seven = '7',
  Eight = '8',
  Nine = '9',
  Ten = '10',
  Jack = 'J',
  Queen = 'Q',
  King = 'K',
  Ace = 'A'
}

export interface CardModel {
  id: string;
  suit: Suit;
  rank: Rank;
  value: number; // Raw value for sorting
}

export enum GamePhase {
  Waiting = 'WAITING',
  Bidding = 'BIDDING',
  Doubling = 'DOUBLING',
  VariantSelection = 'VARIANT_SELECTION', // Open/Closed choice
  Playing = 'PLAYING',
  Finished = 'FINISHED', // Round End
  GameOver = 'GAMEOVER'
}

export enum PlayerPosition {
  Bottom = 'Bottom',
  Right = 'Right',
  Top = 'Top',
  Left = 'Left'
}

export interface Player {
  position: PlayerPosition;
  name: string;
  avatar: string; // URL or emoji
  hand: CardModel[];
  score: number; // Cards won or points
  isDealer: boolean;
  isActive: boolean; // Is it their turn?
  actionText?: string; // e.g. "Pass", "Sun" displayed briefly
  lastReasoning?: string; // AI Reasoning text
  index: number; // Player index (0-3)
  isBot?: boolean; // Added for AI identification

  // Director Configs
  strategy?: 'heuristic' | 'mcts' | 'neural' | 'hybrid';
  profile?: 'Aggressive' | 'Conservative' | 'Balanced';
}

export interface Bid {
  type: 'SUN' | 'HOKUM' | null;
  suit: Suit | null; // NEW: Explicitly store suit
  bidder: PlayerPosition | null;
  doubled: boolean;
}

export interface TableCardMetadata {
  akka?: boolean;
  [key: string]: unknown;
}

export interface GameSettings {
  turnDuration: number; // Seconds (e.g. 5, 10, 15)
  strictMode: boolean; // True = Auto-block illegal moves, False = Allow illegal + Disputes
  soundEnabled: boolean;
  gameSpeed: 'NORMAL' | 'FAST';
  isDebug?: boolean;
  fourColorMode?: boolean; // NEW: Accessibility
  highContrastMode?: boolean; // NEW: Accessibility
  cardLanguage?: 'EN' | 'AR'; // NEW: Arabic/English Indices
}

export interface DetailedScore {
  aklat: number;
  ardh: number;
  mashaari: number;
  abnat: number;
  result: number;
  projects: DeclaredProject[];
  
  // UI Helper Props (Optional)
  rawCardPoints?: number;
  projectPoints?: number;
  totalRaw?: number;
  gamePoints?: number;
}

export interface ScoreBreakdown {
  rawCardPoints: number;
  projectPoints: number;
  totalRaw: number;
  gamePoints: number;
  isKaboot: boolean;
  multiplierApplied: number;
}

export interface RoundResult {
  roundNumber?: number; // Added
  us: DetailedScore;
  them: DetailedScore;
  winner: 'us' | 'them' | 'tie' | 'NONE';
  bidder?: string;
  gameMode?: 'SUN' | 'HOKUM';
  doubling?: number;
  reason?: string;
}



export enum ProjectType {
  SIRA = 'SIRA',       // Sequence of 3
  FIFTY = 'FIFTY',     // Sequence of 4
  HUNDRED = 'HUNDRED', // Sequence of 5 or 4-of-a-kind (Tens, J, Q, K - sometimes A in Sun)
  FOUR_HUNDRED = 'FOUR_HUNDRED', // 4 Aces (Sun only)
  BALOOT = 'BALOOT'    // K + Q of Trump
}

export enum DoublingLevel {
  NORMAL = 1,
  DOUBLE = 2,
  TRIPLE = 3,
  QUADRUPLE = 4,
  GAHWA = 100 // Instant Win
}

export enum LeagueTier {
  BRONZE = 'Bronze',
  SILVER = 'Silver',
  GOLD = 'Gold',
  PLATINUM = 'Platinum',
  DIAMOND = 'Diamond',
  grandmaster = "Grandmaster"
}

export interface UserProfile {
  id: string;
  name: string;
  avatar?: string;
  leaguePoints: number;
  tier: LeagueTier;
  level: number;
  xp: number;
  xpToNextLevel: number;
  coins: number;
  firstName?: string;
  lastName?: string;
  email?: string;
  disableProfessor?: boolean;
}

export interface DeclaredProject {
  type: ProjectType;
  rank: Rank;
  suit: Suit;
  owner: PlayerPosition;
  score?: number; // Added score for round result display
}

export interface ProfessorIntervention {
  type: string;
  message: string;
  suggestion?: {
    action: string;
    cardIndex?: number;
    reasoning?: string;
  };
  confidence: number;
}

export interface QaydState {
  active: boolean;
  reporter: PlayerPosition | null; // Backend uses Position string
  reason: string | null;
  target_play: { card: CardModel; playedBy: PlayerPosition; metadata?: TableCardMetadata };
  status?: 'REVIEW' | 'RESOLVED';
  verdict?: string;
  loser_team?: 'us' | 'them';
  qayd_type?: string;     // Added for Kammelna display
  penalty_points?: number; // Added for detailed result
}

export interface GameState {
  gameId?: string; // Phase VII: For Remote Debugging & AI
  players: Player[];
  currentTurnIndex: number;
  phase: GamePhase;
  biddingPhase?: string; // e.g. "GABLAK_WINDOW"
  tableCards: { card: CardModel; playedBy: PlayerPosition; metadata?: TableCardMetadata }[];
  gameMode?: string;
  trumpSuit?: Suit;
  bid: Bid;
  teamScores: { us: number; them: number };
  matchScores: { us: number; them: number }; // For Championship (152)
  roundHistory: RoundResult[];

  // Scored Tricks History
  currentRoundTricks?: { cards: CardModel[] }[];

  floorCard: CardModel | null;
  deck: CardModel[];
  dealerIndex: number;
  biddingRound: number;
  declarations: { [key: string]: DeclaredProject[] };

  // Transition Flags
  isRoundTransitioning?: boolean;
  isTrickTransitioning?: boolean;
  isProjectRevealing?: boolean;

  doublingLevel: DoublingLevel;
  isLocked: boolean;
  settings: GameSettings;

  // Phase V: Sawa
  sawaState?: {
    active: boolean;
    claimer: PlayerPosition;
    responses: Record<string, 'ACCEPT' | 'REFUSE'>;
    status: 'PENDING' | 'ACCEPTED' | 'REFUSED' | 'NONE';
    challenge_active: boolean;
  } | null;
  sawaClaimed?: PlayerPosition;

  // Phase V: Sawa
  isFastForwarding?: boolean;

  // Phase VII: Qayd
  qaydPenalty?: { team: 'us' | 'them', round: number };
  lastTrick?: { cards: { card: CardModel; playedBy: PlayerPosition }[]; winner: PlayerPosition } | null;
  qaydState?: QaydState;

  // Akka
  akkaState?: { claimer: PlayerPosition; suits: string[]; timestamp: number } | null;

  // Debug/Dev
  fullMatchHistory?: any[];
  analytics?: {
    winProbability: { trick: number; us: number }[];
    blunders?: { [key: string]: number }; // Map "Bottom": count
  };
  metadata?: {
    source_game_id?: string;
    forked_at_round?: number;
    forked_at_trick?: number;
    original_final_scores?: { us: number; them: number };
    [key: string]: any;
  };
}
```

### FILE: frontend\src\vite-env.d.ts
```ts
/// <reference types="vite/client" />

```

### FILE: frontend\src\ai\IntelligentBot.ts
```ts
/*
import * as ort from 'onnxruntime-web';
import { devLogger } from '../utils/devLogger';

export class IntelligentBot {
   // ... (Disabled for Debugging WASM Crash)
   constructor() {}
   async loadModel() { console.log("Bot AI Disabled"); }
   async predict() { return -1; }
}
*/

export class IntelligentBot {
    public session: any = null;
    constructor() { }
    async loadModel() { console.log("Bot AI Disabled (WASM Fix)"); }
    async predict(gameState: any, myIndex: number) { return -1; }
}

```

### FILE: frontend\src\components\ActionBar.tsx (SKIPPED - >10KB)
### FILE: frontend\src\components\AIAnalysisPanel.tsx (SKIPPED - >10KB)
### FILE: frontend\src\components\AIStudio.tsx
```tsx
import React, { useState, useEffect } from 'react';
import { ArrowLeft, Layers, List, Brain, GraduationCap, Wand2 } from 'lucide-react';
import { getTrainingData } from '../services/trainingService';
import { GamePhase } from '../types';

// Sub-Components
import ReportsListView from './ai-studio/ReportsListView';
import BuilderView from './ai-studio/BuilderView';
import BiddingLabView from './ai-studio/BiddingLabView';
import TrainingView from './ai-studio/TrainingView';
import BrainMemoryView from './ai-studio/BrainMemoryView';

interface AIStudioProps {
    onBack: () => void;
}

const AIStudio: React.FC<AIStudioProps> = ({ onBack }) => {
    const [viewMode, setViewMode] = useState<'LIST' | 'BUILDER' | 'TRAINING' | 'BIDDING' | 'BRAIN'>('LIST');

    // --- LIST MODE STATE ---
    const [examples, setExamples] = useState<any[]>([]);
    const [loading, setLoading] = useState(true);

    // --- SHARED BUILDER/TRAINING STATE ---
    // Lifted up so switching tabs doesn't destroy work in progress immediately,
    // though TrainingView mostly manages its own puzzle state.
    const [scenarioState, setScenarioState] = useState<any>({
        players: [
            { name: 'Me', position: 'Bottom', hand: [] },
            { name: 'Right', position: 'Right', hand: [] },
            { name: 'Partner', position: 'Top', hand: [] },
            { name: 'Left', position: 'Left', hand: [] },
        ],
        phase: GamePhase.Bidding,
        dealerIndex: 0,
        currentTurn: 0,
        bid: { type: 'SUN', suit: null },
        floorCard: null,
        playedCards: {},
        playerBids: {}
    });

    const [correctAction, setCorrectAction] = useState('');
    const [reasoning, setReasoning] = useState('');
    const [currentImage, setCurrentImage] = useState<string | null>(null);

    useEffect(() => {
        if (viewMode === 'LIST') loadData();
    }, [viewMode]);

    const loadData = async () => {
        setLoading(true);
        const res = await getTrainingData();
        if (res.data) {
            setExamples(res.data);
        }
        setLoading(false);
    };

    const handleDuplicate = (example: any) => {
        try {
            const loadedState = JSON.parse(example.gameState);
            setScenarioState(loadedState);
            setCorrectAction(example.correctMove || '');
            setReasoning(example.reason || '');
            setViewMode('BUILDER');
        } catch (e) {
            console.error("Failed to load scenario", e);
            alert("Error loading scenario data");
        }
    };


    return (
        <div className="flex flex-col h-full w-full bg-slate-900 text-white font-tajawal p-6 overflow-hidden">

            {/* Header */}
            <div className="flex items-center justify-between mb-6 shrink-0">
                <div className="flex items-center gap-4">
                    <button onClick={onBack} className="p-2 bg-slate-800 rounded-full hover:bg-slate-700">
                        <ArrowLeft size={24} />
                    </button>
                    <div>
                        <h1 className="text-3xl font-bold bg-gradient-to-r from-yellow-500 to-amber-600 bg-clip-text text-transparent">
                            ÿßÿ≥ÿ™ŸàÿØŸäŸà ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä
                        </h1>
                        <p className="text-slate-400">ÿ™ÿØÿ±Ÿäÿ® Ÿàÿ™ÿµÿ≠Ÿäÿ≠ ŸÇÿ±ÿßÿ±ÿßÿ™ ÿßŸÑÿ®Ÿàÿ™</p>
                    </div>
                </div>

                {/* Tabs */}
                <div className="flex bg-slate-800 p-1 rounded-lg gap-1 overflow-x-auto">
                    <button onClick={() => setViewMode('LIST')} className={`flex items-center gap-2 px-4 py-2 rounded-md transition-all whitespace-nowrap ${viewMode === 'LIST' ? 'bg-slate-700 text-white shadow' : 'text-slate-400 hover:text-white'}`}>
                        <List size={16} /> Reports
                    </button>
                    <button onClick={() => setViewMode('BUILDER')} className={`flex items-center gap-2 px-4 py-2 rounded-md transition-all whitespace-nowrap ${viewMode === 'BUILDER' ? 'bg-yellow-600 text-white shadow' : 'text-slate-400 hover:text-white'}`}>
                        <Layers size={16} /> Builder
                    </button>
                    <button onClick={() => setViewMode('TRAINING')} className={`flex items-center gap-2 px-4 py-2 rounded-md transition-all whitespace-nowrap ${viewMode === 'TRAINING' ? 'bg-green-600 text-white shadow' : 'text-slate-400 hover:text-white'}`}>
                        <GraduationCap size={16} /> Training
                    </button>
                    <button onClick={() => setViewMode('BIDDING')} className={`flex items-center gap-2 px-4 py-2 rounded-md transition-all whitespace-nowrap ${viewMode === 'BIDDING' ? 'bg-purple-600 text-white shadow' : 'text-slate-400 hover:text-white'}`}>
                        <Wand2 size={16} /> Bidding üßê
                    </button>
                    <button onClick={() => setViewMode('BRAIN')} className={`flex items-center gap-2 px-4 py-2 rounded-md transition-all whitespace-nowrap ${viewMode === 'BRAIN' ? 'bg-indigo-600 text-white shadow ring-1 ring-indigo-400' : 'text-slate-400 hover:text-white'}`}>
                        <Brain size={16} /> Brain Memory
                    </button>
                </div>
            </div>

            {/* CONTENT AREA */}
            {viewMode === 'LIST' && (
                <ReportsListView
                    examples={examples}
                    loading={loading}
                    onLoadData={loadData}
                    onDuplicate={handleDuplicate}
                />
            )}

            {viewMode === 'BUILDER' && (
                <BuilderView
                    scenarioState={scenarioState}
                    setScenarioState={setScenarioState}
                    correctAction={correctAction}
                    setCorrectAction={setCorrectAction}
                    reasoning={reasoning}
                    setReasoning={setReasoning}
                    currentImage={currentImage}
                    setCurrentImage={setCurrentImage}
                    onSaveSuccess={() => setViewMode('LIST')}
                />
            )}

            {viewMode === 'TRAINING' && (
                <TrainingView
                    scenarioState={scenarioState}
                    setScenarioState={setScenarioState}
                />
            )}

            {viewMode === 'BIDDING' && (
                <BiddingLabView />
            )}

            {viewMode === 'BRAIN' && (
                <BrainMemoryView
                    onBack={() => setViewMode('LIST')}
                />
            )}

        </div>
    );
};

export default AIStudio;

```

### FILE: frontend\src\components\Card.tsx
```tsx
import React, { useMemo } from 'react';
import { CardModel, Suit, Rank } from '../types';
import { Spade, Heart, Club, Diamond } from './SuitIcons';
import { motion } from 'framer-motion';

interface CardProps {
  card: CardModel;
  isHidden?: boolean;
  isSmall?: boolean;
  onClick?: () => void;
  className?: string;
  selected?: boolean;
  disabled?: boolean;
  skin?: string;
  isFourColorMode?: boolean;
  isHighContrast?: boolean;
  isPlayable?: boolean;
  animationDelay?: number;
  cardLanguage?: 'EN' | 'AR';
  isAkka?: boolean;
  isAccessibilityMode?: boolean;
}

// Typography: Slab Serif for standard English indices
const getRankSymbolEN = (rank: Rank): string => {
  switch (rank) {
    case Rank.Ace: return 'A';
    case Rank.King: return 'K';
    case Rank.Queen: return 'Q';
    case Rank.Jack: return 'J';
    default: return rank;
  }
};

// Colors: Darker Red (#D32F2F) for Hearts/Diamonds to reduce eye strain
const getSuitColor = (suit: Suit, isFourColorMode: boolean = false, isHighContrast: boolean = false, isAccessibilityMode: boolean = false): string => {
  if (isAccessibilityMode) {
    switch (suit) {
      case Suit.Diamonds: return '#3ABEF9'; // Light Blue
      case Suit.Spades: return '#55AD9B'; // Green
      case Suit.Hearts: return '#dc2626'; // Standard Red
      case Suit.Clubs: return '#111111'; // Standard Black
    }
  }

  if (isHighContrast) return (suit === Suit.Hearts || suit === Suit.Diamonds) ? '#ff0000' : '#000000';
  if (isFourColorMode) {
    switch (suit) {
      case Suit.Spades: return '#1a1a1a';
      case Suit.Hearts: return '#dc2626';
      case Suit.Clubs: return '#166534';
      case Suit.Diamonds: return '#2563eb';
    }
  }
  // Standard Premium Palette: Dark Red vs Black
  return (suit === Suit.Hearts || suit === Suit.Diamonds) ? '#D32F2F' : '#111111';
};

// Arabic Indices
const getRankSymbolAR = (rank: Rank): string => {
  switch (rank) {
    case Rank.Ace: return 'ÿ£';
    case Rank.King: return 'ŸÉ';
    case Rank.Queen: return 'ŸÇ';
    case Rank.Jack: return 'ÿ¨';
    case Rank.Ten: return '€±€∞';
    case Rank.Nine: return '€π';
    case Rank.Eight: return '€∏';
    case Rank.Seven: return '€∑';
    default: return rank;
  }
};

const Card: React.FC<CardProps> = ({
  card,
  isHidden = false,
  isSmall = false,
  onClick,
  className = '',
  selected = false,
  disabled = false,
  isFourColorMode = false,
  isHighContrast = false,
  isPlayable = true,
  animationDelay = 0,

  cardLanguage = 'EN', // Default
  isAkka = false,
  isAccessibilityMode = false
}) => {
  if (!card) return null;

  const isCourtCard = [Rank.King, Rank.Queen, Rank.Jack].includes(card.rank);
  const suitColor = getSuitColor(card.suit, isFourColorMode, isHighContrast, isAccessibilityMode);
  const rankSymbol = cardLanguage === 'AR' ? getRankSymbolAR(card.rank) : getRankSymbolEN(card.rank);
  const fontFamily = cardLanguage === 'AR' ? '"Tajawal", "Segoe UI", sans-serif' : '"Roboto Slab", serif';

  const SuitIcon = ({ size, className }: { size: number, className?: string }) => {
    switch (card.suit) {
      case Suit.Spades: return <Spade size={size} color={suitColor} className={className} />;
      case Suit.Hearts: return <Heart size={size} color={suitColor} className={className} />;
      case Suit.Clubs: return <Club size={size} color={suitColor} className={className} />;
      case Suit.Diamonds: return <Diamond size={size} color={suitColor} className={className} />;
    }
  };

  const containerClasses = `
    relative 
    w-full h-full
    aspect-[5/7]
    flex flex-col items-center justify-center 
    rounded-[10%] 
    select-none 
    bg-white
    ${disabled ? 'grayscale opacity-60 pointer-events-none' : ''}
    ${!disabled && isPlayable ? 'cursor-pointer' : ''}
    ${!isPlayable && !disabled ? 'opacity-90 brightness-95' : ''}
    ${className}
  `;

  // Motion Variants
  const variants = {
    hidden: { opacity: 0, y: 50, scale: 0.8 },
    visible: {
      opacity: 1,
      y: selected ? -30 : 0,
      scale: 1,
      transition: { delay: animationDelay / 1000, type: "spring", stiffness: 300, damping: 20 }
    },
    hover: (!disabled && isPlayable) ? {
      y: -15,
      scale: 1.05,
      boxShadow: "0 20px 25px -5px rgba(0, 0, 0, 0.4), 0 10px 10px -5px rgba(0, 0, 0, 0.2)"
    } : {},
    tap: (!disabled && isPlayable) ? { scale: 0.95 } : {}
  };

  if (isHidden) {
    return (
      <motion.div
        className={`${containerClasses} overflow-hidden`}
        onClick={onClick}
        initial={{ opacity: 0, scale: 0.8 }}
        animate={{ opacity: 1, scale: 1 }}
        transition={{ delay: animationDelay / 1000 }}
        style={{
          boxShadow: '0 2px 5px rgba(0,0,0,0.2)',
          border: '1px solid #ddd',
          backgroundImage: 'linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%)', // Simple Back
        }}
      >
        <div className="w-full h-full border-4 border-white/20 rounded-[8%] m-1"></div>
      </motion.div>
    );
  }

  return (
    <motion.div
      className={containerClasses}
      onClick={onClick}
      variants={variants}
      initial="hidden"
      animate="visible"
      whileHover="hover"
      whileTap="tap"
      style={{
        boxShadow: selected
          ? '0 0 0 3px #d4af37, 0 10px 20px rgba(0,0,0,0.3)'
          : '0 2px 6px rgba(0,0,0,0.15)',
        border: '1px solid #e5e5e5',
        zIndex: selected ? 50 : 'auto'
      }}
    >
      {/* Akka Badge */}
      {isAkka && (
        <motion.div
          initial={{ scale: 0 }}
          animate={{ scale: 1 }}
          className="absolute -top-3 -right-3 z-50 bg-rose-600 text-white text-[10px] font-bold px-2 py-0.5 rounded-full shadow-md border-2 border-white"
        >
          ÿ£ŸÉÿ©
        </motion.div>
      )}

      {/* --- Top-Left Index (Primary) --- */}
      <div className="absolute top-[4%] left-[6%] flex flex-col items-center leading-none">
        <span style={{ color: suitColor, fontFamily }} className="font-bold text-[clamp(1rem,4vw,1.8rem)] tracking-tight">
          {rankSymbol}
        </span>
        <div className="mt-[-2px]">
          <SuitIcon size={isSmall ? 12 : 16} />
        </div>
      </div>

      {/* --- Bottom-Right Index (Rotated) --- */}
      <div className="absolute bottom-[4%] right-[6%] flex flex-col items-center leading-none rotate-180">
        <span style={{ color: suitColor, fontFamily }} className="font-bold text-[clamp(1rem,4vw,1.8rem)] tracking-tight">
          {rankSymbol}
        </span>
        <div className="mt-[-2px]">
          <SuitIcon size={isSmall ? 12 : 16} />
        </div>
      </div>

      {/* --- Center Art (Faded for Court Cards) --- */}
      <div className={`flex-1 flex items-center justify-center w-full h-full ${isCourtCard ? 'opacity-80' : ''}`}>
        {isCourtCard ? (
          <div className="relative flex items-center justify-center w-full h-full overflow-hidden">
            {/* Abstract Court Card Graphic or Big Letter */}
            <span style={{ color: suitColor }} className="text-[clamp(3rem,8vw,5rem)] font-serif font-black opacity-15 absolute">
              {rankSymbol}
            </span>
            <SuitIcon size={48} className="opacity-90" />
          </div>
        ) : (
          <div className="transform scale-[1.8]">
            <SuitIcon size={28} />
          </div>
        )}
      </div>
    </motion.div>
  );
};

export default Card;
```

### FILE: frontend\src\components\CardPicker.tsx
```tsx
import React from 'react';


const SUIT_ICONS: Record<string, string> = { 'S': '‚ô†', 'H': '‚ô•', 'D': '‚ô¶', 'C': '‚ô£' };
const RANK_ORDER = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A'];

interface CardPickerProps {
  onSelect: (rank: string, suit: string) => void;
  takenCards?: string[]; // Cards taken by OTHER players (Disabled)
  myCards?: string[];    // Cards in MY hand (Highlighted)
  multiSelect?: boolean;
}

const CardPicker: React.FC<CardPickerProps> = ({ onSelect, takenCards = [], myCards = [] }) => {

  const isTaken = (rank: string, suit: string) => takenCards.includes(`${rank}${suit}`);
  const isMine = (rank: string, suit: string) => myCards.includes(`${rank}${suit}`);

  return (
    <div className="bg-slate-800 p-4 rounded-xl border border-slate-600 shadow-2xl max-w-md">
      <h3 className="text-white font-bold mb-4 text-center">Select Card</h3>
      <div className="grid grid-cols-4 gap-2">
        {['S', 'H', 'D', 'C'].map(suit => (
          <div key={suit} className="flex flex-col gap-2">
            {/* Header Icon */}
            <div className={`text-center font-bold text-xl ${suit === 'H' || suit === 'D' ? 'text-red-500' : 'text-white'}`}>
              {SUIT_ICONS[suit]}
            </div>

            {RANK_ORDER.map(rank => {
              const cardId = `${rank}${suit}`;
              const taken = isTaken(rank, suit);
              const mine = isMine(rank, suit);

              return (
                <button
                  key={cardId}
                  onClick={() => onSelect(rank, suit)}
                  disabled={taken}
                  className={`
                            relative h-12 rounded flex items-center justify-center font-bold text-lg
                            transition-all border
                            ${taken
                      ? 'bg-slate-900 text-slate-600 border-slate-800 cursor-not-allowed'
                      : mine
                        ? 'bg-green-600 text-white border-green-400 shadow-md ring-2 ring-green-300'
                        : 'bg-white hover:bg-yellow-100 border-slate-300 shadow-sm hover:-translate-y-1 text-black'
                    }
                            ${!taken && !mine && (suit === 'H' || suit === 'D') ? 'text-red-600' : ''}
                        `}
                >
                  {rank}
                  <span className="text-xs absolute top-0.5 right-1 opacity-50">{SUIT_ICONS[suit]}</span>
                </button>
              );
            })}
          </div>
        ))}
      </div>
    </div>
  );
};

export default CardPicker;

```

### FILE: frontend\src\components\CardReal.tsx
```tsx
import React from 'react';
import { CardModel, Suit, Rank } from '../types';
import cardsSprite from '../assets/cards.png';
import cardBack from '../assets/royal_card_back.png';

interface CardRealProps {
    card: CardModel;
    isHidden?: boolean;
    className?: string;
    selected?: boolean;
    onClick?: () => void;
    isPlayable?: boolean;
    // Legacy props to ignore
    isFourColorMode?: boolean;
    isHighContrast?: boolean;
    cardLanguage?: string;
    isAccessibilityMode?: boolean;
    skin?: string;
    isAkka?: boolean; // We might want to overlay this
}

const CardReal: React.FC<CardRealProps> = ({
    card,
    isHidden = false,
    className = '',
    selected = false,
    onClick,
    isPlayable = true,
    isAkka = false,
}) => {
    if (!card) return null;

    // --- SPRITE SHEET MAPPING ---
    // Dimensions determined: 2600x1120
    // Cols: 13
    // Rows: 4

    const getRankIndex = (rank: Rank): number => {
        // Standard Deck Order: A, 2, 3... 10, J, Q, K
        // Note: Some sprites start with 2 and end with Ace.
        // Let's assume A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K
        const ranks = [Rank.Ace, '2', '3', '4', '5', '6', '7', Rank.Eight, Rank.Nine, Rank.Ten, Rank.Jack, Rank.Queen, Rank.King];
        return ranks.indexOf(rank);
    };

    const getSuitIndex = (suit: Suit): number => {
        // Common Sprite Order 1: Spades, Hearts, Diamonds, Clubs
        // Common Sprite Order 2: Spades, Hearts, Clubs, Diamonds
        // We will default to: Spades, Hearts, Clubs, Diamonds
        // If user says "Wrong suit", we swap lines here.
        switch (suit) {
            case Suit.Spades: return 0; // Row 0
            case Suit.Hearts: return 1; // Row 1
            case Suit.Clubs: return 2;  // Row 2
            case Suit.Diamonds: return 3; // Row 3
        }
        return 0;
    };

    const rankIdx = getRankIndex(card.rank); // 0..12
    const suitIdx = getSuitIndex(card.suit); // 0..3

    // CSS Logic for Sprites
    // x% = (index / (total - 1)) * 100
    const xPos = (rankIdx / 12) * 100;
    const yPos = (suitIdx / 3) * 100;

    const playStyle = (!isHidden && isPlayable) ? 'cursor-pointer hover:-translate-y-2 hover:shadow-2xl' : '';
    const disabledStyle = (!isHidden && !isPlayable) ? 'opacity-90 brightness-75' : '';

    return (
        <div
            className={`
        relative aspect-[5/7] rounded-[5%] shadow-md transition-all duration-300
        ${selected ? 'ring-4 ring-yellow-400 -translate-y-6 z-50 shadow-[0_0_30px_rgba(255,215,0,0.6)]' : ''}
        ${playStyle}
        ${disabledStyle}
        ${className}
      `}
            onClick={onClick}
            style={{
                backgroundImage: isHidden ? `url(${cardBack})` : `url(${cardsSprite})`,
                backgroundSize: isHidden ? 'cover' : '1300% 400%',
                backgroundPosition: isHidden ? 'center' : `${xPos}% ${yPos}%`,
                backgroundColor: 'white',
                imageRendering: 'high-quality'
            }}
        >
            {/* Akka Badge Overlay */}
            {isAkka && !isHidden && (
                <div className="absolute -top-2 -right-2 bg-gradient-to-r from-red-600 to-rose-600 text-white text-[10px] sm:text-xs font-black px-2 py-0.5 rounded-full border border-white shadow-lg z-20 animate-bounce">
                    ÿ£ŸÉÿ©
                </div>
            )}
        </div>
    );
};

export default CardReal;

```

### FILE: frontend\src\components\CardV2.tsx
```tsx

import React from 'react';
import { CardModel, Suit, Rank } from '../types';
import { Spade, Heart, Club, Diamond } from './SuitIcons';

interface CardV2Props {
    card: CardModel;
    isHidden?: boolean;
    isSmall?: boolean;
    onClick?: () => void;
    className?: string;
    selected?: boolean;
    disabled?: boolean;
    isPlayable?: boolean;
    animationDelay?: number;
}

interface SuitIconProps {
    suit: Suit;
    color: string;
    size: number;
    className?: string;
}

const SuitIconRender: React.FC<SuitIconProps> = ({ suit, color, size, className }) => {
    switch (suit) {
        case Suit.Spades: return <Spade size={size} color={color} className={className} />;
        case Suit.Hearts: return <Heart size={size} color={color} className={className} />;
        case Suit.Clubs: return <Club size={size} color={color} className={className} />;
        case Suit.Diamonds: return <Diamond size={size} color={color} className={className} />;
        default: return null;
    }
};

const getRankSymbolAR = (rank: Rank): string => {
    switch (rank) {
        case Rank.Ace: return 'ÿ£';
        case Rank.King: return 'ŸÉ';
        case Rank.Queen: return 'ŸÇ';
        case Rank.Jack: return 'ÿ¨';
        case Rank.Ten: return '€±€∞';
        case Rank.Nine: return '€π';
        case Rank.Eight: return '€∏';
        case Rank.Seven: return '€∑';
        default: return rank;
    }
};

const getSuitColor = (suit: Suit): string => {
    // Classic Style: Rich Red vs Jet Black
    return (suit === Suit.Hearts || suit === Suit.Diamonds) ? '#D32F2F' : '#111111';
};

const CardV2: React.FC<CardV2Props> = ({
    card,
    isHidden = false,
    isSmall = false,
    onClick,
    className = '',
    selected = false,
    disabled = false,
    isPlayable = true,
    animationDelay = 0,
}) => {
    if (!card) return null;

    const suitColor = getSuitColor(card.suit);
    const rankSymbol = getRankSymbolAR(card.rank); // Default to Arabic for Classic feel
    const isCourtCard = [Rank.King, Rank.Queen, Rank.Jack].includes(card.rank);

    // Premium texture background (CSS only)
    const textureStyle = {
        backgroundImage: `repeating-linear-gradient(45deg, rgba(0,0,0,0.01) 0px, rgba(0,0,0,0.01) 2px, transparent 2px, transparent 4px)`
    };

    // Back Pattern (Arabic Geometric)
    const backStyle = {
        backgroundImage: `
      radial-gradient(circle at center, #1e3a8a 0%, #172554 100%),
      repeating-radial-gradient(circle at 50% 50%, rgba(255,255,255,0.1) 0, rgba(255,255,255,0.1) 2px, transparent 4px, transparent 8px)
    `
    };

    const containerClasses = `
    relative 
    w-full h-full
    aspect-[5/7]
    flex flex-col items-center justify-center 
    rounded-lg
    select-none 
    transition-transform duration-300
    bg-stone-50
    border-2
    shadow-lg
    ${selected ? 'z-50 ring-4 ring-yellow-400 ring-offset-2' : 'border-stone-300'}
    ${disabled ? 'grayscale opacity-60 pointer-events-none' : ''}
    ${!disabled && isPlayable ? 'cursor-pointer hover:-translate-y-4 hover:shadow-xl' : ''}
    ${!isPlayable && !disabled ? 'opacity-90 brightness-95' : ''}
    ${className}
  `;

    if (isHidden) {
        return (
            <div
                className={`${containerClasses} overflow-hidden`}
                onClick={onClick}
                style={{
                    ...backStyle,
                    boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
                    animationDelay: `${animationDelay}ms`,
                    border: '2px solid #fff',
                }}
            >
                {/* Inner Border for detail */}
                <div className="absolute inset-2 border border-white/30 rounded-md opacity-50"></div>
                <div className="w-12 h-12 bg-white/10 rounded-full flex items-center justify-center backdrop-blur-sm">
                    {/* Logo or Center Icon placeholder */}
                    <div className="w-8 h-8 border-2 border-white/40 rotate-45"></div>
                </div>
            </div>
        );
    }

    return (
        <div
            className={containerClasses}
            onClick={onClick}
            style={{
                ...textureStyle,
                animationDelay: `${animationDelay}ms`,
                transform: selected ? 'translateY(-30px)' : undefined
            }}
        >
            {/* Gold/Bronze Border Effect inside */}
            <div className="absolute inset-1 border border-yellow-600/20 rounded-[inherit] pointer-events-none"></div>

            {/* Top Left Index */}
            <div className="absolute top-1 left-2 flex flex-col items-center leading-none">
                <span style={{ color: suitColor }} className="font-bold text-[clamp(1.2rem,4vw,2rem)] font-sans">
                    {rankSymbol}
                </span>
                <SuitIconRender suit={card.suit} color={suitColor} size={isSmall ? 10 : 14} />
            </div>

            {/* Bottom Right Index (Rotated) */}
            <div className="absolute bottom-1 right-2 flex flex-col items-center leading-none rotate-180">
                <span style={{ color: suitColor }} className="font-bold text-[clamp(1.2rem,4vw,2rem)] font-sans">
                    {rankSymbol}
                </span>
                <SuitIconRender suit={card.suit} color={suitColor} size={isSmall ? 10 : 14} />
            </div>

            {/* Center Content */}
            <div className={`flex-1 flex items-center justify-center w-full h-full`}>
                {isCourtCard ? (
                    <div className="relative w-full h-full flex items-center justify-center overflow-hidden">
                        {/* Watermark Big Letter */}
                        <span style={{ color: suitColor }} className="absolute text-[6rem] opacity-5 font-serif font-black">
                            {card.rank === Rank.Ten ? '10' : card.rank}
                        </span>

                        {/* Court Icon - Placeholder for now, can use Crown SVG later */}
                        <div className="border-4 double p-4 rounded-full bg-white/50 backdrop-blur-[2px]" style={{ borderColor: suitColor }}>
                            <SuitIconRender suit={card.suit} color={suitColor} size={42} />
                        </div>

                        {/* Crown Hint */}
                        <div className="absolute top-[25%] text-yellow-500 opacity-80">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M5 16L3 5L8.5 10L12 4L15.5 10L21 5L19 16H5M19 19C19 19.6 18.6 20 18 20H6C5.4 20 5 19.6 5 19V18H19V19Z" />
                            </svg>
                        </div>
                    </div>
                ) : (
                    <div className="transform scale-[1.5]">
                        {/* Simple Pips for Numbers */}
                        <div className="grid grid-cols-2 gap-1 p-2 border-2 rounded-lg opacity-80" style={{ borderColor: suitColor }}>
                            {Array.from({ length: 4 }).map((_, i) => (
                                <SuitIconRender key={i} suit={card.suit} color={suitColor} size={12} />
                            ))}
                        </div>
                    </div>
                )}
            </div>
        </div>
    );
};

export default CardV2;

```

### FILE: frontend\src\components\CardVector.tsx
```tsx
import React, { useMemo } from 'react';
import { CardModel, Suit, Rank } from '../types';
import { VISUAL_ASSETS } from '../constants';
import { Spade, Heart, Club, Diamond } from './SuitIcons';

interface CardVectorProps {
    card: CardModel;
    isHidden?: boolean;
    className?: string;
    selected?: boolean;
    onClick?: () => void;
    isPlayable?: boolean;
    isAkka?: boolean;
    skin?: string;
}

const CardVector: React.FC<CardVectorProps> = ({
    card,
    isHidden = false,
    className = '',
    selected = false,
    onClick,
    isPlayable = true,
    isAkka = false,
    skin = 'card_default'
}) => {
    if (!card) return null;

    const isRed = card.suit === Suit.Hearts || card.suit === Suit.Diamonds;
    const color = isRed ? '#d32f2f' : '#111';

    // --- Suit Icon Component ---
    const SuitIcon = ({ size, className, rotate }: { size: number, className?: string, rotate?: boolean }) => {
        const props = { size, color, className: `${className} ${rotate ? 'rotate-180' : ''}` };
        switch (card.suit) {
            case Suit.Spades: return <Spade {...props} />;
            case Suit.Hearts: return <Heart {...props} />;
            case Suit.Clubs: return <Club {...props} />;
            case Suit.Diamonds: return <Diamond {...props} />;
        }
    };

    // --- Pip Layout Logic ---
    const getPips = () => {
        // 100% width/height of the PILLARED area
        const pips = [];
        const r = card.rank;

        // Standard Pip Positions (percentages)
        // Cols: 30%, 70% | Row Center: 50%
        // Rows: 20, 35, 50, 65, 80

        // Column Definitions
        const left = '30%';
        const right = '70%';
        const mid = '50%';

        // Row Definitions
        const top = '20%';
        const topMid = '35%'; // for 7,8
        const center = '50%';
        const botMid = '65%'; // for 8
        const bot = '80%';

        interface StandardPipProps {
            top: string;
            left: string;
            invert?: boolean;
        }

        const StandardPip: React.FC<StandardPipProps> = ({ top, left, invert }) => (
            <div className={`absolute -translate-x-1/2 -translate-y-1/2 ${invert ? 'rotate-180' : ''}`} style={{ top, left }}>
                <SuitIcon size={20} />
            </div>
        );

        // Logic
        if (['2', '3'].includes(r as string)) {
            pips.push(<StandardPip top={top} left={mid} key="t" />);
            pips.push(<StandardPip top={bot} left={mid} key="b" invert />);
            if (r === '3') pips.push(<StandardPip top={center} left={mid} key="c" />);
        }
        else if (['4', '5', '6', '7', '8', '9', '10'].includes(r as string) || r === Rank.Ten) {
            // Corners
            pips.push(<StandardPip top={top} left={left} key="tl" />);
            pips.push(<StandardPip top={top} left={right} key="tr" />);
            pips.push(<StandardPip top={bot} left={left} key="bl" invert />);
            pips.push(<StandardPip top={bot} left={right} key="br" invert />);

            if (['6', '7', '8', '9', '10', Rank.Ten].includes(r as string)) {
                // Mids
                pips.push(<StandardPip top={center} left={left} key="ml" />);
                pips.push(<StandardPip top={center} left={right} key="mr" />);
            }

            // Center Column
            if (['5', '9'].includes(r as string)) {
                pips.push(<StandardPip top={center} left={mid} key="c" />);
            }
            if (['7', '8', '10', Rank.Ten].includes(r as string)) {
                pips.push(<StandardPip top={topMid} left={mid} key="tm" />);
            }
            if (['8', '10', Rank.Ten].includes(r as string)) {
                pips.push(<StandardPip top={botMid} left={mid} key="bm" invert />);
            }
        }

        return pips;
    };

    const isFace = ['J', 'Q', 'K'].includes(card.rank as string) || [Rank.Jack, Rank.Queen, Rank.King].includes(card.rank);
    const isAce = card.rank === Rank.Ace || card.rank === 'A';

    // Rank Text
    const rankText = card.rank === Rank.Ten ? '10' :
        card.rank === Rank.Ace ? 'A' :
            card.rank === Rank.King ? 'K' :
                card.rank === Rank.Queen ? 'Q' :
                    card.rank === Rank.Jack ? 'J' : card.rank;

    const playStyle = (!isHidden && isPlayable) ? 'cursor-pointer hover:-translate-y-2 hover:shadow-2xl' : '';

    return (
        <div
            role={onClick ? "button" : undefined}
            tabIndex={onClick ? 0 : undefined}
            aria-label={onClick && card ? `${card.rank} of ${card.suit}` : undefined}
            className={`
        relative aspect-[2.5/3.5] bg-white rounded-lg border border-gray-300 shadow-md select-none transition-transform duration-300
        font-serif overflow-hidden
        ${selected ? 'ring-4 ring-yellow-400 -translate-y-6 z-50' : ''}
        ${playStyle}
        ${className}
      `}
            onClick={onClick}
            onKeyDown={(e) => {
                if (onClick && (e.key === 'Enter' || e.key === ' ')) {
                    onClick();
                }
            }}
            style={{
                boxShadow: '2px 2px 5px rgba(0,0,0,0.1)'
            }}
        >
            {isHidden ? (
                <div
                    className="w-full h-full flex items-center justify-center border-4 border-white bg-cover bg-center"
                    style={{
                        backgroundImage: skin === 'card_default' ? `url('/assets/royal_card_back.png')` : 'none',
                        background: skin !== 'card_default' ? (VISUAL_ASSETS.CARDS.find(c => c.id === skin)?.value || '#1e3a8a') : undefined
                    }}
                ></div>
            ) : (
                <>
                    {/* Top Index */}
                    <div className="absolute top-1 left-1 flex flex-col items-center leading-none">
                        <span className="font-bold text-xl tracking-tighter" style={{ color }}>{rankText}</span>
                        <SuitIcon size={14} />
                    </div>

                    {/* Bottom Index */}
                    <div className="absolute bottom-1 right-1 flex flex-col items-center leading-none rotate-180">
                        <span className="font-bold text-xl tracking-tighter" style={{ color }}>{rankText}</span>
                        <SuitIcon size={14} />
                    </div>

                    {/* Center Content */}
                    <div className="absolute inset-[15%] flex items-center justify-center">
                        {isAce ? (
                            <SuitIcon size={64} />
                        ) : isFace ? (
                            <div className="w-full h-full flex items-center justify-center relative opacity-80">
                                {/* Improved Court Placeholder: No Box */}
                                <div className="absolute inset-0 flex items-center justify-center opacity-10">
                                    <span className="text-6xl font-black" style={{ color }}>{rankText}</span>
                                </div>
                                <SuitIcon size={40} />
                            </div>
                        ) : (
                            <div className="relative w-full h-full pointer-events-none">
                                {getPips()}
                            </div>
                        )}
                    </div>
                </>
            )}
        </div>
    );
};

export default CardVector;

```

### FILE: frontend\src\components\DevLogSidebar.tsx
```tsx

import React, { useEffect, useState, useRef } from 'react';
import { devLogger, LogEntry } from '../utils/devLogger';

export const DevLogSidebar: React.FC = () => {
    const [isOpen, setIsOpen] = useState(false); // Default closed
    const [logs, setLogs] = useState<LogEntry[]>([]);
    const endRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        // Load initial history
        setLogs(devLogger.getHistory());

        // Subscribe to new logs
        const unsubscribe = devLogger.subscribe((log) => {
            setLogs(prev => [...prev, log]);
        });

        return () => unsubscribe();
    }, []);

    useEffect(() => {
        // Auto scroll
        if (isOpen && endRef.current) {
            endRef.current.scrollIntoView({ behavior: 'smooth' });
        }
    }, [logs, isOpen]);

    const toggle = () => setIsOpen(!isOpen);
    const clear = () => {
        devLogger.clear();
        setLogs([]);
    };

    if (!isOpen) {
        return (
            <div style={{
                position: 'fixed',
                right: 0,
                top: '50%',
                transform: 'translateY(-50%)',
                zIndex: 9999,
            }}>
                <button
                    onClick={toggle}
                    style={{
                        writingMode: 'vertical-rl',
                        padding: '10px 5px',
                        backgroundColor: '#333',
                        color: '#0f0',
                        border: '1px solid #0f0',
                        borderRight: 'none',
                        cursor: 'pointer',
                        fontFamily: 'monospace',
                        fontWeight: 'bold',
                        borderTopLeftRadius: '5px',
                        borderBottomLeftRadius: '5px'
                    }}
                >
                    DEV LOGS
                </button>
            </div>
        );
    }

    return (
        <div style={{
            position: 'fixed',
            right: 0,
            top: 0,
            bottom: 0,
            width: '400px',
            backgroundColor: 'rgba(0, 0, 0, 0.95)',
            color: '#fff',
            zIndex: 9999,
            display: 'flex',
            flexDirection: 'column',
            borderLeft: '2px solid #0f0',
            fontFamily: 'monospace',
            fontSize: '12px',
            boxShadow: '-5px 0 15px rgba(0,0,0,0.5)'
        }}>
            {/* Header */}
            <div style={{
                padding: '10px',
                borderBottom: '1px solid #333',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                backgroundColor: '#111'
            }}>
                <span style={{ color: '#0f0', fontWeight: 'bold' }}>INTELLIGENT BOT PROTOCOL</span>
                <div>
                    <button onClick={clear} style={{ marginRight: '10px', background: 'transparent', border: '1px solid #666', color: '#aaa', cursor: 'pointer' }}>CLR</button>
                    <button onClick={toggle} style={{ background: 'transparent', border: '1px solid #666', color: '#aaa', cursor: 'pointer' }}>X</button>
                </div>
            </div>

            {/* Logs Area */}
            <div style={{
                flex: 1,
                overflowY: 'auto',
                padding: '10px',
                wordBreak: 'break-word',
                userSelect: 'text', // Allow copying
                cursor: 'text'
            }}>
                {logs.length === 0 && <div style={{ color: '#666', textAlign: 'center', marginTop: '20px' }}>Waiting for data stream...</div>}

                {logs.map((log) => (
                    <div key={log.id} style={{ marginBottom: '8px', borderBottom: '1px solid #222', paddingBottom: '4px' }}>
                        <div style={{ display: 'flex', marginBottom: '2px' }}>
                            <span style={{ color: '#666', marginRight: '8px' }}>[{log.timestamp}]</span>
                            <span style={{
                                fontWeight: 'bold',
                                color: log.level === 'ERROR' ? '#ff4444' :
                                    log.level === 'WARN' ? '#ffbb33' :
                                        log.level === 'SUCCESS' ? '#00C851' : '#33b5e5',
                                marginRight: '8px'
                            }}>{log.level}</span>
                            <span style={{ color: '#ccc' }}>[{log.category}]</span>
                        </div>
                        <div style={{ color: '#fff', paddingLeft: '15px' }}>
                            {log.message}
                        </div>
                        {log.data && (
                            <pre style={{
                                marginTop: '4px',
                                background: '#111',
                                padding: '5px',
                                borderRadius: '3px',
                                color: '#aaa',
                                overflowX: 'auto',
                                fontSize: '10px'
                            }}>
                                {JSON.stringify(log.data, null, 2)}
                            </pre>
                        )}
                    </div>
                ))}
                <div ref={endRef} />
            </div>
        </div>
    );
};

```

### FILE: frontend\src\components\DirectorOverlay.tsx (SKIPPED - >10KB)
### FILE: frontend\src\components\DisputeModal.tsx (SKIPPED - >10KB)
### FILE: frontend\src\components\EmoteMenu.tsx
```tsx
import React from 'react';
import { MessageSquare, Smile, Zap } from 'lucide-react';

interface EmoteMenuProps {
    onSelectEmote: (msg: string) => void;
    onSelectThrowable: (item: string) => void;
    onClose: () => void;
}

const QUICK_CHATS = ["ŸÉŸÅŸà", "ÿßŸÑÿπÿ®", "ŸÖÿß ÿπŸÑŸäŸÉ", "ÿ¨ÿ®ÿ™ ÿßŸÑÿπŸäÿØ", "ÿ≥ÿ±Ÿä", "ŸáŸÑÿß"];
const THROWABLES = [
    { id: 'slipper', icon: 'ü©¥', label: 'ŸÜÿπÿßŸÑ' },
    { id: 'tomato', icon: 'üçÖ', label: 'ÿ∑ŸÖÿßÿ∑ŸÖ' },
    { id: 'flower', icon: 'üåπ', label: 'Ÿàÿ±ÿØÿ©' },
    { id: 'egg', icon: 'ü•ö', label: 'ÿ®Ÿäÿ∂' },
];

const EmoteMenu: React.FC<EmoteMenuProps> = ({ onSelectEmote, onSelectThrowable, onClose }) => {
    return (
        <div className="absolute bottom-24 left-1/2 -translate-x-1/2 bg-[#1e1e1e] border border-gray-600 rounded-xl shadow-2xl p-4 w-72 z-50 animate-in fade-in slide-in-from-bottom-4">

            {/* Header */}
            <div className="flex justify-between items-center mb-4 text-xs font-bold text-gray-400 uppercase tracking-wider">
                <span>Quick Chat</span>
                <button onClick={onClose} className="hover:text-white">‚úï</button>
            </div>

            {/* Quick Chat Grid */}
            <div className="grid grid-cols-3 gap-2 mb-4">
                {QUICK_CHATS.map(msg => (
                    <button
                        key={msg}
                        onClick={() => onSelectEmote(msg)}
                        className="bg-[#2a2a2a] hover:bg-yellow-600 hover:text-white text-gray-300 py-2 rounded text-sm font-bold transition-colors"
                    >
                        {msg}
                    </button>
                ))}
            </div>

            {/* Throwables Section */}
            <div className="border-t border-gray-700 pt-3">
                <div className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-2 flex items-center gap-1">
                    <Zap size={12} className="text-yellow-500" />
                    Throw Item
                </div>
                <div className="flex justify-between">
                    {THROWABLES.map(item => (
                        <button
                            key={item.id}
                            onClick={() => onSelectThrowable(item.id)}
                            className="flex flex-col items-center gap-1 group"
                        >
                            <div className="w-10 h-10 bg-[#2a2a2a] rounded-full flex items-center justify-center text-xl group-hover:scale-110 group-hover:bg-yellow-500/20 transition-all">
                                {item.icon}
                            </div>
                            <span className="text-[10px] text-gray-500">{item.label}</span>
                        </button>
                    ))}
                </div>
            </div>

            {/* Triangle Pointer */}
            <div className="absolute left-1/2 -translate-x-1/2 bottom-[-6px] w-3 h-3 bg-[#1e1e1e] border-b border-r border-gray-600 transform rotate-45"></div>
        </div>
    );
};

export default EmoteMenu;

```

### FILE: frontend\src\components\ErrorBoundary.tsx
```tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
    children: ReactNode;
    fallback?: ReactNode;
}

interface State {
    hasError: boolean;
    error: Error | null;
}

class ErrorBoundary extends Component<Props, State> {
    readonly props: Props;

    public state: State = {
        hasError: false,
        error: null
    };

    public static getDerivedStateFromError(error: Error): State {
        return { hasError: true, error };
    }

    public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
        console.error('ErrorBoundary caught an error:', error, errorInfo);
    }

    public render() {
        if (this.state.hasError) {
            return this.props.fallback || (
                <div className="w-full h-full flex flex-col items-center justify-center bg-gradient-to-br from-red-50 to-red-100 p-8">
                    <div className="bg-white rounded-2xl shadow-2xl p-8 max-w-md text-center">
                        <h2 className="text-2xl font-bold text-red-600 mb-4">ÿπÿ∞ÿ±ÿßŸãÿå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÖÿß</h2>
                        <p className="text-gray-700 mb-6">ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ∫Ÿäÿ± ŸÖÿ™ŸàŸÇÿπ. Ÿäÿ±ÿ¨Ÿâ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿµŸÅÿ≠ÿ©.</p>
                        <button
                            onClick={() => window.location.reload()}
                            className="px-6 py-3 bg-red-600 text-white font-bold rounded-full hover:bg-red-700 transition-all shadow-lg"
                        >
                            ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿµŸÅÿ≠ÿ©
                        </button>
                        {this.state.error && (
                            <details className="mt-4 text-left">
                                <summary className="cursor-pointer text-sm text-gray-500 hover:text-gray-700">
                                    ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿÆÿ∑ÿ£
                                </summary>
                                <pre className="mt-2 p-4 bg-gray-100 rounded text-xs overflow-auto max-h-40">
                                    {this.state.error.toString()}
                                </pre>
                            </details>
                        )}
                    </div>
                </div>
            );
        }

        return this.props.children;
    }
}

export default ErrorBoundary;

```

### FILE: frontend\src\components\GablakTimer.tsx
```tsx
import React, { useEffect, useState } from 'react';
import { GamePhase } from '../types';
import { Clock } from 'lucide-react';

interface GablakTimerProps {
    biddingPhase?: string;
    isActive: boolean;
    duration?: number; // Total duration (e.g. 5s)
    startTime?: number; // Server timestamp
}

const GablakTimer: React.FC<GablakTimerProps> = ({ biddingPhase, isActive, duration = 5, startTime }) => {
    const [timeLeft, setTimeLeft] = useState(duration);

    useEffect(() => {
        if (biddingPhase !== 'GABLAK_WINDOW') return;

        // Simple local countdown for visualization
        // In real implementations, sync with server time
        setTimeLeft(duration);

        const interval = setInterval(() => {
            setTimeLeft(prev => {
                if (prev <= 0) {
                    clearInterval(interval);
                    return 0;
                }
                return prev - 0.1;
            });
        }, 100);

        return () => clearInterval(interval);
    }, [biddingPhase, duration, startTime]);

    if (biddingPhase !== 'GABLAK_WINDOW') return null;

    // Calculate progress for bar
    const progress = (timeLeft / duration) * 100;
    const isCritical = timeLeft < 2;

    return (
        <div className="absolute top-[40%] left-1/2 -translate-x-1/2 z-50 flex flex-col items-center animate-in fade-in zoom-in duration-300">
            <div className={`
                flex items-center gap-2 px-3 py-1.5 rounded-full border shadow-lg backdrop-blur-sm
                transition-colors duration-300
                ${isCritical ? 'bg-red-900/90 border-red-500/50 text-red-100' : 'bg-amber-900/90 border-amber-500/50 text-amber-100'}
            `}>
                <Clock size={14} className={isCritical ? 'animate-bounce' : ''} />
                <div className="flex flex-col items-center leading-none">
                    <span className="font-bold font-tajawal text-xs sm:text-sm">
                        ŸÅÿ±ÿµÿ© ŸÇŸäÿØ (Gablak)
                    </span>
                </div>
                <span className="font-mono text-sm font-bold w-8 text-center bg-black/20 rounded px-1">
                    {timeLeft.toFixed(1)}
                </span>
            </div>

            {/* Micro Progress Bar */}
            <div className="w-[80%] h-1 bg-black/40 rounded-full mt-1 overflow-hidden">
                <div
                    className={`h-full transition-all duration-100 ease-linear ${isCritical ? 'bg-red-500' : 'bg-amber-500'}`}
                    style={{ width: `${progress}%` }}
                />
            </div>
        </div>
    );
};

export default GablakTimer;

```

### FILE: frontend\src\components\GameLayout.tsx
```tsx
import React from 'react';

interface GameLayoutProps {
    children: React.ReactNode;
    className?: string;
    variant?: 'mobile' | 'studio';
}

export const GameLayout: React.FC<GameLayoutProps> = ({ children, className = '', variant = 'mobile' }) => {
    const containerClasses = variant === 'mobile'
        ? "md:w-[480px] md:h-[92vh] md:max-h-[920px]"
        : "md:w-[1200px] md:h-[90vh] md:max-w-[95vw]";

    return (
        <div className="relative w-full h-screen bg-[url('/react-py4web/static/build/assets/premium_wood_texture.png')] bg-cover bg-center flex items-center justify-center overflow-hidden">
            {/* Desktop Background (Visible only on larger screens) */}
            <div className="hidden md:block absolute inset-0 opacity-40 pointer-events-none"
                style={{
                    backgroundImage: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%239C92AC' fill-opacity='0.1'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E")`,
                }}
            />

            {/* App Container */}
            <div
                className={`
          relative 
          w-full h-full 
          ${containerClasses}
          md:rounded-[40px] 
          md:shadow-[0_20px_50px_rgba(0,0,0,0.5),0_0_0_12px_#1a1a1a] 
          bg-[#F5F3EF] 
          overflow-hidden 
          flex flex-col
          ${className}
        `}
            >


                {/* Main Content Area */}
                <div className="flex-1 w-full h-full relative overflow-hidden">
                    {children}
                </div>
            </div>
        </div>
    );
};

export default GameLayout;

```

### FILE: frontend\src\components\GhostCardLayer.tsx
```tsx
import React from 'react';
import { motion } from 'framer-motion';
import CardVector from './CardVector';

interface CandidateMove {
    card: any; // Using any for simplicity with backend dict, but ideally formatted
    win_rate: number;
    diff: number;
    rank: number;
}

interface GhostCardLayerProps {
    candidates: CandidateMove[];
}

export const GhostCardLayer: React.FC<GhostCardLayerProps> = ({ candidates }) => {
    if (!candidates || candidates.length === 0) return null;

    return (
        <div className="flex items-center justify-center p-4">
            <div className="flex gap-3 sm:gap-4 items-end justify-center">
                {candidates.map((cand, idx) => {
                    const isBest = idx === 0;

                    return (
                        <motion.div
                            key={idx}
                            initial={{ opacity: 0, scale: 0.5, y: 20 }}
                            animate={{ opacity: 1, scale: 1, y: 0 }}
                            transition={{ delay: idx * 0.1, duration: 0.4 }}
                            className="relative flex flex-col items-center group"
                        >
                            {/* Annotation */}
                            <div className={`mb-2 px-3 py-1 rounded-full text-sm font-bold shadow-lg backdrop-blur-md border ${isBest ? 'bg-green-500/80 border-green-300 text-white' : 'bg-blue-400/70 border-blue-200 text-white'
                                }`}>
                                +{Math.round(cand.diff * 100)}%
                            </div>

                            {/* The Ghost Card */}
                            <div className={`relative ${isBest ? 'scale-110' : 'scale-90 opacity-80'} transition-transform duration-300`}>
                                {/* Glowing Aura for Best Move */}
                                {isBest && (
                                    <div className="absolute -inset-3 bg-green-400/40 rounded-xl blur-lg animate-pulse" />
                                )}

                                <CardVector
                                    card={cand.card}
                                    className="w-20 h-28 sm:w-24 sm:h-36 shadow-2xl skew-x-1"
                                    isPlayable={false}
                                />

                                {/* Label */}
                                <div className="absolute -bottom-6 w-full text-center text-xs font-bold text-white drop-shadow-md">
                                    Option #{cand.rank}
                                </div>
                            </div>
                        </motion.div>
                    );
                })}
            </div>
        </div>
    );
};

```

### FILE: frontend\src\components\GlassPanel.tsx
```tsx
import React from 'react';
import { motion, HTMLMotionProps } from 'framer-motion';

interface GlassPanelProps extends HTMLMotionProps<"div"> {
    children: React.ReactNode;
    className?: string;
    intensity?: 'low' | 'medium' | 'high';
    border?: boolean;
    glow?: boolean;
}

const GlassPanel: React.FC<GlassPanelProps> = ({
    children,
    className = '',
    intensity = 'medium',
    border = true,
    glow = false,
    ...props
}) => {
    // Opacity & Blur mapping
    const bgMap = {
        low: 'bg-white/10 backdrop-blur-sm',
        medium: 'bg-white/20 backdrop-blur-md',
        high: 'bg-white/30 backdrop-blur-lg'
    };

    const borderClass = border ? 'border border-white/20' : '';
    const glowClass = glow ? 'shadow-[0_0_20px_rgba(212,175,55,0.3)]' : 'shadow-lg';

    return (
        <motion.div
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.95 }}
            transition={{ duration: 0.3, ease: "easeOut" }}
            className={`
                rounded-2xl 
                ${bgMap[intensity]} 
                ${borderClass} 
                ${glowClass} 
                ${className}
            `}
            {...props}
        >
            {children}
        </motion.div>
    );
};

export default GlassPanel;

```

### FILE: frontend\src\components\HandFan.tsx
```tsx
import React from 'react';
import { motion } from 'framer-motion';
import { CardModel as Card, Suit } from '../types';
import CardVector from './CardVector';
import { sortHand } from '../utils/gameLogic';

interface HandFanProps {
    hand: Card[];
    selectedCardIndex: number | null;
    isMyTurn: boolean;
    onCardClick: (index: number) => void;
    cardSkin?: string;
    gameMode: 'SUN' | 'HOKUM';
    trumpSuit?: Suit;
    settings?: any; // To be typed strictly later
}

// Layout Constants
const FAN_SPACING = {
    base: '-space-x-8',
    sm: 'sm:-space-x-10',
    md: 'md:-space-x-12'
};

const ELEVATION = {
    base: 'bottom-0',
    elevated: 'bottom-5 sm:bottom-6',
    hoverBase: 'hover:bottom-4',
    hoverElevated: 'hover:bottom-9 sm:hover:bottom-10',
    selected: 'bottom-12 sm:bottom-14'
};

const HandFanComponent: React.FC<HandFanProps> = ({

    hand,
    selectedCardIndex,
    isMyTurn,
    onCardClick,
    cardSkin = 'card_default',
    gameMode,
    trumpSuit,
    settings
}) => {
    // Memoized sort to avoid re-sorting on every render
    const sortedHand = React.useMemo(() => {
        if (!hand) return [];
        return sortHand(hand, gameMode, trumpSuit || 'S'); // Default stump suit to prevent crash
    }, [hand, gameMode, trumpSuit]);

    // Calculate Card Groups for Elevation (Alternating Up/Down)
    const cardGroups = React.useMemo(() => {
        let currentSuit = '';
        let groupIndex = -1;
        const groups: Record<string, number> = {};

        sortedHand.forEach((card) => {
            if (card.suit !== currentSuit) {
                groupIndex++;
                currentSuit = card.suit;
            }
            groups[card.id] = groupIndex;
        });
        return groups;
    }, [sortedHand]);

    // Validation Helper (Duplicated from Table, ideally passed down or in util)
    const isCardPlayable = (card: Card) => {
        // Strict validation logic is complex and state-dependent (table cards).
        // For visual interaction, we assume "Playable" unless visually disabled?
        // Actually, Table.tsx handles the actual *logic* check on click.
        // We just render.
        return true;
    };

    if (!hand || hand.length === 0) return null;

    return (
        <div className={`
            absolute bottom-2 sm:bottom-4 left-1/2 -translate-x-1/2 
            flex items-end justify-center 
            ${FAN_SPACING.base} ${FAN_SPACING.sm} ${FAN_SPACING.md} 
            z-50 perspective-1000 w-full px-4 overflow-visible pointer-events-none
        `}>
            {sortedHand.map((card, idx) => {
                // Find original index in unsorted hand to pass back to parent
                const originalIndex = hand.findIndex(c => c.id === card.id);
                const isSelected = selectedCardIndex === originalIndex;

                // Visual Grouping Logic
                const groupIdx = cardGroups[card.id] || 0;
                const isElevated = groupIdx % 2 === 0;

                // Determine Classes based on state
                const baseClass = isElevated ? ELEVATION.elevated : ELEVATION.base;
                const hoverClass = isElevated ? ELEVATION.hoverElevated : ELEVATION.hoverBase;

                return (
                    <motion.div key={`hand-${card.id}`}
                        role="button"
                        tabIndex={0}
                        aria-label={`Play ${card.rank} of ${card.suit}`}
                        initial={{ y: 200, opacity: 0, rotate: 10 }}
                        animate={{
                            y: isSelected ? -50 : 0,
                            opacity: 1,
                            rotate: 0,
                            transition: { delay: idx * 0.05, type: "spring", stiffness: 200, damping: 20 }
                        }}
                        className={`
                            relative transition-all duration-300 pointer-events-auto
                            ${isSelected
                                ? `${ELEVATION.selected} z-[60] scale-110`
                                : `${baseClass} ${hoverClass} hover:z-[55] hover:scale-105`
                            }
                            opacity-100
                        `}
                        style={{
                            transformOrigin: 'bottom center',
                            zIndex: isSelected ? 60 : 50 + (sortedHand.length - idx)
                        }}
                        onClick={() => onCardClick(originalIndex)}
                        onKeyDown={(e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                onCardClick(originalIndex);
                            }
                        }}
                    >
                        <CardVector
                            card={card}
                            className="w-[3.75rem] h-[5.55rem] sm:w-[4.55rem] sm:h-[6.7rem] md:w-[5.2rem] md:h-[7.9rem] shadow-2xl"
                            selected={isSelected}
                            isPlayable={true}
                            skin={cardSkin}
                        />
                    </motion.div>
                );
            })}
        </div>
    );
};

const HandFan = React.memo(HandFanComponent, (prev, next) => {
    // Custom comparison for performance
    if (prev.isMyTurn !== next.isMyTurn) return false;
    if (prev.selectedCardIndex !== next.selectedCardIndex) return false;
    if (prev.hand.length !== next.hand.length) return false;

    // Deep check card IDs if length is same (to detect played cards)
    const prevIds = prev.hand.map(c => c.id).join(',');
    const nextIds = next.hand.map(c => c.id).join(',');
    if (prevIds !== nextIds) return false;

    return true; // Props are effectively equal, skip render
});

export default HandFan;


```

### FILE: frontend\src\components\index.ts
```ts
export * from './AIAnalysisPanel';
export { default as AIStudio } from './AIStudio';
export { default as ActionBar } from './ActionBar';
export { default as Card } from './Card';
export { default as CardPicker } from './CardPicker';
export { default as CardReal } from './CardReal';
export { default as CardV2 } from './CardV2';
export { default as CardVector } from './CardVector';
export * from './DevLogSidebar';
export { default as DisputeModal } from './DisputeModal';
export { default as EmoteMenu } from './EmoteMenu';
export { default as ErrorBoundary } from './ErrorBoundary';
export { default as GablakTimer } from './GablakTimer';
export { default as GameLayout } from './GameLayout';
export { default as LevelUpModal } from './LevelUpModal';
export { default as Lobby } from './Lobby';
export { default as MatchReviewModal } from './MatchReviewModal';
export { default as MultiplayerLobby } from './MultiplayerLobby';
export { default as ProjectSelectionModal } from './ProjectSelectionModal';
export { default as RoundResultsModal } from './RoundResultsModal';
export { default as SawaModal } from './SawaModal';
export { default as ScenarioTable } from './ScenarioTable';
export { default as ScoreSheet } from './ScoreSheet';
export { default as SettingsModal } from './SettingsModal';
export { default as Sidebar } from './Sidebar';
export * from './SpeechBubble';
export { default as StoreModal } from './StoreModal';
export * from './SuitIcons';
export { default as Table } from './Table';
export { default as VariantSelectionModal } from './VariantSelectionModal';
export { default as VictoryModal } from './VictoryModal';

```

### FILE: frontend\src\components\LevelUpModal.tsx
```tsx
import React, { useEffect } from 'react';
import { Crown, Star, Coins } from 'lucide-react';
import { soundManager } from '../services/SoundManager';

interface LevelUpModalProps {
    newLevel: number;
    rewards: { coins: number };
    onClose: () => void;
}

const LevelUpModal: React.FC<LevelUpModalProps> = ({ newLevel, rewards, onClose }) => {

    useEffect(() => {
        soundManager.playWinSound(); // Re-use win sound or add level up sound
    }, []);

    return (
        <div className="absolute inset-0 z-[400] flex items-center justify-center bg-black/90 backdrop-blur-md animate-in fade-in duration-500">
            <div className="relative bg-gradient-to-b from-[#1a1a1a] to-black border-2 border-yellow-500 rounded-3xl p-10 flex flex-col items-center shadow-[0_0_100px_rgba(234,179,8,0.3)] max-w-sm w-full text-center">

                {/* Radiation Effect */}
                <div className="absolute inset-0 overflow-hidden rounded-3xl pointer-events-none">
                    <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[500px] h-[500px] bg-yellow-500/10 rounded-full blur-3xl animate-pulse"></div>
                </div>

                <div className="relative mb-6">
                    <div className="w-24 h-24 bg-yellow-500 rounded-full flex items-center justify-center shadow-lg animate-bounce">
                        <Crown size={48} className="text-black" />
                    </div>
                    <div className="absolute -bottom-2 -right-2 bg-black border border-yellow-500 text-yellow-500 font-bold px-3 py-1 rounded-full text-xs">
                        LEVEL UP!
                    </div>
                </div>

                <h2 className="text-4xl font-black text-white mb-2 tracking-tighter">LEVEL {newLevel}</h2>
                <p className="text-gray-400 mb-8">You are becoming a legend of Baloot!</p>

                <div className="w-full bg-[#2a2a2a] rounded-xl p-4 mb-8 border border-gray-700 flex items-center justify-between">
                    <div className="flex items-center gap-3">
                        <Coins className="text-yellow-400" />
                        <span className="text-gray-300 font-bold">Reward</span>
                    </div>
                    <span className="text-2xl font-bold text-yellow-400">+{rewards.coins} Coins</span>
                </div>

                <button
                    onClick={onClose}
                    className="w-full py-4 bg-yellow-500 hover:bg-yellow-400 text-black font-black text-xl rounded-xl shadow-xl transition-all hover:scale-105"
                >
                    CLAIM & CONTINUE
                </button>
            </div>
        </div>
    );
};

export default LevelUpModal;

```

### FILE: frontend\src\components\Lobby.tsx
```tsx
import React, { useState } from 'react';
import { GameSettings } from '../types';
import { Clock, Shield, ShieldAlert, Play, Gamepad2, Brain, RefreshCcw } from 'lucide-react';

interface LobbyProps {
    onStartGame: (settings: GameSettings) => void;
    onMultiplayer: () => void;
    onAIStudio: () => void;
    onAIClassroom: () => void;
    onReplay: () => void;
    onVisionary?: () => void;
}

const Lobby: React.FC<LobbyProps> = ({ onStartGame, onMultiplayer, onAIStudio, onAIClassroom, onReplay, onVisionary }) => {
    const [turnDuration, setTurnDuration] = useState<number>(3);
    const [strictMode, setStrictMode] = useState<boolean>(true);

    const handleStart = () => {
        console.log("Lobby: Start Game Button Clicked");
        // @ts-ignore
        import('../utils/devLogger').then(({ devLogger }) => devLogger.log('LOBBY', 'Button Clicked', { turnDuration, strictMode }));
        onStartGame({ turnDuration, strictMode, soundEnabled: true, gameSpeed: 'NORMAL' });
    };

    return (
        <div
            className="flex h-full w-full items-center justify-center font-tajawal safe-area-top safe-area-bottom p-4"
            style={{ background: 'linear-gradient(180deg, #F5F3EF 0%, #E8E6E1 50%, #DCD6C8 100%)' }}
        >
            {/* Subtle texture overlay - REMOVED for Stability */}

            <div className="w-full max-w-md glass-premium p-6 sm:p-8 relative overflow-hidden">

                {/* Background Glow - Gold accent */}
                <div className="absolute top-[-50%] left-[-50%] w-[200%] h-[200%] bg-[radial-gradient(circle,rgba(212,175,55,0.15)_0%,transparent_60%)] pointer-events-none" />

                <div className="relative z-10 flex flex-col items-center">
                    {/* Logo/Title */}
                    <div className="mb-2 flex items-center gap-3">
                        <Gamepad2 size={36} className="text-amber-600" />
                        <h1 className="text-3xl sm:text-4xl font-bold text-gray-800">ÿ®ŸÑŸàÿ™</h1>
                    </div>
                    <p className="text-gray-500 mb-6 sm:mb-8 text-sm sm:text-base">ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ¨ŸÑÿ≥ÿ©</p>

                    {/* Timer Settings */}
                    <div className="w-full mb-5 sm:mb-6">
                        <div className="flex items-center gap-2 mb-2 sm:mb-3 text-gray-700">
                            <Clock size={18} className="text-blue-500" />
                            <span className="font-bold text-sm sm:text-base">ŸàŸÇÿ™ ÿßŸÑŸÑÿπÿ® (ÿ´ŸàÿßŸÜŸä)</span>
                        </div>
                        <div className="grid grid-cols-4 gap-2">
                            {[3, 5, 10, 15].map((seconds) => (
                                <button
                                    key={seconds}
                                    onClick={() => setTurnDuration(seconds)}
                                    className={`py-2.5 sm:py-3 rounded-xl text-sm font-bold transition-all touch-target ${turnDuration === seconds
                                        ? 'bg-blue-500 text-white shadow-lg shadow-blue-500/30'
                                        : 'bg-white/60 text-gray-600 hover:bg-white border border-gray-200'
                                        }`}
                                >
                                    {seconds}
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* Strict Mode Settings */}
                    <div className="w-full mb-6 sm:mb-8">
                        <div className="flex items-center justify-between mb-2 sm:mb-3 text-gray-700">
                            <div className="flex items-center gap-2">
                                {strictMode ? <Shield size={18} className="text-green-500" /> : <ShieldAlert size={18} className="text-orange-500" />}
                                <span className="font-bold text-sm sm:text-base">ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÑÿπÿ®</span>
                            </div>
                            <span className={`text-xs px-2 py-0.5 rounded-full ${strictMode ? 'bg-green-100 text-green-600' : 'bg-orange-100 text-orange-600'}`}>
                                {strictMode ? 'ÿµÿßÿ±ŸÖ (ÿ¢ŸÑŸä)' : 'ÿ™ÿ≠ÿØŸä (ŸäÿØŸàŸä)'}
                            </span>
                        </div>

                        <div className="flex bg-white/60 p-1 rounded-xl border border-gray-200">
                            <button
                                onClick={() => setStrictMode(true)}
                                className={`flex-1 py-2.5 rounded-lg text-xs sm:text-sm font-bold transition-all touch-target ${strictMode ? 'bg-white text-gray-800 shadow-md' : 'text-gray-500 hover:text-gray-700'
                                    }`}
                            >
                                ŸÖŸÜÿπ ÿßŸÑÿ∫ÿ¥ ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã
                            </button>
                            <button
                                onClick={() => setStrictMode(false)}
                                className={`flex-1 py-2.5 rounded-lg text-xs sm:text-sm font-bold transition-all touch-target ${!strictMode ? 'bg-white text-gray-800 shadow-md' : 'text-gray-500 hover:text-gray-700'
                                    }`}
                            >
                                ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ÿ≠ÿØŸä
                            </button>
                        </div>
                        <p className="text-xs text-gray-500 mt-2 text-right">
                            {strictMode
                                ? "ŸäŸÖŸÜÿπ ÿßŸÑŸÜÿ∏ÿßŸÖ ŸÑÿπÿ® ÿ£Ÿä Ÿàÿ±ŸÇÿ© ŸÖÿÆÿßŸÑŸÅÿ© ŸÑŸÑŸÇŸàÿßŸÜŸäŸÜ ÿ®ÿ¥ŸÉŸÑ ÿ¢ŸÑŸä."
                                : "ŸäŸÖŸÉŸÜ ŸÑŸÑÿßÿπÿ®ŸäŸÜ ŸÑÿπÿ® ÿ£Ÿä Ÿàÿ±ŸÇÿ©. Ÿäÿ¨ÿ® ÿπŸÑŸâ ÿßŸÑÿÆÿµŸÖ ÿßŸÑÿßÿπÿ™ÿ±ÿßÿ∂ ŸÑŸÉÿ¥ŸÅ ÿßŸÑÿ∫ÿ¥."}
                        </p>
                    </div>

                    {/* Start Button - Premium Gold */}
                    <button
                        onClick={handleStart}
                        className="w-full btn-premium flex items-center justify-center gap-2 mb-3"
                    >
                        <Play size={20} fill="currentColor" />
                        <span>ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ® (ÿ∂ÿØ ÿßŸÑŸÉŸÖÿ®ŸäŸàÿ™ÿ±)</span>
                    </button>

                    {/* Multiplayer Button */}
                    <button
                        onClick={onMultiplayer}
                        className="w-full py-3 bg-white/60 border border-gray-300 hover:bg-white text-gray-700 font-bold rounded-full transition-all flex items-center justify-center gap-2 touch-target"
                    >
                        <span>üåê ÿßŸÑŸÑÿπÿ® ÿßŸàŸÜŸÑÿßŸäŸÜ (ÿ™ÿ¨ÿ±Ÿäÿ®Ÿä)</span>
                    </button>

                    <div className="grid grid-cols-2 gap-4 w-full max-w-md mt-3">
                        <button
                            onClick={onAIStudio}
                            className="flex flex-col items-center justify-center gap-2 bg-purple-900/50 hover:bg-purple-800/50 p-6 rounded-xl border border-purple-500/30 transition-all text-purple-200"
                        >
                            <span className="text-3xl">üß†</span>
                            <span className="font-bold">AI Studio</span>
                        </button>

                        <button
                            onClick={onReplay}
                            className="flex flex-col items-center justify-center gap-2 bg-cyan-900/50 hover:bg-cyan-800/50 p-6 rounded-xl border border-cyan-500/30 transition-all text-cyan-200"
                        >
                            <span className="text-3xl">üé•</span>
                            <span className="font-bold">Replay Studio</span>
                        </button>
                    </div>

                    {/* AI Classroom Button */}
                    <button
                        onClick={() => typeof onAIClassroom !== 'undefined' && onAIClassroom()}
                        className="w-full py-3 bg-teal-900/20 border border-teal-500/30 hover:bg-teal-900/40 text-teal-400 font-bold rounded-full transition-all flex items-center justify-center gap-2 touch-target mt-3"
                    >
                        <Brain size={20} />
                        <span>ÿßŸÑŸÅÿµŸÑ ÿßŸÑÿØÿ±ÿßÿ≥Ÿä (ÿ™ÿØÿ±Ÿäÿ®)</span>
                    </button>

                    {/* Visionary Studio Button */}
                    <button
                        // @ts-ignore
                        onClick={() => onVisionary && onVisionary()}
                        className="w-full py-3 bg-[#CDA434]/10 border border-[#CDA434]/30 hover:bg-[#CDA434]/20 text-[#CDA434] font-bold rounded-full transition-all flex items-center justify-center gap-2 touch-target mt-3"
                    >
                        <span className="text-xl">üëÅÔ∏è</span>
                        <span>Visionary Studio (Ingest)</span>
                    </button>

                </div>
            </div>
        </div>
    );
};

export default Lobby;


```

### FILE: frontend\src\components\MatchReviewModal.tsx (SKIPPED - >10KB)
### FILE: frontend\src\components\MultiplayerLobby.tsx
```tsx

import React, { useState, useEffect } from 'react';
import { ArrowLeft, Users, Play, Copy, Loader, Wifi } from 'lucide-react';
import socketService from '../services/SocketService';

interface MultiplayerLobbyProps {
    onBack: () => void;
    onGameStart: (gameState: any, myIndex: number, roomId: string) => void;
}

const MultiplayerLobby: React.FC<MultiplayerLobbyProps> = ({ onBack, onGameStart }) => {
    const [playerName, setPlayerName] = useState(() => {
        const profile = localStorage.getItem('baloot_user_profile');
        return profile ? JSON.parse(profile).firstName : '';
    });
    const [roomCode, setRoomCode] = useState('');
    const [error, setError] = useState('');
    const [isConnecting, setIsConnecting] = useState(false);
    const [createdRoomId, setCreatedRoomId] = useState<string | null>(null);

    useEffect(() => {
        // Connect to socket when entering lobby
        socketService.connect();

        return () => {
            // Don't disconnect here, we might need it for the game.
            // But if we go back, maybe? For now, keep connection.
        };
    }, []);

    const handleCreateRoom = () => {
        setIsConnecting(true);
        setError('');

        socketService.createRoom((response: any) => {
            setIsConnecting(false);
            if (response.success) {
                setCreatedRoomId(response.roomId);
                // Auto-join the created room
                handleJoinRoom(response.roomId);
            } else {
                setError(response.error || 'Failed to create room');
            }
        });
    };

    const handleJoinRoom = (code: string = roomCode) => {
        if (!code || !playerName) {
            setError('Please enter your name and a room code');
            return;
        }

        setIsConnecting(true);
        setError('');

        socketService.joinRoom(code.toUpperCase(), playerName, (response: any) => {
            setIsConnecting(false);
            if (response.success) {
                console.log("Joined Room:", response);
                // We have joined! Now we wait for game start OR if full, server might send game_started separately
                // But for now, our server sends immediate gamestate. 
                // In a real lobby, we'd wait. 
                // If the server sends gameState, it means we entered. 
                // But we might be WAITING.

                // For Phase 1 of Multiplayer:
                // Just pass the state up. The Game View will render 'WAITING' if needed.
                onGameStart(response.gameState, response.yourIndex, code.toUpperCase());
            } else {
                setError(response.error || 'Failed to join room');
            }
        });
    };

    return (
        <div className="flex flex-col items-center justify-center w-full h-full bg-[#050505] text-white p-4 font-['Tajawal'] relative overflow-hidden">
            {/* Background Pattern */}
            <div className="absolute inset-0 opacity-10 pointer-events-none" style={{
                backgroundImage: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23d4af37' fill-opacity='1'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E")`
            }}></div>

            <div className="z-10 bg-[#1e1e1e] border border-gray-700 p-8 rounded-2xl shadow-2xl w-full max-w-md backdrop-blur-sm bg-opacity-90">
                <div className="flex items-center justify-between mb-8">
                    <button onClick={onBack} className="p-2 hover:bg-gray-700 rounded-full transition-colors">
                        <ArrowLeft className="text-gray-400" />
                    </button>
                    <h1 className="text-2xl font-bold text-yellow-500 flex items-center gap-2">
                        <Wifi size={24} />
                        Multiplayer Lobby
                    </h1>
                    <div className="w-10"></div>
                </div>

                {error && (
                    <div className="bg-red-900/50 border border-red-500 text-red-200 p-3 rounded-lg mb-6 text-sm text-center animate-pulse">
                        {error}
                    </div>
                )}

                <div className="space-y-6">
                    <div>
                        <label className="block text-gray-400 text-sm mb-2">My Name</label>
                        <input
                            type="text"
                            value={playerName}
                            onChange={(e) => setPlayerName(e.target.value)}
                            className="w-full bg-[#121212] border border-gray-600 rounded-lg p-3 text-white focus:border-yellow-500 focus:outline-none transition-colors"
                            placeholder="Enter your name"
                        />
                    </div>

                    <div className="grid grid-cols-2 gap-4">
                        {/* Join Existing */}
                        <div className="col-span-2">
                            <label className="block text-gray-400 text-sm mb-2">Room Code</label>
                            <div className="flex gap-2">
                                <input
                                    type="text"
                                    value={roomCode}
                                    onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
                                    maxLength={4}
                                    className="flex-1 bg-[#121212] border border-gray-600 rounded-lg p-3 text-white focus:border-yellow-500 focus:outline-none font-mono tracking-widest text-center uppercase text-lg"
                                    placeholder="ABCD"
                                />
                                <button
                                    onClick={() => handleJoinRoom()}
                                    disabled={isConnecting || !roomCode}
                                    className="bg-yellow-600 hover:bg-yellow-500 text-black font-bold px-6 rounded-lg transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2"
                                >
                                    {isConnecting ? <Loader className="animate-spin" /> : <Play size={20} />}
                                    Join
                                </button>
                            </div>
                        </div>

                        <div className="relative flex py-2 items-center col-span-2">
                            <div className="flex-grow border-t border-gray-700"></div>
                            <span className="flex-shrink-0 mx-4 text-gray-500 text-xs uppercase">Or</span>
                            <div className="flex-grow border-t border-gray-700"></div>
                        </div>

                        {/* Create New */}
                        <button
                            onClick={handleCreateRoom}
                            disabled={isConnecting}
                            className="col-span-2 bg-[#2a2a2a] hover:bg-[#333] border border-gray-600 text-yellow-500 font-bold p-4 rounded-lg transition-all flex items-center justify-center gap-2 group"
                        >
                            {isConnecting ? <Loader className="animate-spin" /> : <Users className="group-hover:scale-110 transition-transform" />}
                            Create New Room
                        </button>
                    </div>
                </div>

                {createdRoomId && (
                    <div className="mt-6 bg-green-900/30 border border-green-500/50 rounded-xl p-4 text-center animate-in fade-in slide-in-from-bottom-4">
                        <p className="text-gray-400 text-sm mb-1">Room Created!</p>
                        <div className="text-3xl font-mono font-bold text-green-400 tracking-[0.5em] mb-2">{createdRoomId}</div>
                        <p className="text-xs text-green-200/70">Automatic join in progress...</p>
                    </div>
                )}
            </div>
        </div>
    );
};

export default MultiplayerLobby;

```

### FILE: frontend\src\components\MultiverseTree.tsx
```tsx

import React, { useEffect, useRef, useState } from 'react';
import * as d3 from 'd3';

interface Node {
    id: string;
    parentId: string | null;
    scoreUs: number;
    scoreThem: number;
    timestamp: string;
    isFork: boolean;
    children?: Node[];
}

interface MultiverseTreeProps {
    onSelectGame: (gameId: string) => void;
    currentGameId: string;
}

const MultiverseTree: React.FC<MultiverseTreeProps> = ({ onSelectGame, currentGameId }) => {
    const svgRef = useRef<SVGSVGElement>(null);
    const containerRef = useRef<HTMLDivElement>(null);
    const [nodes, setNodes] = useState<Node[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    // Fetch Data
    useEffect(() => {
        fetch('/react-py4web/replay/multiverse')
            .then(res => {
                if (!res.ok) throw new Error("Fetch Failed: " + res.statusText);
                return res.json();
            })
            .then(data => {
                if (data.nodes) setNodes(data.nodes);
                else if (data.error) setError(data.error);
                setLoading(false);
            })
            .catch(e => {
                setError(e.message);
                setLoading(false);
            });
    }, []);

    // Render D3 Graph with Zoom
    useEffect(() => {
        if (loading || !svgRef.current || !containerRef.current) return;

        // Fallback or Real Data
        const nodesToUse = nodes.length > 0 ? nodes : [
            { id: "root", parentId: null, scoreUs: 0, scoreThem: 0, timestamp: "0", isFork: false }
        ];

        try {
            const containerWidth = containerRef.current.clientWidth || 800;
            const containerHeight = containerRef.current.clientHeight || 500;
            const margin = { top: 20, right: 120, bottom: 20, left: 120 };

            // Clear previous
            const svg = d3.select(svgRef.current);
            svg.selectAll("*").remove();

            svg.attr("width", "100%")
                .attr("height", "100%")
                .attr("viewBox", `0 0 ${containerWidth} ${containerHeight}`)
                .style("background-color", "rgba(0,0,0,0.2)"); // Visual bounds

            // Zoom Container
            const g = svg.append("g");

            // Build Hierarchy
            const nodeMap = new Map<string, Node>();
            nodesToUse.forEach(n => nodeMap.set(n.id, { ...n, children: [] }));

            const roots: Node[] = [];
            nodeMap.forEach(n => {
                if (n.parentId && nodeMap.has(n.parentId)) {
                    nodeMap.get(n.parentId)!.children!.push(n);
                } else {
                    roots.push(n);
                }
            });

            // Active Root Logic
            let activeRoot = roots.find(r => r.id === currentGameId) || roots[0];
            if (nodeMap.has(currentGameId)) {
                let curr = nodeMap.get(currentGameId);
                while (curr?.parentId && nodeMap.has(curr.parentId)) {
                    curr = nodeMap.get(curr.parentId);
                }
                if (curr) activeRoot = curr;
            }

            if (!activeRoot) {
                g.append("text").text("No Data").attr("fill", "white").attr("y", 100).attr("x", 100);
                return;
            }

            const rootLayout = d3.hierarchy<Node>(activeRoot);

            // Dynamic Tree Size based on depth/breadth
            // If tree is huge, we make the logical layout larger, zoom handles the view
            const levelHeight = 150;
            const nodeHeight = 60;
            const maxDepth = rootLayout.height;
            const maxBreadth = Math.max(1, rootLayout.leaves().length);

            const treeWidth = Math.max(containerWidth - margin.left - margin.right, maxDepth * levelHeight);
            const treeHeight = Math.max(containerHeight - margin.top - margin.bottom, maxBreadth * nodeHeight);

            const treeLayout = d3.tree<Node>()
                .size([treeHeight, treeWidth]); // D3 Tree uses [height, width] for horizontal layout

            treeLayout(rootLayout);

            // Center the tree initially
            const initialTransform = d3.zoomIdentity
                .translate(margin.left, margin.top);

            // Zoom Behavior
            const zoom = d3.zoom<SVGSVGElement, unknown>()
                .scaleExtent([0.1, 3])
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                });

            svg.call(zoom)
                .call(zoom.transform, initialTransform);

            // Render Links
            const linkGen = d3.linkHorizontal()
                .x((d: any) => d.y)
                .y((d: any) => d.x) as any;

            g.selectAll('.link')
                .data(rootLayout.links())
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('d', linkGen)
                .attr('fill', 'none')
                .attr('stroke', '#CDA434')
                .attr('stroke-width', 2)
                .attr('opacity', 0.6);

            // Render Nodes
            const nodeGroup = g.selectAll('.node')
                .data(rootLayout.descendants())
                .enter()
                .append('g')
                .attr('class', d => `node ${d.data.id === currentGameId ? 'active' : ''}`)
                .attr("transform", (d: any) => `translate(${d.y},${d.x})`)
                .style("cursor", "pointer")
                .on("click", (event, d) => onSelectGame(d.data.id));

            // Node Circle
            nodeGroup.append('circle')
                .attr('r', 12)
                .style('fill', (d: any) => {
                    if (d.data.id === currentGameId) return '#CDA434';
                    const win = d.data.scoreUs > d.data.scoreThem;
                    return win ? '#4ade80' : '#f87171'; // Green/Red
                })
                .style('stroke', '#1a1a1a')
                .style('stroke-width', 2);

            // Current Indicator Ring
            g.selectAll('.node.active')
                .append('circle')
                .attr('r', 18)
                .attr('fill', 'none')
                .attr('stroke', '#CDA434')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '4 2')
                .style('animation', 'spin 10s linear infinite'); // CSS handle spin if possible, else static

            // Score Labels
            nodeGroup.append('text')
                .attr('dy', '.35em')
                .attr('x', (d: any) => d.children && d.children.length ? -18 : 18)
                .style('text-anchor', (d: any) => d.children && d.children.length ? 'end' : 'start')
                .text((d: any) => `${d.data.scoreUs}-${d.data.scoreThem}`)
                .style('fill', 'white')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .style('text-shadow', '0 2px 4px rgba(0,0,0,0.8)');

            // Fork ID Label
            nodeGroup.append('text')
                .attr('dy', '1.6em')
                .attr('x', (d: any) => d.children && d.children.length ? -18 : 18)
                .style('text-anchor', (d: any) => d.children && d.children.length ? 'end' : 'start')
                .text((d: any) => d.data.isFork ? '‚ö° fork' : 'root')
                .style('fill', '#CDA434')
                .style('font-size', '8px')
                .style('opacity', 0.8);

        } catch (err: any) {
            console.error(err);
        }

    }, [nodes, loading, currentGameId]);

    return (
        <div ref={containerRef} className="bg-slate-900/90 rounded-2xl border border-white/10 p-1 shadow-2xl relative overflow-hidden w-[90vw] h-[80vh] backdrop-blur-xl">
            <div className="absolute top-4 left-4 z-10 pointer-events-none">
                <h3 className="text-[#CDA434] font-bold text-lg flex items-center gap-2 drop-shadow-md">
                    <span>‚ö°</span> Multiverse Tree <span className="text-xs text-slate-400 font-normal border border-white/10 px-2 py-0.5 rounded-full">{nodes.length} Timelines</span>
                </h3>
                <p className="text-[10px] text-white/40 mt-1 max-w-[200px]">
                    Scroll to Zoom ‚Ä¢ Drag to Pan <br />
                    Click node to travel
                </p>
            </div>

            <svg ref={svgRef} className="w-full h-full cursor-grab active:cursor-grabbing"></svg>

            {/* Legend */}
            <div className="absolute bottom-4 right-4 flex gap-4 text-[10px] bg-black/40 px-3 py-1.5 rounded-full border border-white/5 backdrop-blur-md text-white/60 pointer-events-none">
                <div className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-green-400"></span> Win</div>
                <div className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-red-400"></span> Loss</div>
                <div className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-[#CDA434]"></span> Current</div>
            </div>

            {loading && (
                <div className="absolute inset-0 flex items-center justify-center bg-black/50 backdrop-blur-sm z-20">
                    <div className="text-[#CDA434] animate-pulse font-mono">Loading timelines...</div>
                </div>
            )}
        </div>
    );
};

export default MultiverseTree;

```

### FILE: frontend\src\components\ProjectSelectionModal.tsx
```tsx
import React from 'react';
import { X, Trophy, Crown, Layers, Star } from 'lucide-react';

interface ProjectSelectionModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSelect: (projectType: string) => void;
}

const ProjectSelectionModal: React.FC<ProjectSelectionModalProps> = ({ isOpen, onClose, onSelect }) => {
    if (!isOpen) return null;

    const projects = [
        { id: 'SIRA', label: 'ÿ≥ÿ±ÿß', icon: <Layers size={24} />, desc: '3 consecutive' },
        { id: 'FIFTY', label: 'ÿÆŸÖÿ≥ŸäŸÜ', icon: <Star size={24} />, desc: '4 consecutive' },
        { id: 'HUNDRED', label: 'ŸÖŸäÿ©', icon: <Trophy size={24} />, desc: '5 consecutive / 4 Aces' },
        { id: 'FOUR_HUNDRED', label: 'ÿ£ÿ±ÿ®ÿπŸÖŸäÿ©', icon: <Crown size={24} />, desc: '4 Aces (Sun)' },
        { id: 'BALOOT', label: 'ÿ®ŸÑŸàÿ™', icon: <Crown size={24} />, desc: 'K + Q (Hokum)' },
    ];

    return (
        <div className="fixed inset-0 z-[200] flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-fade-in">
            <div className="relative bg-gradient-to-b from-gray-900 to-gray-800 border-2 border-yellow-600 rounded-2xl shadow-2xl w-full max-w-md overflow-hidden transform transition-all scale-100">

                {/* Header */}
                <div className="bg-gradient-to-r from-yellow-700/20 to-yellow-900/20 p-4 border-b border-yellow-600/30 flex justify-between items-center">
                    <h2 className="text-xl font-black text-yellow-500 flex items-center gap-2">
                        <Trophy className="text-yellow-400" />
                        ŸäÿπŸÑŸÜ ŸÖÿ¥ÿßÿ±Ÿäÿπ
                    </h2>
                    <button onClick={onClose} className="text-gray-400 hover:text-white transition-colors">
                        <X size={24} />
                    </button>
                </div>

                {/* Content */}
                <div className="p-6 grid grid-cols-2 gap-4">
                    {projects.map((p) => (
                        <button
                            key={p.id}
                            onClick={() => onSelect(p.id)}
                            className="group relative flex flex-col items-center justify-center p-4 bg-gray-800/50 hover:bg-yellow-900/20 border border-gray-600 hover:border-yellow-500 rounded-xl transition-all duration-300 hover:shadow-[0_0_15px_rgba(234,179,8,0.2)]"
                        >
                            <div className="mb-3 p-3 bg-gray-700/50 group-hover:bg-yellow-500/20 rounded-full transition-colors text-yellow-500">
                                {p.icon}
                            </div>
                            <span className="text-lg font-bold text-gray-200 group-hover:text-yellow-400 mb-1">{p.label}</span>
                            <span className="text-xs text-gray-500 group-hover:text-yellow-200/60 uppercase tracking-widest">{p.desc}</span>
                        </button>
                    ))}
                </div>

                {/* Footer */}
                <div className="bg-gray-900/50 p-4 text-center">
                    <p className="text-xs text-gray-500">
                        Select a project to verify its validity.
                    </p>
                </div>
            </div>
        </div>
    );
};

export default ProjectSelectionModal;

```

### FILE: frontend\src\components\RoundResultsModal.tsx (SKIPPED - >10KB)
### FILE: frontend\src\components\SawaModal.tsx
```tsx
import React from 'react';
import { Gavel, ThumbsUp, ThumbsDown } from 'lucide-react';
import { PlayerPosition } from '../types';

interface SawaModalProps {
    isOpen: boolean;
    claimerName: string;
    onAccept: () => void;
    onRefuse: () => void;
}

const SawaModal: React.FC<SawaModalProps> = ({ isOpen, claimerName, onAccept, onRefuse }) => {
    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 z-[200] flex items-center justify-center bg-black/60 backdrop-blur-sm animate-in fade-in duration-300">
            <div className="bg-gradient-to-b from-gray-900 to-black border-2 border-[var(--color-premium-gold)] rounded-3xl p-8 max-w-md w-full shadow-[0_0_50px_rgba(212,175,55,0.3)] animate-bounce-in relative overflow-hidden">

                {/* Background Glow */}
                <div className="absolute top-0 left-1/2 -translate-x-1/2 w-full h-32 bg-[var(--color-premium-gold)] opacity-20 blur-3xl rounded-full pointer-events-none"></div>

                <div className="relative z-10 flex flex-col items-center text-center gap-6">
                    <div className="bg-[var(--color-premium-gold)] p-4 rounded-full shadow-lg shadow-amber-500/20">
                        <Gavel size={48} className="text-black" />
                    </div>

                    <div>
                        <h2 className="text-3xl font-black text-white mb-2 drop-shadow-md">Sawa Check</h2>
                        <p className="text-amber-100/80 text-lg">
                            <span className="font-bold text-[var(--color-premium-gold)]">{claimerName}</span> claims to win all remaining tricks.
                        </p>
                        <p className="text-white/40 text-sm mt-2">
                            If you refuse and they lose a trick, they suffer Khasara!
                        </p>
                    </div>

                    <div className="flex gap-4 w-full mt-2">
                        <button
                            onClick={onRefuse}
                            className="flex-1 py-4 bg-red-600 hover:bg-red-500 text-white rounded-xl font-bold text-lg flex items-center justify-center gap-2 transition-all hover:scale-105 active:scale-95 shadow-lg shadow-red-900/40"
                        >
                            <ThumbsDown size={20} />
                            Refuse
                        </button>

                        <button
                            onClick={onAccept}
                            className="flex-1 py-4 bg-green-600 hover:bg-green-500 text-white rounded-xl font-bold text-lg flex items-center justify-center gap-2 transition-all hover:scale-105 active:scale-95 shadow-lg shadow-green-900/40"
                        >
                            <ThumbsUp size={20} />
                            Accept
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default SawaModal;

```

### FILE: frontend\src\components\ScenarioTable.tsx (SKIPPED - >10KB)
### FILE: frontend\src\components\ScoreSheet.tsx
```tsx
import React from 'react';
import { RoundResult } from '../types';

interface ScoreSheetProps {
    roundHistory: RoundResult[];
    matchScores: { us: number; them: number };
    currentRoundScore: { us: number; them: number };
}

const ScoreSheet: React.FC<ScoreSheetProps> = ({ roundHistory, matchScores, currentRoundScore }) => {
    return (
        <div className="w-full bg-[#f3e5ab] text-black font-serif rounded-lg shadow-inner overflow-hidden relative">
            {/* Paper Texture Overlay */}
            <div className="absolute inset-0 pointer-events-none opacity-10 bg-[url('https://www.transparenttextures.com/patterns/notebook.png')]"></div>

            {/* Header */}
            <div className="flex border-b-2 border-gray-400 bg-[#e6d595] p-2 text-center font-bold text-lg relative z-10">
                <div className="w-1/2">ŸÑŸáŸÖ (Laham)</div>
                <div className="w-1/2 border-l border-gray-400">ŸÑŸÜÿß (Lana)</div>
            </div>

            {/* History Rows */}
            <div className="p-2 space-y-1 min-h-[150px] relative z-10">
                {roundHistory.map((round) => (
                    <div key={round.roundNumber} className="flex text-lg border-b border-gray-300 pb-1 group relative cursor-help hover:bg-black/5 transition-colors">
                        {/* Tooltip for Score Breakdown */}
                        <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 w-48 bg-black text-white text-xs p-2 rounded hidden group-hover:block z-50 pointer-events-none shadow-xl">
                            <div className="font-bold border-b border-gray-600 mb-1 pb-1">Round {round.roundNumber} Breakdown</div>
                            <div className="flex justify-between text-blue-300">
                                <span>Us:</span>
                                <span>{round.us.rawCardPoints} (Cards) + {round.us.projectPoints} (Proj)</span>
                            </div>
                            <div className="flex justify-between text-red-300">
                                <span>Them:</span>
                                <span>{round.them.rawCardPoints} (Cards) + {round.them.projectPoints} (Proj)</span>
                            </div>
                        </div>

                        {/* Penalty / Qayd Indicators */}
                        {round.them.totalRaw === 0 && (
                            <div className="absolute left-1 top-1/2 -translate-y-1/2 text-red-600 text-xs font-black" title="Qayd / Shutout">‚ùå</div>
                        )}
                        {round.us.totalRaw === 0 && (
                            <div className="absolute right-1 top-1/2 -translate-y-1/2 text-red-600 text-xs font-black" title="Qayd / Shutout">‚ùå</div>
                        )}

                        <div className={`w-1/2 text-center font-bold ${round.winner === 'them' ? 'text-red-800' : ''}`}>
                            {round.them.gamePoints}
                        </div>
                        <div className={`w-1/2 text-center border-l border-gray-300 font-bold ${round.winner === 'us' ? 'text-green-800' : ''}`}>
                            {round.us.gamePoints}
                        </div>
                    </div>
                ))}

                {/* Current Round (In Progress) */}
                <div className="flex text-lg text-gray-500 italic">
                    <div className="w-1/2 text-center">{currentRoundScore.them > 0 ? `+${currentRoundScore.them}` : '-'}</div>
                    <div className="w-1/2 text-center border-l border-gray-300">{currentRoundScore.us > 0 ? `+${currentRoundScore.us}` : '-'}</div>
                </div>
            </div>

            {/* Total Footer */}
            <div className="flex border-t-2 border-gray-800 bg-[#e6d595] p-2 text-center font-black text-xl relative z-10">
                <div className="w-1/2 text-red-900">{matchScores.them}</div>
                <div className="w-1/2 border-l border-gray-800 text-blue-900">{matchScores.us}</div>
            </div>

            {/* Sakkah Line Visualization (Optional - usually just a line across) */}
            <div className="absolute top-0 bottom-0 left-1/2 w-px bg-red-400/30 z-0"></div>
        </div>
    );
};

export default ScoreSheet;

```

### FILE: frontend\src\components\SettingsModal.tsx (SKIPPED - >10KB)
### FILE: frontend\src\components\Sidebar.tsx
```tsx
import React, { useRef, useEffect } from 'react';
import { Settings, HelpCircle, LogOut, Volume2, MessageSquare, Signal, Users, User, Trophy, History, Crown, Coins, Star } from 'lucide-react';
import ScoreSheet from './ScoreSheet';
import { UserProfile, RoundResult, Player } from '../types';

interface SidebarProps {
  scores: { us: number; them: number }; // Round Scores
  matchScores: { us: number; them: number }; // Global Scores (Target 152)
  roundHistory: RoundResult[];
  userProfile?: UserProfile;
  messages: { sender: string, text: string }[];
  roomId?: string | null;
  players?: Player[]; // Added players for Bot Insights
}

const Sidebar: React.FC<SidebarProps> = ({ scores, matchScores, roundHistory, userProfile, messages, roomId, players }) => {
  const chatEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    chatEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  return (
    <div className="hidden md:flex flex-col w-72 bg-white/80 backdrop-blur-lg border-r border-white/30 h-full text-gray-800 shrink-0 z-30 shadow-lg">

      {/* --- Top Icons --- */}
      <div className="flex justify-between px-4 py-3 bg-white/50 border-b border-gray-200/50">
        <button className="text-gray-500 hover:text-red-500 transition-colors"><LogOut size={20} /></button>
        <button className="text-gray-500 hover:text-blue-500 transition-colors"><HelpCircle size={20} /></button>
        <button className="text-gray-500 hover:text-gray-800 transition-colors"><Settings size={20} /></button>
        <button className="text-gray-500 hover:text-gray-800 transition-colors"><Volume2 size={20} /></button>
      </div>

      {/* --- Session Info --- */}
      <div className="p-4 bg-white/40 border-b border-gray-200/50">
        <div className="flex justify-between items-center mb-1">
          <span className="text-gray-500 text-xs font-tajawal">ÿ±ŸÇŸÖ ÿßŸÑÿ¨ŸÑÿ≥ÿ©</span>
          <div className="flex flex-col items-end">
            {userProfile ? (
              <>
                <span className="text-xs font-bold text-amber-600">Lvl {userProfile.level}</span>
                <span className="text-[10px] text-gray-400">{userProfile.coins} Coins</span>
              </>
            ) : (
              <span className="text-xs text-gray-400">Guest</span>
            )}
          </div>
        </div>
        <div className="flex justify-between items-center">
          <h2 className="text-xl font-bold tracking-wider text-gray-800">{roomId || "OFFLINE"}</h2>
          <Signal size={16} className={roomId ? "text-green-500" : "text-gray-400"} />
        </div>
      </div>

      {/* --- Score Board (Qayd) --- */}
      <div className="p-4">
        <ScoreSheet
          roundHistory={roundHistory}
          matchScores={matchScores}
          currentRoundScore={scores}
        />
      </div>

      {/* --- Spectators --- */}
      <div className="px-4 py-2 border-b border-gray-200/50">
        <div className="flex items-center gap-2 text-gray-500">
          <Users size={14} />
          <span className="text-xs font-bold">ÿßŸÑŸÖÿ¥ÿßŸáÿØŸàŸÜ (0)</span>
        </div>
      </div>

      {/* --- Bot Insights REMOVED (Moved to dedicated Left Panel) --- */}

      {/* --- Chat Area --- */}
      <div className="flex-1 flex flex-col min-h-0 bg-white/30">
        <div className="flex-1 overflow-y-auto p-3 space-y-2">
          {messages.length === 0 && (
            <div className="text-center text-gray-400 text-xs mt-4 italic">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ±ÿ≥ÿßÿ¶ŸÑ</div>
          )}
          {messages.map((msg, i) => (
            <div key={i} className="text-sm">
              <span className="text-amber-600 font-bold ml-1">{msg.sender}:</span>
              <span className="text-gray-700">{msg.text}</span>
            </div>
          ))}
          <div ref={chatEndRef} />
        </div>

        <div className="p-3 bg-white/50 border-t border-gray-200/50 flex items-center gap-2">
          <input
            type="text"
            placeholder="ÿ±ÿ≥ÿßŸÑÿ™ŸÉ..."
            className="flex-1 bg-white/70 border border-gray-200 rounded-full px-4 py-2 text-gray-800 text-right text-sm placeholder-gray-400 focus:outline-none focus:border-amber-400 transition-colors"
          />
          <button className="p-2 bg-amber-500 hover:bg-amber-400 rounded-full text-white transition-colors shadow-md">
            <MessageSquare size={16} />
          </button>
        </div>
      </div>

    </div>
  );
};

export default Sidebar;
```

### FILE: frontend\src\components\SpeechBubble.tsx
```tsx
import React, { useEffect, useState } from 'react';

interface SpeechBubbleProps {
    text: string | null;
    isVisible: boolean;
    onComplete?: () => void;
    position: 'top' | 'bottom' | 'left' | 'right';
}

export const SpeechBubble: React.FC<SpeechBubbleProps> = ({ text, isVisible, onComplete, position }) => {
    const [show, setShow] = useState(isVisible);

    useEffect(() => {
        setShow(isVisible);
        if (isVisible) {
            const timer = setTimeout(() => {
                setShow(false);
                if (onComplete) onComplete();
            }, 5000); // 5 seconds display
            return () => clearTimeout(timer);
        }
    }, [isVisible, text, onComplete]);

    if (!show || !text) return null;

    // Positioning styles
    const positionStyles: Record<string, React.CSSProperties> = {
        top: { bottom: '110%', left: '50%', transform: 'translateX(-50%)' },
        bottom: { top: '110%', left: '50%', transform: 'translateX(-50%)' },
        left: { right: '110%', top: '50%', transform: 'translateY(-50%)' },
        right: { left: '110%', top: '50%', transform: 'translateY(-50%)' }
    };

    return (
        <div
            style={{
                position: 'absolute',
                ...positionStyles[position],
                backgroundColor: '#ffffff',
                color: '#1f2937',
                padding: '6px 8px',
                borderRadius: '8px',
                maxWidth: '120px',
                fontSize: '10px',
                fontWeight: 'bold',
                boxShadow: '0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06)',
                zIndex: 50,
                pointerEvents: 'none',
                whiteSpace: 'normal',
                textAlign: 'center',
                border: '1px solid #e5e7eb',
                animation: 'popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)'
            }}
        >
            <div
                style={{
                    content: '""',
                    position: 'absolute',
                    width: '6px',
                    height: '6px',
                    backgroundColor: '#ffffff',
                    transform: 'rotate(45deg)',
                    borderBottom: '1px solid #e5e7eb',
                    borderRight: '1px solid #e5e7eb',
                    ...(position === 'top' ? { bottom: '-4px', left: '50%', marginLeft: '-3px' } : {}),
                    ...(position === 'bottom' ? { top: '-4px', left: '50%', marginLeft: '-3px', borderBottom: 'none', borderRight: 'none', borderTop: '1px solid #e5e7eb', borderLeft: '1px solid #e5e7eb' } : {}),
                    ...(position === 'left' ? { right: '-4px', top: '50%', marginTop: '-3px', transform: 'rotate(-45deg)', borderBottom: '1px solid #e5e7eb', borderRight: '1px solid #e5e7eb' } : {}),
                    ...(position === 'right' ? { left: '-4px', top: '50%', marginTop: '-3px', transform: 'rotate(135deg)', borderBottom: '1px solid #e5e7eb', borderRight: '1px solid #e5e7eb' } : {})
                }}
            />
            "{text}"
            <style>{`
        @keyframes popIn {
          from { opacity: 0; transform: scale(0.5) ${position === 'top' || position === 'bottom' ? 'translateX(-50%)' : 'translateY(-50%)'}; }
          to { opacity: 1; transform: scale(1) ${position === 'top' || position === 'bottom' ? 'translateX(-50%)' : 'translateY(-50%)'}; }
        }
      `}</style>
        </div>
    );
};

```

### FILE: frontend\src\components\StoreModal.tsx
```tsx
import React, { useState } from 'react';
import { X, Coins, Check, Lock } from 'lucide-react';
import { UserProfile } from '../types';

interface StoreModalProps {
    userProfile: UserProfile;
    onClose: () => void;
    onPurchase: (itemId: string, cost: number, type: 'card' | 'table') => void;
    onEquip: (itemId: string, type: 'card' | 'table') => void;
    ownedItems: string[];
    equippedItems: { card: string, table: string };
}

interface StoreItem {
    id: string;
    name: string;
    cost: number;
    type: 'card' | 'table';
    previewColor: string;
}

const ITEMS: StoreItem[] = [
    { id: 'card_default', name: 'Classic Blue', cost: 0, type: 'card', previewColor: 'bg-blue-900' },
    { id: 'card_gold', name: 'Royal Gold', cost: 500, type: 'card', previewColor: 'bg-yellow-500' },
    { id: 'card_sadu', name: 'Sadu Pattern', cost: 200, type: 'card', previewColor: 'bg-red-900' },

    { id: 'table_default', name: 'Classic Green', cost: 0, type: 'table', previewColor: 'bg-green-900' },
    { id: 'table_majlis', name: 'Red Majlis', cost: 1000, type: 'table', previewColor: 'bg-red-800' },
    { id: 'table_neon', name: 'Cyber Neon', cost: 1500, type: 'table', previewColor: 'bg-purple-900' },
];

const StoreModal: React.FC<StoreModalProps> = ({ userProfile, onClose, onPurchase, onEquip, ownedItems, equippedItems }) => {
    const [activeTab, setActiveTab] = useState<'card' | 'table'>('card');

    const filteredItems = ITEMS.filter(item => item.type === activeTab);

    return (
        <div className="absolute inset-0 z-[200] flex items-center justify-center bg-black/90 backdrop-blur-md">
            <div className="w-full max-w-4xl bg-[#1e1e1e] border border-gray-700 rounded-2xl shadow-2xl flex flex-col h-[600px] overflow-hidden">

                {/* Header */}
                <div className="p-6 border-b border-gray-700 flex justify-between items-center bg-[#252525]">
                    <div>
                        <h2 className="text-2xl font-bold text-white flex items-center gap-2">
                            <Coins className="text-yellow-500" />
                            Store
                        </h2>
                        <span className="text-gray-400 text-sm">Spend your hard earned coins!</span>
                    </div>
                    <div className="flex items-center gap-4">
                        <div className="bg-black/50 px-4 py-2 rounded-full border border-yellow-500/30 flex items-center gap-2">
                            <Coins size={16} className="text-yellow-500" />
                            <span className="text-yellow-500 font-bold">{userProfile.coins}</span>
                        </div>
                        <button onClick={onClose} className="p-2 hover:bg-white/10 rounded-full transition-colors">
                            <X className="text-white" />
                        </button>
                    </div>
                </div>

                {/* Tabs */}
                <div className="flex border-b border-gray-700">
                    <button
                        onClick={() => setActiveTab('card')}
                        className={`flex-1 py-4 text-center font-bold tracking-wider transition-colors ${activeTab === 'card' ? 'bg-[#2a2a2a] text-white border-b-2 border-yellow-500' : 'text-gray-500 hover:text-gray-300'}`}
                    >
                        CARD SKINS
                    </button>
                    <button
                        onClick={() => setActiveTab('table')}
                        className={`flex-1 py-4 text-center font-bold tracking-wider transition-colors ${activeTab === 'table' ? 'bg-[#2a2a2a] text-white border-b-2 border-yellow-500' : 'text-gray-500 hover:text-gray-300'}`}
                    >
                        TABLE THEMES
                    </button>
                </div>

                {/* Grid */}
                <div className="flex-1 overflow-y-auto p-8 bg-noise">
                    <div className="grid grid-cols-3 gap-6">
                        {filteredItems.map(item => {
                            const isOwned = ownedItems.includes(item.id);
                            const isEquipped = activeTab === 'card' ? equippedItems.card === item.id : equippedItems.table === item.id;
                            const canAfford = userProfile.coins >= item.cost;

                            return (
                                <div key={item.id} className="bg-[#2a2a2a] rounded-xl border border-gray-700 overflow-hidden group hover:border-gray-500 transition-all">
                                    <div className={`h-40 ${item.previewColor} relative flex items-center justify-center`}>
                                        {/* Preview Placeholder */}
                                        <div className="w-16 h-24 bg-white/10 border-2 border-white/20 rounded shadow-lg transform group-hover:scale-110 transition-transform"></div>
                                        {isEquipped && (
                                            <div className="absolute top-2 right-2 bg-green-500 text-black text-xs font-bold px-2 py-1 rounded-full flex items-center gap-1 shadow-lg">
                                                <Check size={12} /> EQUIPPED
                                            </div>
                                        )}
                                    </div>
                                    <div className="p-4">
                                        <h3 className="font-bold text-white mb-1">{item.name}</h3>
                                        <div className="flex justify-between items-center mt-4">
                                            {isOwned ? (
                                                <button
                                                    onClick={() => onEquip(item.id, item.type)}
                                                    disabled={isEquipped}
                                                    className={`w-full py-2 rounded-lg font-bold text-sm transition-all ${isEquipped
                                                            ? 'bg-gray-700 text-gray-400 cursor-default'
                                                            : 'bg-white text-black hover:bg-gray-200'
                                                        }`}
                                                >
                                                    {isEquipped ? 'EQUIPPED' : 'EQUIP'}
                                                </button>
                                            ) : (
                                                <button
                                                    onClick={() => onPurchase(item.id, item.cost, item.type)}
                                                    disabled={!canAfford}
                                                    className={`w-full py-2 rounded-lg font-bold text-sm flex items-center justify-center gap-2 transition-all ${canAfford
                                                            ? 'bg-yellow-600 hover:bg-yellow-500 text-white'
                                                            : 'bg-gray-700 text-gray-500 cursor-not-allowed'
                                                        }`}
                                                >
                                                    {item.cost === 0 ? 'FREE' : item.cost} <Coins size={14} />
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>

            </div>
        </div>
    );
};

export default StoreModal;

```

### FILE: frontend\src\components\SuitIcons.tsx
```tsx
import React from 'react';

export const Spade: React.FC<{ size?: number; color?: string; className?: string }> = ({ size = 24, color = "currentColor", className = "" }) => (
    <svg width={size} height={size} viewBox="0 0 24 24" fill={color} className={className} xmlns="http://www.w3.org/2000/svg">
        <path d="M12 2C9 2 7 4.5 7 7C7 9.5 9.5 12 12 14.5C14.5 12 17 9.5 17 7C17 4.5 15 2 12 2ZM12 14.5C9 14.5 4 17 4 21H20C20 17 15 14.5 12 14.5Z" />
        <path d="M11 15V21H13V15H11Z" fill={color} />
    </svg>
);

export const Heart: React.FC<{ size?: number; color?: string; className?: string }> = ({ size = 24, color = "currentColor", className = "" }) => (
    <svg width={size} height={size} viewBox="0 0 24 24" fill={color} className={className} xmlns="http://www.w3.org/2000/svg">
        <path d="M12 21.35L10.55 20.03C5.4 15.36 2 12.27 2 8.5C2 5.41 4.42 3 7.5 3C9.24 3 10.91 3.81 12 5.08C13.09 3.81 14.76 3 16.5 3C19.58 3 22 5.41 22 8.5C22 12.27 18.6 15.36 13.45 20.03L12 21.35Z" />
    </svg>
);

export const Club: React.FC<{ size?: number; color?: string; className?: string }> = ({ size = 24, color = "currentColor", className = "" }) => (
    <svg width={size} height={size} viewBox="0 0 24 24" fill={color} className={className} xmlns="http://www.w3.org/2000/svg">
        <circle cx="12" cy="7" r="4.5" />
        <circle cx="7" cy="15" r="4.5" />
        <circle cx="17" cy="15" r="4.5" />
        <polygon points="12,12 10,21 14,21" />
    </svg>
);

export const Diamond: React.FC<{ size?: number; color?: string; className?: string }> = ({ size = 24, color = "currentColor", className = "" }) => (
    <svg width={size} height={size} viewBox="0 0 24 24" fill={color} className={className} xmlns="http://www.w3.org/2000/svg">
        <path d="M12 2L2 12L12 22L22 12L12 2Z" />
    </svg>
);

```

### FILE: frontend\src\components\Table.tsx (SKIPPED - >10KB)
### FILE: frontend\src\components\VariantSelectionModal.tsx
```tsx
import React from 'react';
import { GamePhase } from '../types';
import { Lock, Unlock } from 'lucide-react';

interface VariantSelectionModalProps {
    phase: GamePhase;
    isMyTurn: boolean;
    onSelect: (variant: 'OPEN' | 'CLOSED') => void;
}

const VariantSelectionModal: React.FC<VariantSelectionModalProps> = ({ phase, isMyTurn, onSelect }) => {
    if (phase !== GamePhase.VariantSelection) return null;

    if (!isMyTurn) {
        return (
            <div className="fixed inset-0 z-[200] flex items-center justify-center bg-black/60 backdrop-blur-sm animate-fadeIn">
                <div className="bg-zinc-900 border border-white/10 p-6 rounded-2xl shadow-2xl flex flex-col items-center">
                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-amber-400 mb-4"></div>
                    <div className="text-white font-tajawal text-lg">Waiting for Buyer to choose Open/Closed...</div>
                </div>
            </div>
        );
    }

    return (
        <div className="fixed inset-0 z-[200] flex items-center justify-center bg-black/80 backdrop-blur-md animate-fadeIn">
            <div className="bg-zinc-900 border border-amber-500/30 p-8 rounded-3xl shadow-2xl flex flex-col items-center max-w-md w-full mx-4">
                <h2 className="text-2xl font-bold text-amber-400 mb-2 font-tajawal">Choose Play Mode</h2>
                <p className="text-zinc-400 text-sm mb-8 text-center">
                    You have been doubled. As the Buyer, you decide: <br />
                    <span className="text-white">Open (Maftuh)</span> or <span className="text-white">Closed (Magfool)</span>?
                </p>

                <div className="flex gap-4 w-full">
                    {/* OPEN */}
                    <button
                        onClick={() => onSelect('OPEN')}
                        className="flex-1 flex flex-col items-center gap-3 bg-zinc-800 hover:bg-zinc-700 p-6 rounded-2xl border border-white/5 transition-all hover:scale-105 active:scale-95 group"
                    >
                        <div className="p-4 bg-emerald-500/20 rounded-full group-hover:bg-emerald-500/30 transition-colors">
                            <Unlock size={32} className="text-emerald-400" />
                        </div>
                        <div className="text-emerald-400 font-bold text-xl">OPEN</div>
                        <div className="text-zinc-500 text-xs">Play any card</div>
                    </button>

                    {/* CLOSED */}
                    <button
                        onClick={() => onSelect('CLOSED')}
                        className="flex-1 flex flex-col items-center gap-3 bg-zinc-800 hover:bg-zinc-700 p-6 rounded-2xl border border-white/5 transition-all hover:scale-105 active:scale-95 group"
                    >
                        <div className="p-4 bg-rose-500/20 rounded-full group-hover:bg-rose-500/30 transition-colors">
                            <Lock size={32} className="text-rose-400" />
                        </div>
                        <div className="text-rose-400 font-bold text-xl">CLOSED</div>
                        <div className="text-zinc-500 text-xs">Restricted Leads</div>
                    </button>
                </div>
            </div>
        </div>
    );
};

export default VariantSelectionModal;

```

### FILE: frontend\src\components\VictoryModal.tsx
```tsx
import React, { useEffect, useRef } from 'react';
import { Trophy, RefreshCw, Home, Eye } from 'lucide-react';

interface VictoryModalProps {
    scores: { us: number; them: number };
    onRematch: () => void;
    onHome: () => void;
    onReview?: () => void;
}

const VictoryModal: React.FC<VictoryModalProps> = ({ scores, onRematch, onHome, onReview }) => {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const isWin = scores.us >= scores.them;

    useEffect(() => {
        if (!isWin) return;

        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const particles: any[] = [];
        const colors = ['#f00', '#0f0', '#00f', '#ff0', '#0ff', '#f0f'];

        for (let i = 0; i < 200; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height - canvas.height,
                vx: Math.random() * 4 - 2,
                vy: Math.random() * 4 + 2,
                color: colors[Math.floor(Math.random() * colors.length)],
                size: Math.random() * 5 + 2
            });
        }

        const animate = () => {
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                if (p.y > canvas.height) p.y = -10;

                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });

            requestAnimationFrame(animate);
        };

        const animId = requestAnimationFrame(animate);
        return () => cancelAnimationFrame(animId);

    }, [isWin]);

    return (
        <div className="absolute inset-0 z-[300] flex items-center justify-center bg-black/95 backdrop-blur-xl animate-in fade-in duration-1000">
            {isWin && <canvas ref={canvasRef} className="absolute inset-0 pointer-events-none" />}

            <div className="relative z-10 text-center flex flex-col items-center">
                <div className={`
                    w-32 h-32 rounded-full flex items-center justify-center mb-6 shadow-[0_0_50px_currentColor]
                    ${isWin ? 'bg-yellow-500/20 text-yellow-500' : 'bg-gray-500/20 text-gray-500'}
                `}>
                    <Trophy size={64} />
                </div>

                <h1 className={`text-6xl font-black mb-2 tracking-tighter uppercase ${isWin ? 'text-yellow-500' : 'text-gray-400'}`}>
                    {isWin ? 'Victory!' : 'Defeat'}
                </h1>

                <p className="text-2xl text-gray-400 mb-8 font-serif tracking-widest">
                    {isWin ? 'The Championship is Yours' : 'Better Luck Next Time'}
                </p>

                <div className="flex items-center gap-12 mb-12 bg-white/5 p-8 rounded-2xl border border-white/10">
                    <div className="text-center">
                        <div className="text-sm text-gray-500 uppercase tracking-widest mb-2">Us</div>
                        <div className={`text-5xl font-bold ${isWin ? 'text-green-500' : 'text-white'}`}>{scores.us}</div>
                    </div>
                    <div className="text-2xl text-gray-600 font-light">vs</div>
                    <div className="text-center">
                        <div className="text-sm text-gray-500 uppercase tracking-widest mb-2">Them</div>
                        <div className={`text-5xl font-bold ${!isWin ? 'text-red-500' : 'text-white'}`}>{scores.them}</div>
                    </div>
                </div>

                <div className="flex gap-4">
                    <button onClick={onHome} className="px-8 py-4 rounded-xl bg-gray-800 hover:bg-gray-700 text-white font-bold flex items-center gap-2 transition-all">
                        <Home size={20} />
                        <span>Main Menu</span>
                    </button>
                    {onReview && (
                        <button onClick={onReview} className="px-8 py-4 rounded-xl bg-gray-600 hover:bg-gray-500 text-white font-bold flex items-center gap-2 transition-all">
                            <Eye size={20} />
                            <span>Review</span>
                        </button>
                    )}
                    <button onClick={onRematch} className="px-8 py-4 rounded-xl bg-white text-black hover:bg-gray-200 font-bold flex items-center gap-2 shadow-[0_0_30px_rgba(255,255,255,0.3)] transition-all">
                        <RefreshCw size={20} />
                        <span>Play Again</span>
                    </button>
                </div>
            </div>
        </div>
    );
};

export default VictoryModal;

```

### FILE: frontend\src\components\VisionaryStudio.tsx (SKIPPED - >10KB)
### FILE: frontend\src\components\VisionaryVerifier.tsx
```tsx

import React, { useState, useEffect, useCallback } from 'react';

interface VisionaryVerifierProps {
    onBack: () => void;
}

export const VisionaryVerifier: React.FC<VisionaryVerifierProps> = ({ onBack }) => {
    const [currentImage, setCurrentImage] = useState<{ filename: string, url: string } | null>(null);
    const [loading, setLoading] = useState(false);
    const [correctionMode, setCorrectionMode] = useState(false);
    const [customLabel, setCustomLabel] = useState("");
    
    // Stats
    const [stats, setStats] = useState({ verified: 0, trash: 0 });

    const fetchNext = useCallback(async () => {
        setLoading(true);
        try {
            const res = await fetch('/api/visionary/verify/next');
            const data = await res.json();
            
            if (data.done) {
                alert("All images verified! Great job.");
                setCurrentImage(null);
            } else if (data.filename) {
                setCurrentImage(data);
                setCustomLabel(""); 
                setCorrectionMode(false);
            }
        } catch (e) {
            console.error(e);
        } finally {
            setLoading(false);
        }
    }, []);

    useEffect(() => {
        fetchNext();
    }, [fetchNext]);

    const submitVerdict = async (verdict: 'valid' | 'invalid' | 'correction', label?: string) => {
        if (!currentImage) return;
        
        // Optimistic UI update could happen here, but we'll wait for sync for safety
        try {
            await fetch('/api/visionary/verify/submit', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    filename: currentImage.filename,
                    verdict,
                    label
                })
            });
            
            // Update stats
            if (verdict === 'invalid') setStats(s => ({ ...s, trash: s.trash + 1 }));
            else setStats(s => ({ ...s, verified: s.verified + 1 }));
            
            fetchNext();
        } catch (e) {
            alert("Error submitting: " + e);
        }
    };

    // Keyboard Shortcuts
    useEffect(() => {
        const handleKey = (e: KeyboardEvent) => {
            if (correctionMode) return; // Disable shortcuts while typing
            
            if (e.key === 'ArrowRight' || e.key === 'y') submitVerdict('valid');
            if (e.key === 'ArrowLeft' || e.key === 'n') submitVerdict('invalid');
            if (e.key === 'ArrowUp' || e.key === 'Enter') setCorrectionMode(true);
        };
        
        window.addEventListener('keydown', handleKey);
        return () => window.removeEventListener('keydown', handleKey);
    }, [currentImage, correctionMode]);

    if (!currentImage && !loading) {
        return (
            <div className="flex flex-col items-center justify-center h-full text-slate-400">
                <div className="text-6xl mb-4">üéâ</div>
                <div className="text-2xl">No more images to verify!</div>
                <button onClick={onBack} className="mt-8 px-6 py-2 bg-white/10 rounded hover:bg-white/20">
                    Back to Studio
                </button>
            </div>
        );
    }

    return (
        <div className="flex flex-col h-full w-full bg-slate-900 text-white font-tajawal p-8 relative">
            {/* Header */}
            <div className="flex items-center justify-between mb-4">
                <div className="flex items-center gap-4">
                    <button onClick={onBack} className="text-2xl hover:scale-110 transition-transform">‚¨ÖÔ∏è</button>
                    <h1 className="text-2xl font-bold text-[#CDA434]">Verification Station</h1>
                </div>
                <div className="flex gap-4 text-sm font-mono bg-black/30 p-2 rounded-lg">
                    <div className="text-green-400">Valid: {stats.verified}</div>
                    <div className="text-red-400">Trash: {stats.trash}</div>
                </div>
            </div>

            {/* Main Card Area */}
            <div className="flex-1 flex flex-col items-center justify-center relative">
                {currentImage ? (
                    <div className="relative group">
                        <img 
                            src={currentImage.url} 
                            className="max-h-[60vh] rounded-xl shadow-2xl border-4 border-white/10" 
                            alt="To Verify"
                        />
                        <div className="absolute top-2 left-2 bg-black/60 px-2 py-1 rounded text-xs font-mono opacity-50 group-hover:opacity-100 transition-opacity">
                            {currentImage.filename}
                        </div>
                    </div>
                ) : (
                    <div className="animate-pulse w-96 h-96 bg-white/5 rounded-xl"></div>
                )}
            </div>

            {/* Controls */}
            <div className="h-32 mt-8 flex flex-col items-center justify-center gap-4">
                {correctionMode ? (
                    <div className="flex gap-2 w-full max-w-md animate-in slide-in-from-bottom-4">
                        <input 
                            autoFocus
                            type="text" 
                            placeholder="Enter Card (e.g. 7S, KD)..."
                            className="flex-1 bg-white/10 border border-white/20 rounded-lg px-4 py-2 text-xl focus:border-[#CDA434] outline-none"
                            value={customLabel}
                            onChange={e => setCustomLabel(e.target.value)}
                            onKeyDown={e => {
                                if (e.key === 'Enter' && customLabel) submitVerdict('correction', customLabel);
                                if (e.key === 'Escape') setCorrectionMode(false);
                            }}
                        />
                        <button 
                            onClick={() => submitVerdict('correction', customLabel)}
                            className="bg-[#CDA434] text-black font-bold px-6 rounded-lg hover:bg-yellow-400"
                        >
                            Save
                        </button>
                    </div>
                ) : (
                    <div className="flex gap-8 items-center">
                        <button 
                            onClick={() => submitVerdict('invalid')}
                            className="flex flex-col items-center gap-2 group"
                        >
                            <div className="w-16 h-16 rounded-full bg-red-500/10 border border-red-500/50 flex items-center justify-center text-3xl group-hover:bg-red-500 group-hover:text-black transition-all">
                                üóëÔ∏è
                            </div>
                            <span className="text-xs text-slate-400 font-mono">TRASH (Left)</span>
                        </button>

                        <button 
                            onClick={() => setCorrectionMode(true)}
                            className="flex flex-col items-center gap-2 group"
                        >
                            <div className="w-12 h-12 rounded-full bg-blue-500/10 border border-blue-500/50 flex items-center justify-center text-xl group-hover:bg-blue-500 group-hover:text-black transition-all">
                                ‚úèÔ∏è
                            </div>
                            <span className="text-xs text-slate-400 font-mono">LABEL (Up)</span>
                        </button>

                        <button 
                            onClick={() => submitVerdict('valid')}
                            className="flex flex-col items-center gap-2 group"
                        >
                            <div className="w-16 h-16 rounded-full bg-green-500/10 border border-green-500/50 flex items-center justify-center text-3xl group-hover:bg-green-500 group-hover:text-black transition-all">
                                ‚úÖ
                            </div>
                            <span className="text-xs text-slate-400 font-mono">VALID (Right)</span>
                        </button>
                    </div>
                )}
            </div>
        </div>
    );
};

```

### FILE: frontend\src\components\Academy\PuzzleArena.tsx
```tsx

import React, { useEffect, useState } from 'react';
import Table from '../Table';
import { API_BASE_URL } from '../../config';
import { GameState, GamePhase } from '../../types';
import { ArrowLeft, CheckCircle, XCircle, RotateCcw, Lightbulb } from 'lucide-react';
import { soundManager } from '../../services/SoundManager';

interface PuzzleArenaProps {
    id: string;
    onBack: () => void;
}

const PuzzleArena: React.FC<PuzzleArenaProps> = ({ id, onBack }) => {

    const [puzzle, setPuzzle] = useState<any>(null);
    const [gameState, setGameState] = useState<GameState | null>(null);
    const [result, setResult] = useState<'PENDING' | 'CORRECT' | 'WRONG'>('PENDING');
    const [feedback, setFeedback] = useState<string>("");
    const [moves, setMoves] = useState<string[]>([]); // Track user moves

    useEffect(() => {
        // Load Puzzle
        fetch(`${API_BASE_URL}/academy/puzzles/${id}`)
            .then(res => res.json())
            .then(data => {
                if (data.puzzle) {
                    setPuzzle(data.puzzle);
                    // Assume initial_state_json is ready for Table
                    const state = data.puzzle.initial_state_json;
                    if (state) {
                        setGameState({
                            ...state,
                            phase: GamePhase.Playing // Ensure active
                        });
                    }
                }
            })
            .catch(err => {
                console.error("Puzzle Fetch Error:", err);
                setFeedback("Failed to load puzzle.");
                setResult('WRONG');
            });
    }, [id]);

    const handleAction = async (action: string, payload: any) => {
        if (result !== 'PENDING') return;

        if (action === 'PLAY') {
            // 1. Update Local UI immediately (Optimistic)
            // We need to simulate the card moving to table?
            // The Table component usually waits for "Server Update" via props.
            // But here we are offline/static.
            // We must manually update 'gameState' to show the card played.

            if (!gameState) return;

            const playerIndex = 0; // Assume Hero is 0
            const card = gameState.players[playerIndex].hand[payload.cardIndex];
            const cardStr = `${card.rank}${card.suit}`;

            // Update moves history
            const newMoves = [...moves, cardStr];
            setMoves(newMoves);

            // Verify with Backend
            try {
                const res = await fetch(`${API_BASE_URL}/academy/verify`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        puzzleId: id,
                        moves: newMoves
                    })
                });
                const check = await res.json();

                if (check.success) {
                    // Mark Correct
                    setResult('CORRECT');
                    setFeedback(check.message);
                    soundManager.playProjectSound();
                } else if (!check.success && check.message.includes("Wrong")) {
                    // Mark Wrong (Only if explicitly wrong, not just 'incomplete')
                    // The current backend simplistic logic says "Wrong move" if mismatch.
                    // If partial match, it says "Good move..."

                    if (check.message.includes("Good move")) {
                        // Allow continue
                        // We need to update State to show card on table
                        // And maybe AI response?
                        // For MVP, single-step puzzles are safest.
                    } else {
                        setResult('WRONG');
                        setFeedback(check.message);
                        soundManager.playErrorSound(); // Fail sound?
                    }
                }

                // Update Visual State (Remove card from hand, add to table)
                const newHand = [...gameState.players[playerIndex].hand];
                newHand.splice(payload.cardIndex, 1);

                const newTable = [...gameState.tableCards, {
                    card: card,
                    playedBy: gameState.players[playerIndex].position
                }];

                setGameState({
                    ...gameState,
                    players: gameState.players.map((p, i) => i === 0 ? { ...p, hand: newHand } : p),
                    tableCards: newTable
                    // Turn logic? for multi-step we need to advance turn.
                });

            } catch (e) {
                console.error(e);
            }
        }
    };

    if (!gameState && result !== 'WRONG') return <div className="bg-slate-950 h-screen flex items-center justify-center text-white">Loading Scenario...</div>;

    return (
        <div className="relative h-screen w-full overflow-hidden bg-slate-950 font-tajawal">
            {/* Overlay UI */}
            <div className="absolute top-4 right-4 z-50">
                <button onClick={onBack} className="bg-black/50 hover:bg-black/70 text-white px-4 py-2 rounded-full flex items-center gap-2 backdrop-blur-md transition-all border border-white/10 uppercase tracking-widest text-xs font-bold">
                    <ArrowLeft size={16} /> Exit
                </button>
            </div>

            {/* Mission Objective */}
            <div className="absolute top-4 left-1/2 -translate-x-1/2 z-50 bg-slate-900/90 text-white px-8 py-4 rounded-2xl border border-amber-500/20 shadow-2xl flex flex-col items-center gap-1 backdrop-blur-xl min-w-[300px]">
                <div className="text-amber-500 text-xs font-bold uppercase tracking-widest">Mission Objective</div>
                <div className="text-lg font-bold">{puzzle?.description || "Solve the puzzle"}</div>
            </div>

            {/* Hint Button */}
            <div className="absolute bottom-8 right-8 z-50">
                <button className="bg-indigo-600 hover:bg-indigo-500 text-white p-4 rounded-full shadow-lg shadow-indigo-600/30 transition-all">
                    <Lightbulb size={24} />
                </button>
            </div>

            {/* Game Table */}
            {gameState && (
                <Table
                    gameState={gameState}
                    onPlayerAction={handleAction}
                    // Disable other interactive elements
                    onChallenge={() => { }}
                    onAddBot={() => { }}
                    onDebugAction={() => { }}
                    isCuttingDeck={false}
                    onFastForward={() => { }}
                    onEmoteClick={() => { }}
                />
            )}

            {/* Feedback Overlay */}
            {result !== 'PENDING' && (
                <div className="absolute inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm animate-in fade-in duration-300">
                    <div className="bg-slate-900 border border-white/10 p-8 rounded-3xl max-w-lg w-full text-center shadow-2xl relative overflow-hidden">
                        {/* Background Glow */}
                        <div className={`absolute inset-0 opacity-20 ${result === 'CORRECT' ? 'bg-green-500' : 'bg-red-500'}`} />

                        <div className="relative z-10">
                            {result === 'CORRECT' ? (
                                <CheckCircle size={80} className="mx-auto text-green-400 mb-6 drop-shadow-[0_0_15px_rgba(74,222,128,0.5)]" />
                            ) : (
                                <XCircle size={80} className="mx-auto text-red-400 mb-6 drop-shadow-[0_0_15px_rgba(248,113,113,0.5)]" />
                            )}

                            <h2 className="text-4xl font-black mb-2 text-white">
                                {result === 'CORRECT' ? 'Excellent!' : 'Incorrect'}
                            </h2>
                            <p className="text-white/60 mb-6">{result === 'CORRECT' ? "You found the optimal line." : "That's not quite right."}</p>

                            <div className="bg-black/30 p-4 rounded-xl text-white text-lg mb-8 border border-white/5">
                                {feedback}
                            </div>

                            <div className="flex gap-4 justify-center">
                                <button onClick={() => window.location.reload()} className="px-8 py-3 bg-white/10 hover:bg-white/20 text-white rounded-xl font-bold flex items-center gap-2 transition-colors">
                                    <RotateCcw size={20} /> Retry
                                </button>
                                {result === 'CORRECT' && (
                                    <button onClick={onBack} className="px-8 py-3 bg-amber-500 hover:bg-amber-400 text-black rounded-xl font-bold shadow-lg shadow-amber-500/20 transition-all flex items-center gap-2">
                                        Next Lesson <ArrowLeft size={20} />
                                    </button>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
};

export default PuzzleArena;

```

### FILE: frontend\src\components\ai-studio\ActionSelector.tsx
```tsx
import React from 'react';
import { GamePhase } from '../../types';

interface ActionSelectorProps {
    phase: GamePhase;
    hand: any[]; // We'll type this loosely for now as it comes from JSON
    currentSelection: string | null; // JSON string of selected action
    onSelect: (actionJson: string) => void;
}

const ActionSelector: React.FC<ActionSelectorProps> = ({ phase, hand, currentSelection, onSelect }) => {

    // Helper to check if selection matches
    const isSelected = (actionJson: string) => currentSelection === actionJson;
    const isSunSelected = currentSelection?.includes("SUN");

    if (phase === GamePhase.Bidding) {
        return (
            <div className="grid grid-cols-2 gap-2">
                <button onClick={() => onSelect(JSON.stringify({ action: "PASS" }))} className={`p-2 rounded border ${currentSelection?.includes("PASS") ? 'bg-slate-600 border-green-500' : 'bg-slate-800 border-slate-600 hover:bg-slate-700'}`}>Pass</button>
                <button onClick={() => onSelect(JSON.stringify({ action: "ASHKEL" }))} className={`p-2 rounded border ${currentSelection?.includes("ASHKEL") ? 'bg-red-900/50 border-red-500' : 'bg-slate-800 border-slate-600 hover:bg-red-900/30'}`}>Ashkel</button>
                <button onClick={() => onSelect(JSON.stringify({ action: "SUN" }))} className={`p-2 rounded border col-span-2 ${currentSelection?.includes("SUN") ? 'bg-yellow-600/50 border-yellow-500' : 'bg-slate-800 border-slate-600 hover:bg-yellow-600/30'}`}>Sun ‚òÄÔ∏è</button>
                {['S', 'H', 'D', 'C'].map(s => (
                    <button key={s} onClick={() => onSelect(JSON.stringify({ action: "HOKUM", suit: s }))} className={`p-2 rounded border text-xl ${currentSelection?.includes(s) && currentSelection?.includes("HOKUM") ? 'bg-slate-600 border-blue-500' : 'bg-slate-800 border-slate-600 hover:bg-slate-700'}`}>
                        <span className={['H', 'D'].includes(s) ? 'text-red-500' : 'text-white'}>{{ S: '‚ô†', H: '‚ô•', D: '‚ô¶', C: '‚ô£' }[s] as any}</span>
                    </button>
                ))}
            </div>
        );
    } else {
        return (
            <div className="grid grid-cols-4 gap-1">
                {hand.map((c: any, idx: number) => {
                    // Normalize play action structure
                    // The Studio saves { action: "PLAY_CARD", card: c }
                    const actionJson = JSON.stringify({ action: "PLAY_CARD", card: c });
                    const selected = isSelected(actionJson);
                    return (
                        <button
                            key={idx}
                            onClick={() => onSelect(actionJson)}
                            className={`p-1 rounded border text-sm h-12 flex items-center justify-center font-bold relative group
                                ${selected ? 'bg-green-600 border-green-400 text-white shadow' : 'bg-white text-black border-slate-400 opacity-90 hover:opacity-100 hover:-translate-y-1 transition-transform'}
                            `}
                        >
                            <span className={['H', 'D'].includes(c.suit) ? 'text-red-600' : 'text-black'}>
                                {c.rank}
                                <span className="text-xs ml-0.5">{{ S: '‚ô†', H: '‚ô•', D: '‚ô¶', C: '‚ô£' }[c.suit] as any}</span>
                            </span>
                        </button>
                    );
                })}
            </div>
        );
    }
};

export default ActionSelector;

```

### FILE: frontend\src\components\ai-studio\BiddingLabView.tsx (SKIPPED - >10KB)
### FILE: frontend\src\components\ai-studio\BrainMemoryView.tsx
```tsx
import { Brain, RefreshCw, X, ArrowLeft, Code, Database } from 'lucide-react';
import React, { useState, useEffect } from 'react';
import { getBrainMemory, deleteBrainMemory } from '../../services/trainingService';

interface BrainMemoryViewProps {
    onBack: () => void;
}

const BrainMemoryView: React.FC<BrainMemoryViewProps> = ({ onBack }) => {
    const [brainMemory, setBrainMemory] = useState<any[]>([]);
    const [loading, setLoading] = useState(false);
    const [showJson, setShowJson] = useState(false);

    useEffect(() => {
        loadBrainMemory();
    }, []);

    const loadBrainMemory = async () => {
        setLoading(true);
        const res = await getBrainMemory();
        if (res.memory) {
            setBrainMemory(res.memory);
        }
        setLoading(false);
    };

    const handleDeleteMemory = async (hash: string) => {
        if (!confirm("Forget this move?")) return;
        await deleteBrainMemory(hash);
        loadBrainMemory();
    };

    const getSuitSymbol = (suit: string) => {
        const symbols: Record<string, string> = { S: '‚ô†', H: '‚ô•', D: '‚ô¶', C: '‚ô£' };
        return symbols[suit] || suit;
    };

    return (
        <div className="flex flex-col h-full w-full bg-slate-900 text-white font-tajawal p-6 overflow-hidden">
            <div className="flex items-center justify-between mb-6 shrink-0">
                <div className="flex items-center gap-4">
                    <button onClick={onBack} className="p-2 bg-slate-800 rounded-full hover:bg-slate-700">
                        <ArrowLeft size={24} />
                    </button>
                    <div>
                        <h1 className="text-3xl font-bold bg-gradient-to-r from-indigo-500 to-purple-600 bg-clip-text text-transparent flex items-center gap-2">
                            <Brain /> ÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑÿ®Ÿàÿ™
                        </h1>
                        <p className="text-slate-400">ÿßŸÑÿ≠ÿ±ŸÉÿßÿ™ ÿßŸÑÿ™Ÿä ÿ™ÿπŸÑŸÖŸáÿß ÿßŸÑÿ®Ÿàÿ™ ŸÖŸÜ ÿßŸÑÿ™ÿµÿ≠Ÿäÿ≠ÿßÿ™ ÿßŸÑÿ≥ÿßÿ®ŸÇÿ©</p>
                    </div>
                </div>
                <div className="flex gap-2">
                    <button
                        onClick={() => setShowJson(!showJson)}
                        className={`flex items-center gap-2 px-3 py-2 rounded border transition-colors ${showJson ? 'bg-indigo-600 border-indigo-400 text-white' : 'bg-slate-800 border-slate-600 text-slate-400 hover:text-white'}`}
                        title="Show Raw Data"
                    >
                        <Code size={18} />
                        <span className="hidden sm:inline">{showJson ? 'ÿ•ÿÆŸÅÿßÿ° ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™' : 'ÿπÿ±ÿ∂ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™'}</span>
                    </button>
                    <button onClick={loadBrainMemory} className="p-2 bg-slate-800 rounded hover:bg-slate-700 border border-slate-600">
                        <RefreshCw size={20} className={loading ? "animate-spin" : ""} />
                    </button>
                </div>
            </div>

            <div className="flex-1 overflow-auto bg-slate-800/30 rounded-xl border border-slate-700 p-6">
                {brainMemory.length === 0 ? (
                    <div className="flex flex-col items-center justify-center h-full text-slate-500">
                        <Brain size={64} className="mb-4 opacity-50" />
                        <p className="text-xl">ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ≠ÿ±ŸÉÿßÿ™ ŸÖÿ≠ŸÅŸàÿ∏ÿ© ŸÅŸä ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©</p>
                    </div>
                ) : (
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        {brainMemory.map((mem) => (
                            <div key={mem.hash} className="bg-slate-800 p-5 rounded-xl border border-slate-600 shadow-lg group hover:border-indigo-500 transition-colors relative flex flex-col">
                                <div className="flex justify-between items-start mb-3">
                                    <div className="bg-slate-900 px-2 py-1 rounded text-xs font-mono text-slate-500 select-all border border-slate-700 flex items-center gap-1">
                                        <Database size={12} />
                                        {mem.hash.substring(0, 12)}...
                                    </div>
                                    <button
                                        onClick={() => handleDeleteMemory(mem.hash)}
                                        className="text-slate-600 hover:text-red-400 hover:bg-red-900/20 p-1.5 rounded transition-colors opacity-0 group-hover:opacity-100"
                                        title="Delete Memory"
                                    >
                                        <X size={16} />
                                    </button>
                                </div>

                                {showJson ? (
                                    <div className="flex-1 bg-slate-950 p-3 rounded-lg border border-slate-700 font-mono text-[10px] text-indigo-300 overflow-auto max-h-48">
                                        <pre>{JSON.stringify(mem.data, null, 2)}</pre>
                                    </div>
                                ) : (
                                    <>
                                        <div className="mb-4">
                                            <div className="text-xs text-slate-400 mb-1 uppercase tracking-wider font-bold">Learned Action</div>
                                            <div className="flex items-center gap-2">
                                                <span className={`px-3 py-1 rounded text-sm font-bold border ${mem.data.action === 'PASS' ? 'bg-slate-700 border-slate-500 text-white' : 'bg-green-900/50 border-green-500 text-green-300'}`}>
                                                    {mem.data.action}
                                                </span>
                                                {mem.data.card && (
                                                    <span className={`px-3 py-1 rounded text-sm font-bold bg-white text-black border border-slate-300 flex items-center gap-1 ${['H', 'D'].includes(mem.data.card.suit) ? 'text-red-600' : ''}`}>
                                                        {mem.data.card.rank}<span>{getSuitSymbol(mem.data.card.suit)}</span>
                                                    </span>
                                                )}
                                                {mem.data.suit && (
                                                    <span className={`text-2xl ${['H', 'D'].includes(mem.data.suit) ? 'text-red-500' : 'text-slate-200'}`}>
                                                        {getSuitSymbol(mem.data.suit)}
                                                    </span>
                                                )}
                                            </div>
                                        </div>

                                        <div className="bg-slate-900/50 p-3 rounded-lg border border-slate-700/50 flex-1">
                                            <div className="text-xs text-slate-500 mb-1 flex items-center gap-1"><Brain size={12} /> Reasoning</div>
                                            <p className="text-sm text-slate-300 italic">
                                                "{mem.data.reason || 'No reasoning stored'}"
                                            </p>
                                        </div>
                                    </>
                                )}
                            </div>
                        ))}
                    </div>
                )}
            </div>
        </div>
    );
};

export default BrainMemoryView;

```

### FILE: frontend\src\components\ai-studio\BuilderView.tsx (SKIPPED - >10KB)
### FILE: frontend\src\components\ai-studio\ReportsListView.tsx
```tsx
import React, { useState } from 'react';
import { RefreshCw, CheckCircle, Layers } from 'lucide-react';

interface ReportsListViewProps {
    examples: any[];
    loading: boolean;
    onLoadData: () => void;
    onDuplicate: (example: any) => void;
}

const ReportsListView: React.FC<ReportsListViewProps> = ({ examples, loading, onLoadData, onDuplicate }) => {
    const [selectedExample, setSelectedExample] = useState<any>(null);

    return (
        <div className="flex flex-col lg:flex-row flex-1 gap-6 overflow-hidden overflow-y-auto lg:overflow-y-hidden">
            {/* List */}
            <div className="w-full lg:w-1/3 bg-slate-800 rounded-xl p-4 overflow-y-auto border border-slate-700 order-2 lg:order-1">
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-xl font-bold text-slate-300">ÿ≥ÿ¨ŸÑ ÿßŸÑÿ™ÿµÿ≠Ÿäÿ≠ÿßÿ™ ({examples.length})</h2>
                    <button onClick={onLoadData} className="p-2 bg-slate-700 rounded hover:bg-slate-600"><RefreshCw size={16} /></button>
                </div>
                <div className="flex flex-col gap-3">
                    {loading ? <p>ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...</p> : examples.map((ex, idx) => (
                        <div
                            key={idx}
                            onClick={() => setSelectedExample(ex)}
                            className={`p-4 rounded-lg cursor-pointer transition-all border ${selectedExample === ex ? 'bg-slate-700 border-yellow-500' : 'bg-slate-900/50 border-slate-700 hover:bg-slate-700'}`}
                        >
                            <div className="flex justify-between mb-2">
                                <span className="text-xs text-slate-500">{new Date(ex.created_on).toLocaleString()}</span>
                                <span className="text-xs px-2 py-0.5 bg-blue-900 text-blue-200 rounded-full">
                                    {ex.contextHash?.startsWith('scen-') ? 'Scenario' : 'Report'}
                                </span>
                            </div>
                            <div className="flex items-center justify-between">
                                <div className="text-green-400 font-bold">{JSON.parse(ex.correct_move_json || '"{}"').action || ex.correct_move_json}</div>
                            </div>
                            <div className="text-xs text-slate-400 mt-2 truncate">{ex.reason}</div>
                        </div>
                    ))}
                </div>
            </div>

            {/* Detail View */}
            <div className="flex-1 bg-slate-800 rounded-xl p-6 border border-slate-700 flex flex-col items-center justify-center overflow-auto order-1 lg:order-2">
                {selectedExample ? (
                    <div className="w-full max-w-2xl">
                        <h2 className="text-2xl font-bold mb-6 text-center border-b border-slate-700 pb-4">ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿ≠ÿßŸÑÿ©</h2>

                        <div className="grid grid-cols-2 gap-8 mb-8">
                            <div className="bg-red-900/20 p-6 rounded-xl border border-red-900/50 text-center">
                                <div className="text-red-400 text-sm mb-2">ŸÇÿ±ÿßÿ± ÿßŸÑÿ®Ÿàÿ™</div>
                                <div className="text-xl font-bold text-red-200 truncate">{selectedExample.bad_move_json}</div>
                            </div>
                            <div className="bg-green-900/20 p-6 rounded-xl border border-green-900/50 text-center">
                                <div className="text-green-400 text-sm mb-2">ÿßŸÑÿ≠ŸÑ ÿßŸÑÿµÿ≠Ÿäÿ≠</div>
                                <div className="text-xl font-bold text-green-200 truncate">{selectedExample.correct_move_json}</div>
                            </div>
                        </div>

                        <div className="bg-slate-900 p-6 rounded-xl mb-6">
                            <h3 className="text-sm text-slate-400 mb-2">ÿßŸÑÿ≥ÿ®ÿ® / ÿßŸÑÿ¥ÿ±ÿ≠</h3>
                            <p className="text-lg leading-relaxed">{selectedExample.reason}</p>
                        </div>

                        {selectedExample.contextHash?.startsWith('scen-') && (
                            <div className="bg-blue-900/20 border border-blue-500/30 p-4 rounded-lg text-center text-blue-300 mb-4 bg-red">
                                <div className="mb-2">‚ÑπÔ∏è This is a manually created scenario.</div>
                                <button
                                    onClick={() => onDuplicate(selectedExample)}
                                    className="px-4 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded font-bold flex items-center gap-2 mx-auto"
                                >
                                    <Layers size={16} /> Edit / Duplicate
                                </button>
                            </div>
                        )}
                    </div>
                ) : (
                    <div className="text-center text-slate-500">
                        <CheckCircle size={64} className="mx-auto mb-4 opacity-20" />
                        <p className="text-xl">ÿßÿÆÿ™ÿ± ÿ≠ÿßŸÑÿ© ŸÑÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ</p>
                    </div>
                )}
            </div>
        </div>
    );
};

export default ReportsListView;

```

### FILE: frontend\src\components\ai-studio\TrainingView.tsx
```tsx
import React, { useState } from 'react';
import { Trophy, GraduationCap, Play, CheckCircle, X } from 'lucide-react';
import { getTrainingData } from '../../services/trainingService';
import ScenarioTable from '../ScenarioTable';
import ActionSelector from './ActionSelector';

interface TrainingViewProps {
    scenarioState: any;
    setScenarioState: (state: any) => void;
}

const TrainingView: React.FC<TrainingViewProps> = ({ scenarioState, setScenarioState }) => {

    const [trainingPuzzle, setTrainingPuzzle] = useState<any>(null);
    const [puzzleResult, setPuzzleResult] = useState<'PENDING' | 'CORRECT' | 'INCORRECT'>('PENDING');
    const [puzzleScore, setPuzzleScore] = useState(0);
    const [loading, setLoading] = useState(false);

    const startTraining = async () => {
        setLoading(true);
        const res = await getTrainingData();
        if (res.data && res.data.length > 0) {
            const valid = res.data.filter((e: any) => e.correct_move_json && e.game_state_json);
            if (valid.length > 0) {
                pickRandomPuzzle(valid);
            } else {
                alert("No valid puzzles found. Create some in Builder first!");
            }
        } else {
            alert("No training data found. Please go to Scenario Builder and save some scenarios first!");
        }
        setLoading(false);
    };

    const pickRandomPuzzle = (pool: any[]) => {
        const random = pool[Math.floor(Math.random() * pool.length)];
        try {
            const state = JSON.parse(random.game_state_json);
            setTrainingPuzzle({
                ...random,
                parsedState: state,
                parsedAnswer: JSON.parse(random.correct_move_json)
            });
            setScenarioState(state);
            setPuzzleResult('PENDING');
        } catch (e) {
            console.error("Bad puzzle data", e);
            pickRandomPuzzle(pool);
        }
    };

    const submitPuzzleAnswer = (actionJson: string) => {
        if (puzzleResult !== 'PENDING') return;

        const answer = JSON.parse(actionJson);
        const correct = trainingPuzzle.parsedAnswer;

        let isCorrect = false;
        if (answer.action === correct.action) {
            if (answer.action === 'PLAY_CARD' || answer.action === 'PLAY') {
                const c1 = answer.card || answer;
                const c2 = correct.card || correct;
                if (c1.rank === c2.rank && c1.suit === c2.suit) isCorrect = true;
            } else if (answer.action === 'HOKUM') {
                if (answer.suit === correct.suit) isCorrect = true;
            } else {
                isCorrect = true;
            }
        }

        if (isCorrect) {
            setPuzzleResult('CORRECT');
            setPuzzleScore(s => s + 10);
        } else {
            setPuzzleResult('INCORRECT');
            setPuzzleScore(s => Math.max(0, s - 5));
        }
    };

    return (
        <div className="flex flex-col lg:flex-row flex-1 gap-6 overflow-hidden overflow-y-auto lg:overflow-y-hidden">
            {/* Left: Score & Controls */}
            <div className="w-full lg:w-1/4 shrink-0 bg-slate-800 rounded-xl p-4 overflow-y-auto border border-slate-700 flex flex-col gap-6 order-2 lg:order-1">

                <div className="bg-slate-900 rounded-lg p-4 text-center borderBorder-slate-700 shadow-inner">
                    <div className="text-sm text-slate-400 mb-1 flex items-center justify-center gap-2"><Trophy size={14} /> Session Score</div>
                    <div className="text-4xl font-bold text-yellow-500">{puzzleScore}</div>
                </div>

                {!trainingPuzzle ? (
                    <div className="flex flex-col items-center justify-center flex-1 text-center py-10">
                        <GraduationCap size={48} className="text-green-500 mb-4 opacity-80" />
                        <h3 className="text-xl font-bold text-white mb-2">Ready to Train?</h3>
                        <p className="text-sm text-slate-400 mb-6">Solve verified scenarios to improve your Baloot skills.</p>
                        <button
                            onClick={startTraining}
                            disabled={loading}
                            className="px-6 py-3 bg-green-600 hover:bg-green-500 text-white rounded-full font-bold flex items-center gap-2 transition-transform hover:scale-105"
                        >
                            <Play size={20} fill="currentColor" /> {loading ? "Loading..." : "Start Puzzles"}
                        </button>
                    </div>
                ) : (
                    <div className="flex flex-col gap-6 animate-in fade-in">
                        <div className="border border-green-500/30 rounded-lg p-3 bg-green-900/10">
                            <div className="flex justify-between text-xs text-green-400 uppercase font-bold mb-1">
                                <span>Goal</span>
                                <span>{scenarioState.mode === 'HOKUM' ? 'Hokum' : 'Sun'}</span>
                            </div>
                            <div className="text-lg text-white font-bold">
                                find the best move!
                            </div>
                        </div>

                        {/* Puzzle Area */}
                        <div>
                            <h3 className="text-sm text-slate-400 mb-3 border-b border-slate-700 pb-1">Your Hand (Select Action)</h3>
                            <div className={puzzleResult !== 'PENDING' ? 'pointer-events-none opacity-50' : ''}>
                                <ActionSelector
                                    phase={scenarioState.phase}
                                    hand={scenarioState.players[0].hand}
                                    currentSelection={null}
                                    onSelect={submitPuzzleAnswer}
                                />
                            </div>
                        </div>

                        {/* Result Overlay */}
                        {puzzleResult !== 'PENDING' && (
                            <div className={`p-4 rounded-xl border-2 animate-in zoom-in-95 duration-300 ${puzzleResult === 'CORRECT' ? 'bg-green-900/50 border-green-500' : 'bg-red-900/50 border-red-500'}`}>
                                <div className="flex items-center gap-3 mb-2">
                                    {puzzleResult === 'CORRECT' ? <CheckCircle className="text-green-400" size={32} /> : <X className="text-red-400" size={32} />}
                                    <div>
                                        <div className={`text-xl font-bold ${puzzleResult === 'CORRECT' ? 'text-green-300' : 'text-red-300'}`}>
                                            {puzzleResult === 'CORRECT' ? 'Excellent!' : 'Incorrect'}
                                        </div>
                                        <div className="text-xs text-white/70">
                                            {puzzleResult === 'CORRECT' ? 'You found the best move.' : 'That is not the optimal play.'}
                                        </div>
                                    </div>
                                </div>

                                <div className="bg-black/30 p-3 rounded text-sm text-slate-200 mt-2">
                                    <span className="font-bold text-slate-400 block text-xs mb-1">WHY?</span>
                                    {trainingPuzzle.reason}
                                </div>

                                <button
                                    onClick={startTraining} // Fetch next
                                    className="w-full mt-4 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded font-bold"
                                >
                                    Next Puzzle ‚Üí
                                </button>
                            </div>
                        )}
                    </div>
                )}
            </div>

            {/* Right: Board */}
            <div className="flex-1 bg-black/50 rounded-xl border border-slate-700 p-4 flex items-center justify-center overflow-auto relative order-1 lg:order-2 min-h-[400px]">
                {trainingPuzzle ? (
                    <div className="w-full max-w-[800px] pointer-events-none scale-75 sm:scale-90 md:scale-100 origin-center">
                        <ScenarioTable
                            scenarioState={scenarioState}
                            onUpdateState={() => { }} // No-op
                        />
                    </div>
                ) : (
                    <div className="text-slate-600 flex flex-col items-center">
                        <GraduationCap size={64} className="mb-4 opacity-50" />
                        <p>Select a puzzle to start</p>
                    </div>
                )}
            </div>
        </div>
    );
};

export default TrainingView;

```

### FILE: frontend\src\components\analytics\BlunderGraph.tsx
```tsx
import React from 'react';
import {
    BarChart,
    Bar,
    XAxis,
    YAxis,
    CartesianGrid,
    Tooltip,
    ResponsiveContainer,
    Cell
} from 'recharts';
import { Flame } from 'lucide-react';

interface BlunderGraphProps {
    data: { [key: string]: number }; // Map "Bottom": 2, "Top": 5 etc
}

export const BlunderGraph: React.FC<BlunderGraphProps> = ({ data }) => {
    // Transform Map to Array for Recharts
    // Ensure all positions are represented 
    const positions = ['Bottom', 'Right', 'Top', 'Left'];
    const chartData = positions.map(pos => ({
        name: pos,
        count: data[pos] || 0
    }));

    const totalBlunders = Object.values(data).reduce((a: number, b: number) => a + b, 0);

    if (totalBlunders === 0) {
        return (
            <div className="w-full h-full flex flex-col items-center justify-center text-white/50 text-sm">
                <Flame size={24} className="mb-2 text-white/20" />
                <span>Clean Game (So Far)</span>
            </div>
        );
    }

    return (
        <div className="w-full h-full p-4 bg-slate-900/90 rounded-xl border border-white/10 backdrop-blur-md shadow-2xl flex flex-col">
            <div className="flex items-center justify-between mb-2">
                <h3 className="text-red-500 font-bold text-sm flex items-center gap-2">
                    <Flame size={14} /> Blunder Heatmap
                </h3>
                <span className="text-xs text-white/60">Total: {totalBlunders}</span>
            </div>

            <div className="flex-1 min-h-0">
                <ResponsiveContainer width="100%" height="100%">
                    <BarChart data={chartData} layout="vertical">
                        <CartesianGrid strokeDasharray="3 3" stroke="#444" horizontal={false} />
                        <XAxis type="number" hide />
                        <YAxis
                            dataKey="name"
                            type="category"
                            width={50}
                            tick={{ fill: '#ccc', fontSize: 11 }}
                            axisLine={false}
                            tickLine={false}
                        />
                        <Tooltip
                            cursor={{ fill: 'transparent' }}
                            contentStyle={{ backgroundColor: '#1e293b', borderColor: '#ef4444', color: '#fff' }}
                            itemStyle={{ color: '#fca5a5' }}
                            labelStyle={{ display: 'none' }}
                            formatter={(value: any) => [`${value} Blunders`]}
                        />
                        <Bar dataKey="count" radius={[0, 4, 4, 0]}>
                            {chartData.map((entry, index) => (
                                <Cell key={`cell-${index}`} fill={entry.name === 'Bottom' ? '#ef4444' : '#64748b'} />
                            ))}
                        </Bar>
                    </BarChart>
                </ResponsiveContainer>
            </div>
        </div>
    );
};

```

### FILE: frontend\src\components\analytics\WinProbabilityGraph.tsx
```tsx
import React from 'react';
import {
    LineChart,
    Line,
    XAxis,
    YAxis,
    CartesianGrid,
    Tooltip,
    ResponsiveContainer,
    ReferenceLine
} from 'recharts';
import { Trophy } from 'lucide-react';

interface WinProbabilityGraphProps {
    data: { trick: number; us: number }[];
}

export const WinProbabilityGraph: React.FC<WinProbabilityGraphProps> = ({ data }) => {
    // Filter valid data points
    const chartData = data.map(d => ({
        name: `Trick ${d.trick}`,
        prob: (d.us * 100).toFixed(1), // Convert to percentage
        raw: d.us
    }));

    if (chartData.length === 0) {
        return (
            <div className="w-full h-full flex items-center justify-center text-white/50 text-sm">
                No Data Yet
            </div>
        );
    }

    return (
        <div className="w-full h-full p-4 bg-slate-900/90 rounded-xl border border-white/10 backdrop-blur-md shadow-2xl flex flex-col">
            <div className="flex items-center justify-between mb-2">
                <h3 className="text-yellow-500 font-bold text-sm flex items-center gap-2">
                    <Trophy size={14} /> Win Probability
                </h3>
                <span className="text-xs text-white/60">Live Heuristic</span>
            </div>

            <div className="flex-1 min-h-0">
                <ResponsiveContainer width="100%" height="100%">
                    <LineChart data={chartData}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#444" vertical={false} />
                        <XAxis
                            dataKey="name"
                            hide={true}
                        />
                        <YAxis
                            domain={[0, 100]}
                            hide={false}
                            stroke="#888"
                            tick={{ fontSize: 10 }}
                            width={30}
                        />
                        <ReferenceLine y={50} stroke="#666" strokeDasharray="5 5" />
                        <Tooltip
                            contentStyle={{ backgroundColor: '#1e293b', borderColor: '#d97706', color: '#fff' }}
                            itemStyle={{ color: '#fbbf24' }}
                            labelStyle={{ display: 'none' }}
                            formatter={(value: any) => [`${value}%`, 'Win Chance']}
                        />
                        <Line
                            type="monotone"
                            dataKey="prob"
                            stroke="#fbbf24"
                            strokeWidth={3}
                            dot={{ r: 3, fill: '#fbbf24' }}
                            activeDot={{ r: 6, stroke: '#fff' }}
                            animationDuration={500}
                        />
                    </LineChart>
                </ResponsiveContainer>
            </div>
        </div>
    );
};

```

### FILE: frontend\src\components\effects\HeartbeatLayer.tsx
```tsx

import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { TensionLevel } from '../../hooks/useGameTension';

interface HeartbeatLayerProps {
    tension: TensionLevel;
    bpm: number;
}

export const HeartbeatLayer: React.FC<HeartbeatLayerProps> = ({ tension, bpm }) => {
    if (tension === 'low' || bpm === 0) return null;

    // Pulse duration in seconds (60 / bpm)
    const duration = 60 / bpm;

    // Determine intensity (opacity/color) based on tension
    let opacity = 0;
    let color = 'rgba(255, 0, 0, 0)'; // Transparent

    switch (tension) {
        case 'medium':
            opacity = 0.1;
            color = 'radial-gradient(circle, transparent 60%, rgba(200, 50, 50, 0.2) 100%)';
            break;
        case 'high':
            opacity = 0.2;
            color = 'radial-gradient(circle, transparent 50%, rgba(220, 0, 0, 0.4) 100%)';
            break;
        case 'critical':
            opacity = 0.3;
            color = 'radial-gradient(circle, transparent 40%, rgba(255, 0, 0, 0.6) 100%)';
            break;
    }

    return (
        <AnimatePresence>
            <motion.div
                className="pointer-events-none fixed inset-0 z-0"
                initial={{ opacity: 0 }}
                animate={{
                    opacity: [0, opacity, 0], // Pulse
                }}
                transition={{
                    duration: duration,
                    repeat: Infinity,
                    ease: "easeInOut"
                }}
                style={{
                    background: color,
                    mixBlendMode: 'multiply'
                }}
            />
        </AnimatePresence>
    );
};

```

### FILE: frontend\src\components\overlays\ForensicOverlay.tsx (SKIPPED - >10KB)
### FILE: frontend\src\components\overlays\MindMapOverlay.tsx
```tsx

import React, { useEffect, useState } from 'react';
import { X, Brain } from 'lucide-react';
import MindMapCity from '../visualizations/MindMapCity';

interface MindMapOverlayProps {
    gameId: string;
    players: any[];
    isOpen: boolean;
    onClose: () => void;
}

export default function MindMapOverlay({ gameId, players, isOpen, onClose }: MindMapOverlayProps) {
    const [mindMap, setMindMap] = useState<any>(null);
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        if (!isOpen || !gameId) return;

        const fetchMindMap = async () => {
            try {
                // Use relative path or config
                const res = await fetch(`http://localhost:8000/api/mind/inference/${gameId}`);
                if (res.ok) {
                    const data = await res.json();
                    setMindMap(data.mind_map);
                }
            } catch (err) {
                console.error("Failed to fetch mind map", err);
            }
        };

        // Initial fetch
        fetchMindMap();

        // Poll every 1s
        const interval = setInterval(fetchMindMap, 1000);
        return () => clearInterval(interval);
    }, [isOpen, gameId]);

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur-sm animate-in fade-in duration-200">
            {/* Header */}
            <div className="absolute top-4 left-4 right-4 flex justify-between items-center z-50 pointer-events-none">
                <div className="flex items-center gap-2 bg-black/50 p-2 rounded-lg pointer-events-auto">
                    <Brain className="w-6 h-6 text-purple-400" />
                    <div>
                        <h2 className="text-xl font-bold text-white">Neural Mind Map</h2>
                        <p className="text-xs text-gray-400">Real-time Probability Inference (Theory of Mind)</p>
                    </div>
                </div>

                <button
                    onClick={onClose}
                    className="p-2 bg-white/10 hover:bg-white/20 rounded-full text-white transition-colors pointer-events-auto"
                >
                    <X className="w-6 h-6" />
                </button>
            </div>

            {/* 3D Scene */}
            <div className="w-full h-full">
                <MindMapCity mindMap={mindMap} players={players} />
            </div>

            {/* Legend */}
            <div className="absolute bottom-8 left-1/2 -translate-x-1/2 bg-black/60 px-6 py-3 rounded-full flex gap-6 text-sm text-white pointer-events-none">
                <div className="flex items-center gap-2">
                    <div className="w-3 h-3 rounded-full bg-blue-500"></div>
                    <span>Unlikely</span>
                </div>
                <div className="flex items-center gap-2">
                    <div className="w-3 h-3 rounded-full bg-purple-500"></div>
                    <span>Possible</span>
                </div>
                <div className="flex items-center gap-2">
                    <div className="w-3 h-3 rounded-full bg-red-500"></div>
                    <span>Certain</span>
                </div>
            </div>
        </div>
    );
}

```

### FILE: frontend\src\components\overlays\ProfessorOverlay.tsx
```tsx
import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { GraduationCap, AlertTriangle, Play, RotateCcw } from 'lucide-react';
import { GhostCardLayer } from '../GhostCardLayer';
import { CardModel as CardType } from '../../types';
import Card from '../Card';

interface InterventionData {
    type: 'BLUNDER' | 'MISTAKE';
    message: string;
    better_card: CardType;
    reason: string;
    diff: number;
    candidates?: any[]; // Added for Holographic Thought
}

interface ProfessorOverlayProps {
    intervention: InterventionData | null;
    onUndo: () => void;
    onInsist: () => void;
}

export const ProfessorOverlay: React.FC<ProfessorOverlayProps> = ({ intervention, onUndo, onInsist }) => {
    if (!intervention) return null;

    return (
        <AnimatePresence>
            <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/60 backdrop-blur-sm">
                <motion.div
                    initial={{ opacity: 0, scale: 0.9, y: 20 }}
                    animate={{ opacity: 1, scale: 1, y: 0 }}
                    exit={{ opacity: 0, scale: 0.9, y: 20 }}
                    className="w-[500px] bg-slate-900 border-2 border-yellow-500/50 rounded-2xl shadow-2xl overflow-hidden flex flex-col"
                >
                    {/* Header */}
                    <div className="bg-gradient-to-r from-yellow-600 to-yellow-800 p-4 flex items-center gap-3">
                        <div className="p-2 bg-white/10 rounded-full">
                            <GraduationCap size={28} className="text-white" />
                        </div>
                        <div>
                            <h2 className="text-xl font-bold text-white leading-none">The Professor</h2>
                            <span className="text-yellow-200 text-xs font-medium tracking-wide">AI COACHING INTERVENTION</span>
                        </div>
                    </div>

                    {/* Content */}
                    <div className="p-6 flex flex-col items-center text-center">
                        <div className="mb-6 bg-red-500/10 border border-red-500/30 rounded-lg p-3 w-full flex items-start gap-3 text-left">
                            <AlertTriangle className="text-red-400 shrink-0 mt-0.5" size={20} />
                            <div>
                                <h3 className="text-red-400 font-bold text-sm uppercase mb-1">{intervention.type} DETECTED</h3>
                                <p className="text-slate-300 text-sm leading-relaxed">
                                    {intervention.message}
                                </p>
                            </div>
                        </div>

                        <div className="w-full flex justify-center mb-8">
                            {intervention.candidates && intervention.candidates.length > 0 ? (
                                <div className="flex flex-col items-center w-full">
                                    <span className="text-xs text-slate-400 mb-2 uppercase tracking-wider">Analysis: Top Candidates</span>
                                    <GhostCardLayer candidates={intervention.candidates} />

                                    <div className="mt-4 flex flex-col items-center text-center max-w-sm">
                                        <span className="text-sm font-semibold text-green-400 mb-1">Coach's Insight:</span>
                                        <p className="text-xs text-slate-400 leading-relaxed">
                                            {intervention.reason}
                                        </p>
                                    </div>
                                </div>
                            ) : (
                                <div className="flex items-center gap-8">
                                    <div className="flex flex-col items-center">
                                        <span className="text-xs text-slate-400 mb-2 uppercase tracking-wider">Better Move</span>
                                        <div className="scale-125 origin-center">
                                            <Card
                                                card={intervention.better_card}
                                                isPlayable={false}
                                                height={120} // Standard height
                                            />
                                        </div>
                                    </div>

                                    <div className="flex flex-col items-start text-left max-w-[200px]">
                                        <span className="text-sm font-semibold text-green-400 mb-1">Why it's better:</span>
                                        <p className="text-xs text-slate-400 leading-relaxed">
                                            {intervention.reason}
                                        </p>
                                        <div className="mt-2 text-xs font-mono text-slate-500">
                                            EV Diff: +{(intervention.diff * 100).toFixed(1)}%
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* Actions */}
                        <div className="flex gap-4 w-full">
                            <button
                                onClick={onUndo}
                                className="flex-1 flex items-center justify-center gap-2 py-3 rounded-xl bg-slate-700 hover:bg-slate-600 text-white font-semibold transition-all border border-slate-600"
                            >
                                <RotateCcw size={18} />
                                Reconsider
                            </button>
                            <button
                                onClick={onInsist}
                                className="flex-1 flex items-center justify-center gap-2 py-3 rounded-xl bg-red-600/20 hover:bg-red-600/30 text-red-200 hover:text-white font-semibold transition-all border border-red-500/30 hover:border-red-500"
                            >
                                <Play size={18} />
                                I Insist (Play it)
                            </button>
                        </div>
                    </div>
                </motion.div>
            </div>
        </AnimatePresence>
    );
};

```

### FILE: frontend\src\components\overlays\QaydOverlay.tsx (SKIPPED - >10KB)
### FILE: frontend\src\components\overlays\WarRoomOverlay.tsx
```tsx
import React, { useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Trophy, ShieldAlert, LineChart as ChartIcon } from 'lucide-react';
import { WinProbabilityGraph } from '../analytics/WinProbabilityGraph';
import { BlunderGraph } from '../analytics/BlunderGraph';
import { GameState } from '../../types';

interface WarRoomOverlayProps {
    gameState: GameState;
    showAnalytics: boolean;
    setShowAnalytics: (show: boolean) => void;
}

export const WarRoomOverlay: React.FC<WarRoomOverlayProps> = ({ gameState, showAnalytics, setShowAnalytics }) => {
    const [analyticsView, setAnalyticsView] = useState<'WIN' | 'BLUNDER'>('WIN');

    return (
        <>
            {/* Analytics Toggle (War Room) */}
            <button
                onClick={() => setShowAnalytics(!showAnalytics)}
                className={`absolute top-4 left-44 z-50 p-1.5 rounded-full border transition-all shadow-lg ${showAnalytics ? 'bg-yellow-500/80 border-yellow-300 text-white' : 'bg-white/20 border-white/30 text-white hover:bg-white/40'}`}
                title="Toggle War Room"
            >
                <ChartIcon size={18} />
            </button>

            {/* Analytics Overlay */}
            <AnimatePresence>
                {showAnalytics && gameState.analytics && (
                    <motion.div
                        initial={{ opacity: 0, y: -20, scale: 0.9 }}
                        animate={{ opacity: 1, y: 0, scale: 1 }}
                        exit={{ opacity: 0, y: -20, scale: 0.9 }}
                        className="absolute top-16 left-4 z-[60] w-64 h-48 sm:w-80 sm:h-60 pointer-events-none"
                    >
                        <div className="w-full h-full pointer-events-auto relative group">
                            {/* Toggle View on Click (or small button) */}
                            <div className="absolute top-2 right-2 z-10 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                <button onClick={() => setAnalyticsView('WIN')} className={`p-1 rounded ${analyticsView === 'WIN' ? 'bg-yellow-500 text-white' : 'bg-slate-700 text-slate-400'}`}>
                                    <Trophy size={12} />
                                </button>
                                <button onClick={() => setAnalyticsView('BLUNDER')} className={`p-1 rounded ${analyticsView === 'BLUNDER' ? 'bg-red-500 text-white' : 'bg-slate-700 text-slate-400'}`}>
                                    <ShieldAlert size={12} />
                                </button>
                            </div>

                            {analyticsView === 'WIN' ? (
                                <WinProbabilityGraph data={gameState.analytics.winProbability} />
                            ) : (
                                <BlunderGraph data={gameState.analytics.blunders || {}} />
                            )}
                        </div>
                    </motion.div>
                )}
            </AnimatePresence>
        </>
    );
};

```

### FILE: frontend\src\components\table\ContractIndicator.tsx
```tsx
import React from 'react';
import { Player, PlayerPosition, Suit } from '../../types';
import { Sun, Gavel } from 'lucide-react';
import { Spade, Heart, Club, Diamond } from '../SuitIcons';

interface ContractIndicatorProps {
    bid: any;
    players: Player[];
    doublingLevel: number;
}

const ContractIndicator = ({ bid, players, doublingLevel }: ContractIndicatorProps) => {
    if (!bid || !bid.type) return null;
    const isDoubled = doublingLevel >= 2;
    const bidder = players.find(p => p.position === bid.bidder);
    if (!bidder) return null;
    const isOurTeam = bidder.position === PlayerPosition.Bottom || bidder.position === PlayerPosition.Top;
    const teamBg = isOurTeam ? 'bg-blue-600' : 'bg-red-600';

    return (
        <div className={`${teamBg} rounded-full shadow-xl px-2 py-0.5 border-2 border-white/20 backdrop-blur-sm flex items-center gap-1`}>
            <span className="text-[9px] sm:text-[10px] font-bold text-white">{bidder.name}</span>
            <div className="flex items-center gap-1 bg-white/20 rounded-full px-1 py-0.5">
                {bid.type === 'SUN' ? <Sun size={10} className="text-amber-300" /> : <Gavel size={10} className="text-white" />}
                <span className="text-[9px] font-black text-white uppercase">{bid.type}</span>
            </div>
            {bid.suit && (
                <div className="bg-white/20 rounded-full p-0.5">
                    {bid.suit === Suit.Spades && <Spade size={10} className="text-white" />}
                    {bid.suit === Suit.Hearts && <Heart size={10} className="text-red-300" />}
                    {bid.suit === Suit.Clubs && <Club size={10} className="text-green-300" />}
                    {bid.suit === Suit.Diamonds && <Diamond size={10} className="text-blue-300" />}
                </div>
            )}
            {isDoubled && (
                <div className="bg-red-600 text-white text-[8px] font-black px-1 py-0 rounded-full border border-white/20 shadow-lg animate-pulse">
                    x{doublingLevel}
                </div>
            )}
        </div>
    );
};

export default ContractIndicator;

```

### FILE: frontend\src\components\table\PlayerAvatar.tsx
```tsx
import React from 'react';
import { Player, PlayerPosition, Suit } from '../../types';
import { Sun, Gavel, Trophy, Spade, Heart, Club, Diamond, Megaphone } from 'lucide-react';
// Correct import paths assuming this file is in frontend/components/table/
import { SpeechBubble } from '../SpeechBubble';
import TurnTimer from './TurnTimer';

// Avatar Mapping moved here as it is specific to PlayerAvatar logic
const AVATAR_MAP: Record<string, string> = {
    'avatar_saad': 'https://api.dicebear.com/7.x/avataaars/svg?seed=Saad&backgroundColor=b6e3f4',
    'avatar_khalid': 'https://api.dicebear.com/7.x/avataaars/svg?seed=Khalid&backgroundColor=c0aede&clothing=blazerAndShirt',
    'avatar_abu_fahad': 'https://api.dicebear.com/7.x/avataaars/svg?seed=AbuFahad&backgroundColor=ffdfbf&facialHair=beardMajestic',
    'bot_1': 'https://api.dicebear.com/7.x/bottts/svg?seed=Bot1'
};

interface PlayerAvatarProps {
    player: Player;
    isCurrentTurn: boolean;
    position: 'top' | 'left' | 'right' | 'bottom';
    timeLeft: number;
    totalTime: number;
    declarations: any;
    isProjectRevealing: boolean;
    showProjects: boolean;
    bid?: any;
    doublingLevel?: number;
    speechText?: string | null;
    isPaused?: boolean;
    akkaState?: any;
}

const PlayerAvatar = ({
    player,
    isCurrentTurn,
    position,
    timeLeft,
    totalTime,
    declarations,
    isProjectRevealing,
    showProjects,
    bid,
    doublingLevel,
    speechText,
    isPaused,
    akkaState
}: PlayerAvatarProps) => {
    const isPartner = position === 'top';
    let posClass = 'absolute z-30';
    // Adjusted: Less negative offset on mobile to prevent clipping
    if (position === 'left') posClass += ' top-1/2 -translate-y-1/2 left-1 sm:-left-[5rem] md:-left-[5.5rem]';
    else if (position === 'right') posClass += ' top-1/2 -translate-y-1/2 right-1 sm:-right-[5rem] md:-right-[5.5rem]';
    else if (position === 'top') posClass += ' top-1 sm:top-2 left-1/2 -translate-x-1/2';
    else if (position === 'bottom') posClass += ' bottom-14 left-1/2 -translate-x-1/2 z-[200]'; // Lifted slightly


    return (
        <div className={`flex flex-col items-center ${posClass} `}>

            {/* Speech Bubble integration */}
            <SpeechBubble
                text={speechText || null}
                isVisible={!!speechText}
                position={position === 'top' ? 'bottom' : position === 'bottom' ? 'top' : position === 'left' ? 'right' : 'left'}
            />

            <div className="relative">
                {/* Timer rendered for all positions now */}
                <TurnTimer isActive={isCurrentTurn} timeLeft={timeLeft} totalTime={totalTime} isPaused={isPaused} />

                {/* Dark Overlay for Active Player to boost Timer contrast */}
                {isCurrentTurn && (
                    <div className="absolute inset-0 z-40 bg-black/60 rounded-full animate-in fade-in duration-300"></div>
                )}


                <div className={`
w-[1.7rem] h-[1.7rem] sm:w-[2.0rem] sm:h-[2.0rem] md:w-[2.35rem] md:h-[2.35rem]
rounded-full bg-white shadow-xl overflow-hidden relative z-10
                    ${isCurrentTurn ? 'halo-active' : ''}
                    ${isPartner ? 'border-2 border-[var(--color-premium-gold)]' : 'border-2 border-white/80'}
`}>
                    <img
                        src={player.avatar && player.avatar.startsWith('http') ? player.avatar : (AVATAR_MAP[player.avatar] || player.avatar)}
                        className="w-full h-full object-cover"
                        alt={player.name}
                        onError={(e) => {
                            // Fallback if image fails or is missing
                            (e.target as HTMLImageElement).src = `https://api.dicebear.com/7.x/initials/svg?seed=${player.name}`;
                        }}
                    />
                </div>
            </div>
            {
                player.isDealer && (
                    <div className="absolute -bottom-2 right-1/2 translate-x-1/2 bg-[var(--color-premium-gold)] border border-white/50 rounded-md px-1.5 py-0.5 flex items-center justify-center z-40 shadow-sm">
                        <span className="text-[8px] font-black text-black leading-none">Dealer</span>
                    </div>
                )
            }
            {
                !isPartner && (
                    <div className={`
                    bg-black/80 text-white px-2 sm:px-3 py-0.5 sm:py-1 rounded-full text-[10px] sm:text-xs font-bold 
                    -mt-2 sm:-mt-3 z-20 mb-1
                    ${position === 'bottom' ? '-order-1 mb-0 -mt-0 -mb-2' : ''}
                    ${isPartner ? 'border border-amber-500/50' : 'border border-white/20'}
                    ${isCurrentTurn ? 'bg-amber-600/90' : ''}
                `}>
                        {player.name}
                    </div>
                )
            }
            {
                player.actionText && (
                    <div key={player.actionText} className="absolute -top-4 -right-10 bg-white/90 text-black px-2 py-1 rounded-lg rounded-bl-none shadow-md border border-gray-200 z-50 whitespace-nowrap animate-in fade-in zoom-in duration-200">
                        <span className="text-[10px] sm:text-xs font-bold">{player.actionText === 'PASS' ? 'ÿ®ÿ≥' : player.actionText}</span>
                    </div>
                )
            }

            {/* Winning Bid Tag - Rendered BELOW the avatar */}
            {
                bid && bid.bidder === player.position && (
                    <div className={`
                    absolute -bottom-5 left-1/2 -translate-x-1/2 
                    flex items-center gap-1 px-3 py-0.5 rounded-full shadow-lg z-50
                    animate-in fade-in slide-in-from-top-2 duration-500
                    ${(player.position === PlayerPosition.Bottom || player.position === PlayerPosition.Top) ? 'bg-blue-600' : 'bg-red-600'}
                    border border-white/30
                 `}>
                        {/* Simplified: No Name, just Icon + Text */}
                        {bid.type === 'SUN' ? <Sun size={12} className="text-amber-300" /> : <Gavel size={12} className="text-white" />}

                        <span className="text-[10px] sm:text-xs font-black text-white uppercase tracking-wider">
                            {bid.type}
                        </span>

                        {/* Suit Icon if applicable */}
                        {bid.suit && (
                            <div className="bg-white/20 rounded-full p-0.5 ml-1">
                                {bid.suit === Suit.Spades && <Spade size={10} className="text-white" />}
                                {bid.suit === Suit.Hearts && <Heart size={10} className="text-red-300" />}
                                {bid.suit === Suit.Clubs && <Club size={10} className="text-green-300" />}
                                {bid.suit === Suit.Diamonds && <Diamond size={10} className="text-blue-300" />}
                            </div>
                        )}
                        {/* Multiplier Badge */}
                        {(doublingLevel && doublingLevel >= 2) && (
                            <div className="bg-red-500 text-white text-[9px] font-black px-1.5 rounded-full ml-1 animate-pulse border border-white/20">
                                x{doublingLevel}
                            </div>
                        )}
                    </div>
                )
            }
            {
                showProjects && declarations?.[player.position] && declarations[player.position].length > 0 && (
                    <div className="absolute top-10 left-1/2 -translate-x-1/2 w-max flex flex-col items-center gap-1 z-50 animate-bounce-in">
                        {declarations[player.position].map((proj: any, idx: number) => {
                            let label = '';
                            switch (proj.type) {
                                case 'SIRA': label = 'ÿ≥ÿ±ÿß'; break;
                                case 'FIFTY': label = '50'; break;
                                case 'HUNDRED': label = '100'; break;
                                case 'FOUR_HUNDRED': label = '400'; break;
                                case 'BALOOT': label = 'ÿ®ŸÑŸàÿ™'; break;
                            }
                            return (
                                <div key={idx} className="bg-gradient-to-r from-amber-300 to-yellow-500 text-black font-black text-xs sm:text-sm px-3 py-1 rounded-full shadow-lg border border-white flex items-center gap-1">
                                    <Trophy size={14} className="text-amber-800" />
                                    <span>{label}</span>
                                </div>
                            );
                        })}
                    </div>
                )
            }
            {/* AKKA BADGE */}
            {
                akkaState && akkaState.claimer === player.position && (
                    <div className="absolute top-16 left-1/2 -translate-x-1/2 w-max bg-rose-600 text-white font-black text-xs sm:text-sm px-3 py-1 rounded-full shadow-lg border border-white flex items-center gap-1 z-50 animate-pulse">
                        <Megaphone size={14} className="text-white" />
                        <span>ÿ£ŸÉÿ©!</span>
                    </div>
                )
            }
        </div>
    );
};

export default PlayerAvatar;

```

### FILE: frontend\src\components\table\ScoreBadge.tsx
```tsx
import React from 'react';

interface ScoreBadgeProps {
    matchScores: { us: number, them: number };
}

const ScoreBadge = ({ matchScores }: ScoreBadgeProps) => {
    if (!matchScores) return null;
    return (
        <div className="absolute top-4 left-4 z-50 flex gap-3">
            {/* Us Score */}
            <div className="bg-gradient-to-br from-blue-600 to-blue-800 rounded-2xl px-2 py-0.5 shadow-xl border-2 border-white/20 backdrop-blur-sm">
                <div className="text-[9px] text-white/80 font-bold">ŸÜÿ≠ŸÜ</div>
                <div className="text-[15px] font-black text-white">{matchScores.us}</div>
            </div>
            {/* Them Score */}
            <div className="bg-gradient-to-br from-red-600 to-red-800 rounded-2xl px-2 py-0.5 shadow-xl border-2 border-white/20 backdrop-blur-sm">
                <div className="text-[9px] text-white/80 font-bold">ŸáŸÖ</div>
                <div className="text-[15px] font-black text-white">{matchScores.them}</div>
            </div>
        </div>
    );
};

export default ScoreBadge;

```

### FILE: frontend\src\components\table\TurnTimer.tsx
```tsx
import React from 'react';
import { Pause } from 'lucide-react';

interface TurnTimerProps {
    isActive: boolean;
    timeLeft: number;
    totalTime: number;
    isPaused?: boolean;
}

const TurnTimer = ({ isActive, timeLeft, totalTime, isPaused = false }: TurnTimerProps) => {
    if (!isActive) return null;

    const radius = 36;
    const stroke = 6;
    const circumference = 2 * Math.PI * radius;
    const percentage = timeLeft / totalTime;
    const progress = percentage * circumference;

    let strokeColor = '#22c55e'; // Green
    if (percentage < 0.25) strokeColor = '#ef4444'; // Red
    else if (percentage < 0.5) strokeColor = '#D4AF37'; // Gold

    return (
        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[84px] h-[84px] pointer-events-none z-50 flex items-center justify-center">
            <svg
                className="-rotate-90 absolute inset-0"
                width="84" height="84"
                viewBox="0 0 84 84"
            >
                <circle cx="42" cy="42" r={radius} stroke="rgba(0,0,0,0.4)" strokeWidth={stroke} fill="none" />
                <circle
                    cx="42" cy="42" r={radius}
                    stroke={strokeColor}
                    strokeWidth={stroke}
                    strokeLinecap="round"
                    fill="none"
                    strokeDasharray={circumference}
                    strokeDashoffset={circumference - progress}
                    className={`transition-all duration-1000 ease-linear shadow-lg ${isPaused ? 'pause-animation' : ''}`}
                    style={{ filter: 'drop-shadow(0 0 2px rgba(0,0,0,0.5))' }}
                />
            </svg>
            <span className="text-amber-400 font-black text-sm sm:text-base md:text-lg drop-shadow-md z-50">
                {timeLeft}
            </span>
            {isPaused && <Pause size={20} className="absolute text-white animate-pulse" />}
        </div>
    );
};

export default TurnTimer;

```

### FILE: frontend\src\components\visualizations\MindMapCity.tsx
```tsx

import React, { useMemo, useRef } from 'react';
import { Canvas, useFrame } from '@react-three/fiber';
import { OrbitControls, Text, Float, Stars, Environment } from '@react-three/drei';
import * as THREE from 'three';
import { interpolate } from 'maath/easing';

// Props:
// mindMap: { playerIdx: { cardIndex (0-31): probability (0-1) } }
// we need to map playerIdx to positions (Left, Top, Right) relative to bottom (0).

const CARD_NAMES = [
    "7S", "8S", "9S", "QS", "KS", "10S", "AS", "JS",
    "7H", "8H", "9H", "QH", "KH", "10H", "AH", "JH",
    "7C", "8C", "9C", "QC", "KC", "10C", "AC", "JC",
    "7D", "8D", "9D", "QD", "KD", "10D", "AD", "JD"
];

// Suits for coloring base
const SUIT_COLORS = {
    'S': '#1a1a1a', // Black
    'H': '#e53935', // Red
    'C': '#2e7d32', // Green
    'D': '#fbc02d'  // Yellow/Orange
};

function ProbabilityBar({ position, probability, label, index }) {
    const mesh = useRef();
    const lightRef = useRef();

    // Animate height
    useFrame((state, delta) => {
        if (!mesh.current) return;

        // Target scale: max height 5 units
        const targetHeight = Math.max(0.1, probability * 5);

        // Smoothly interpolate scale.y
        // mesh.current.scale.y = THREE.MathUtils.lerp(mesh.current.scale.y, targetHeight, delta * 3);
        // Using maath for better easing if installed, or simple lerp
        mesh.current.scale.y = THREE.MathUtils.damp(mesh.current.scale.y, targetHeight, 4, delta);

        // Position correction: scale grows from center, so we need to move y up
        mesh.current.position.y = mesh.current.scale.y / 2;

        // Color interpolation: Blue (Low) -> Red (High)
        // low: #2196f3, high: #ff0000
        const color = new THREE.Color().lerpColors(
            new THREE.Color('#2196f3'),
            new THREE.Color('#ff0000'),
            probability
        );
        mesh.current.material.color = color;

        // Light intensity based on probability
        if (lightRef.current) {
            lightRef.current.intensity = probability * 2;
            lightRef.current.color = color;
        }
    });

    return (
        <group position={position}>
            {/* The Bar */}
            <mesh ref={mesh} position={[0, 0.5, 0]}>
                <boxGeometry args={[0.2, 1, 0.2]} />
                <meshStandardMaterial roughnes={0.3} metalness={0.8} />
            </mesh>

            {/* Base Glow */}
            <pointLight ref={lightRef} position={[0, 0.2, 0]} distance={1} decay={2} />

            {/* Label (Only show if probability > 10% or if hovering) */}
            {probability > 0.1 && (
                <Text
                    position={[0, -0.3, 0]}
                    fontSize={0.15}
                    color="white"
                    anchorX="center"
                    anchorY="middle"
                >
                    {label}
                </Text>
            )}

            {/* Value Label (Top) */}
            {probability > 0.01 && (
                <Text
                    position={[0, probability * 5 + 0.3, 0]}
                    fontSize={0.12}
                    color="#ffd700"
                    anchorX="center"
                    anchorY="middle"
                >
                    {(probability * 100).toFixed(0)}%
                </Text>
            )}
        </group>
    );
}

function PlayerCity({ position, rotation, handData, playerName }) {
    // Layout indices 0-31 in a grid or line
    // Let's do 4 rows of 8 (Suits)

    const rows = [];
    for (let s = 0; s < 4; s++) { // Suits
        for (let r = 0; r < 8; r++) { // Ranks
            const idx = s * 8 + r;
            const prob = handData ? (handData[idx] || 0) : 0;
            const label = CARD_NAMES[idx];

            // X: Rank (spread out)
            // Z: Suit (depth)
            const x = (r - 3.5) * 0.4;
            const z = (s - 1.5) * 0.4;

            rows.push(
                <ProbabilityBar
                    key={idx}
                    position={[x, 0, z]}
                    probability={prob}
                    label={label}
                    index={idx}
                />
            );
        }
    }

    return (
        <group position={position} rotation={rotation}>
            <Float speed={2} rotationIntensity={0.1} floatIntensity={0.2}>
                <Text position={[0, 3, 0]} fontSize={0.5} color="#4fc3f7">
                    {playerName}
                </Text>
                <group position={[0, 0, 0]}>
                    {rows}
                </group>
                {/* Platform */}
                <mesh position={[0, -0.1, 0]} rotation={[-Math.PI / 2, 0, 0]}>
                    <planeGeometry args={[4, 2]} />
                    <meshStandardMaterial color="#333" transparent opacity={0.5} />
                    <lineSegments>
                        <edgesGeometry args={[new THREE.PlaneGeometry(4, 2)]} />
                        <lineBasicMaterial color="#4fc3f7" />
                    </lineSegments>
                </mesh>
            </Float>
        </group>
    );
}

export default function MindMapCity({ mindMap, players }) {
    // mindMap: { 1: [probs...], 2: [probs...], 3: [probs...] }
    // players: Array of player objects to get names. 
    // Usually User is 0. 
    // Right is 1. Top is 2. Left is 3.

    return (
        <div style={{ width: '100%', height: '100%', background: '#000' }}>
            <Canvas camera={{ position: [0, 6, 8], fov: 45 }}>
                <color attach="background" args={['#050510']} />
                <fog attach="fog" args={['#050510', 5, 20]} />

                <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade speed={1} />
                <ambientLight intensity={0.5} />
                <spotLight position={[10, 10, 10]} angle={0.15} penumbra={1} intensity={1} castShadow />
                <pointLight position={[-10, -10, -10]} intensity={0.5} color="blue" />

                <group position={[0, -1, 0]}>
                    {/* Right Player (Index 1) */}
                    <PlayerCity
                        position={[4, 0, 0]}
                        rotation={[0, -Math.PI / 4, 0]}
                        handData={mindMap && mindMap[1]}
                        playerName={players && players[1] ? players[1].name : "Right"}
                    />

                    {/* Top Player (Index 2 - Partner) */}
                    <PlayerCity
                        position={[0, 0, -3]}
                        rotation={[0, 0, 0]}
                        handData={mindMap && mindMap[2]}
                        playerName={players && players[2] ? players[2].name : "Top"}
                    />

                    {/* Left Player (Index 3) */}
                    <PlayerCity
                        position={[-4, 0, 0]}
                        rotation={[0, Math.PI / 4, 0]}
                        handData={mindMap && mindMap[3]}
                        playerName={players && players[3] ? players[3].name : "Left"}
                    />
                </group>

                <OrbitControls
                    enablePan={true}
                    enableZoom={true}
                    maxPolarAngle={Math.PI / 2 - 0.1}
                    autoRotate={true}
                    autoRotateSpeed={0.5}
                />
            </Canvas>
        </div>
    );
}

```

### FILE: frontend\src\components\__tests__\Table.test.tsx
```tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import Table from '../Table';
import { GameState, GamePhase, PlayerPosition, Suit, Player, Rank } from '../../types';

// Mock dependencies
vi.mock('../../services/SoundManager', () => ({
    soundManager: {
        playDealSequence: vi.fn(),
        playProjectSound: vi.fn(),
        playAkkaSound: vi.fn(),
        playCardSound: vi.fn(),
    }
}));

// Mock devLogger to avoid console spam or errors
vi.mock('../../utils/devLogger', () => ({
    devLogger: {
        log: vi.fn(),
    }
}));

// Mock child components to simplify testing the Table logic itself
// We want to test that Table renders them and passes props, not test the children themselves.
vi.mock('../CardVector', () => ({
    default: ({ card, onClick, className }: any) => (
        <div
            data-testid={`card-${card.rank}-${card.suit}`}
            onClick={onClick}
            className={className}
        >
            {card.rank}{card.suit}
        </div>
    )
}));

vi.mock('../table/PlayerAvatar', () => ({
    default: ({ player }: any) => (
        <div data-testid="player-avatar">
            {player.name}
            <img alt={player.name} />
        </div>
    )
}));

vi.mock('../table/TurnTimer', () => ({
    default: () => <div data-testid="turn-timer" />
}));

vi.mock('../table/ScoreBadge', () => ({
    default: () => <div data-testid="score-badge" />
}));

vi.mock('../table/ContractIndicator', () => ({
    default: () => <div data-testid="contract-indicator" />
}));

// Mock DevLogSidebar to prevent its useEffect from crashing due to missing devLogger.getHistory
vi.mock('../DevLogSidebar', () => ({
    DevLogSidebar: () => <div data-testid="dev-log-sidebar" />
}));

vi.mock('../ActionBar', () => ({
    default: () => <div data-testid="action-bar" />
}));

vi.mock('../GablakTimer', () => ({
    default: () => <div data-testid="gablak-timer" />
}));

vi.mock('../../utils/gameLogic', () => ({
    sortHand: (hand: any) => hand,
    canDeclareAkka: () => false
}));

// Helper to create a dummy player
const createPlayer = (index: number, position: PlayerPosition, name: string): Player => ({
    index,
    name,
    position,
    avatar: 'avatar.png',
    hand: [],
    score: 0,
    isDealer: false,
    isActive: false,
    actionText: '',
    lastReasoning: ''
});

// Helper to create a basic game state
const createGameState = (): any => ({
    gameMode: 'SUN',
    phase: GamePhase.Playing,
    players: [
        createPlayer(0, PlayerPosition.Bottom, 'Me'),
        createPlayer(1, PlayerPosition.Right, 'Right'),
        createPlayer(2, PlayerPosition.Top, 'Partner'),
        createPlayer(3, PlayerPosition.Left, 'Left'),
    ],
    currentTurnIndex: 0,
    deck: [],
    tableCards: [],
    declarations: {},
    matchScores: { us: 0, them: 0 },
    teamScores: { us: 0, them: 0 },
    roundHistory: [],
    floorCard: null,
    dealerIndex: 0,
    isLocked: false,
    biddingPhase: 'SUN_OR_HOKUM',
    biddingRound: 1,
    doublingLevel: 1,
    bid: { type: 'SUN', bidder: PlayerPosition.Bottom, suit: null, doubled: false },
    settings: {
        turnDuration: 30,
        fourColorMode: false,
        highContrastMode: false,
        cardLanguage: 'EN',
        strictMode: true,
        soundEnabled: true,
        gameSpeed: 'NORMAL'
    }
});


describe('Table Component', () => {
    let mockGameState: GameState;
    const mockOnPlayerAction = vi.fn();

    beforeEach(() => {
        vi.clearAllMocks();
        mockGameState = createGameState();
        // Give "Me" some cards
        mockGameState.players[0].hand = [
            { rank: Rank.Ace, suit: Suit.Hearts, id: 'Ah', value: 10 },
            { rank: Rank.King, suit: Suit.Spades, id: 'Ks', value: 4 }
        ];
    });

    it('renders loading state when players are missing', () => {
        // @ts-ignore
        render(<Table gameState={{ players: [] } as any} onPlayerAction={mockOnPlayerAction} />);
        expect(screen.getByText(/Loading Game Table/i)).toBeInTheDocument();
    });

    it('renders the game table with players properly', () => {
        render(<Table gameState={mockGameState} onPlayerAction={mockOnPlayerAction} />);

        // Check for player names
        expect(screen.getByText('Me')).toBeInTheDocument();
        expect(screen.getByText('Right')).toBeInTheDocument();
        // Partner name is hidden in UI, so we check the avatar alt text
        expect(screen.getByAltText('Partner')).toBeInTheDocument();
        expect(screen.getByText('Left')).toBeInTheDocument();
    });

    it('renders my hand cards', () => {
        render(<Table gameState={mockGameState} onPlayerAction={mockOnPlayerAction} />);

        // Based on our mock Card, we look for text content
        expect(screen.getByText('A‚ô•')).toBeInTheDocument();
        expect(screen.getByText('K‚ô†')).toBeInTheDocument();
    });

    it('allows selecting a card on first click', () => {
        render(<Table gameState={mockGameState} onPlayerAction={mockOnPlayerAction} />);

        const aceCard = screen.getByTestId('card-A-‚ô•');

        // Click once to select
        fireEvent.click(aceCard);

        expect(mockOnPlayerAction).not.toHaveBeenCalled();
    });

    it('plays a card on second click (double click behavior)', () => {
        render(<Table gameState={mockGameState} onPlayerAction={mockOnPlayerAction} />);

        const aceCard = screen.getByTestId('card-A-‚ô•');

        // First click: Select
        fireEvent.click(aceCard);

        // Second click: Play
        fireEvent.click(aceCard);

        expect(mockOnPlayerAction).toHaveBeenCalledWith('PLAY', { cardIndex: 0 });
    });

    it('prevents playing invalid card in strict mode', () => {
        // Setup: Table has a Spades card led.
        mockGameState.tableCards = [
            { card: { rank: Rank.Ten, suit: Suit.Spades, id: '10s', value: 10 }, playedBy: PlayerPosition.Left }
        ];
        // Me has Hearts and Spades. Must play Spades.
        mockGameState.players[0].hand = [
            { rank: Rank.Ace, suit: Suit.Hearts, id: 'Ah', value: 11 },
            { rank: Rank.King, suit: Suit.Spades, id: 'Ks', value: 4 }
        ];

        render(<Table gameState={mockGameState} onPlayerAction={mockOnPlayerAction} />);

        // Try to play Hearts (Invalid)
        const aceHearts = screen.getByTestId('card-A-‚ô•');
        fireEvent.click(aceHearts); // Select
        fireEvent.click(aceHearts); // Try Play

        expect(mockOnPlayerAction).not.toHaveBeenCalled();

        // Try to play Spades (Valid)
        const kingSpades = screen.getByTestId('card-K-‚ô†');
        fireEvent.click(kingSpades); // Select
        fireEvent.click(kingSpades); // Play

        expect(mockOnPlayerAction).toHaveBeenCalledWith('PLAY', { cardIndex: 1 });
    });
});

```

### FILE: frontend\src\hooks\useGameRules.ts
```ts

import { useMemo } from 'react';
import { GameState, Player, GamePhase, CardModel, ProjectType } from '../types';
import { detectProjects, sortHand, isValidMove } from '../utils/gameLogic';

export const useGameRules = (
    gameState: GameState,
    me: Player | undefined
) => {
    // 1. Projects Scanning
    const availableProjects = useMemo(() => {
        if (
            gameState.phase === GamePhase.Playing &&
            gameState.currentTurnIndex === 0 &&
            me?.hand &&
            me.hand.length === 8
        ) {
            const projects = detectProjects(me.hand, me.position, gameState.trumpSuit);
            // Return unique types
            return Array.from(new Set(projects.map(p => p.type)));
        }
        return [];
    }, [gameState.phase, gameState.currentTurnIndex, me?.hand, gameState.trumpSuit, me?.position]);

    // 2. Card Validation
    // NOTE: validation is PERMISSIVE to allow Qayd (Cheating/Mistakes) to occur.
    // If we enforced strict rules here, users couldn't make illegal moves.
    const isCardPlayable = (card: CardModel) => {
        if (gameState.phase !== GamePhase.Playing) return false;
        if (gameState.currentTurnIndex !== me?.index) return false;
        return true;
    };

    // Helper to check if a move IS checking rules (for UI warnings maybe)
    const checkMoveLegality = (card: CardModel) => {
        return isValidMove(
            card,
            me?.hand || [],
            gameState.tableCards || [],
            (gameState.gameMode as 'SUN' | 'HOKUM') || 'SUN',
            gameState.trumpSuit || null,
            gameState.isLocked,
            true
        );
    }

    // 3. Sorted Hand
    const sortedHand = useMemo(() => {
        if (!me?.hand) return [];
        return sortHand(me.hand, (gameState.gameMode as 'SUN' | 'HOKUM') || 'SUN', gameState.trumpSuit);
    }, [me?.hand, gameState.gameMode, gameState.trumpSuit]);

    return {
        availableProjects,
        isCardPlayable,
        checkMoveLegality,
        sortedHand
    };
};

```

### FILE: frontend\src\hooks\useGameState.ts (SKIPPED - >10KB)
### FILE: frontend\src\hooks\useGameTension.ts
```ts

import { useState, useEffect } from 'react';
import { GameState } from '../types';

export type TensionLevel = 'low' | 'medium' | 'high' | 'critical';

export const useGameTension = (gameState: GameState | null) => {
    const [tension, setTension] = useState<TensionLevel>('low');
    const [bpm, setBpm] = useState(0); // 0 means no heartbeat

    useEffect(() => {
        if (!gameState) return;

        let level: TensionLevel = 'low';
        let newBpm = 0;

        if (!gameState.matchScores) return;

        const scoreUs = gameState.matchScores.us;
        const scoreThem = gameState.matchScores.them;
        const maxScore = Math.max(scoreUs, scoreThem);
        const diff = Math.abs(scoreUs - scoreThem);

        // 1. Critical: Endgame (Score > 145)
        if (maxScore >= 145) {
            level = 'critical';
            newBpm = 100; // Fast pounding
        }
        // 2. High: Late game (Score > 100) and Close (Diff < 20)
        else if (maxScore > 100 && diff < 20) {
            level = 'high';
            newBpm = 80;
        }
        // 3. Medium: Doubling is active or Sawa
        else if (gameState.phase === 'DOUBLING' || gameState.sawaState?.active) {
            level = 'medium';
            newBpm = 60;
        }

        setTension(level);
        setBpm(newBpm);

    }, [gameState]);

    return { tension, bpm };
};

```

### FILE: frontend\src\hooks\useVoice.ts
```ts
import { useCallback, useRef } from 'react';

export type VoicePersonality = 'AGRESSIVE' | 'CONSERVATIVE' | 'BALANCED';

interface VoiceProfile {
    pitch: number;
    rate: number;
    lang: string;
}

const VOICES: Record<VoicePersonality, VoiceProfile> = {
    AGRESSIVE: { pitch: 1.1, rate: 1.25, lang: 'ar-SA' }, // Khalid: Fast, slightly high/tense
    CONSERVATIVE: { pitch: 0.8, rate: 0.85, lang: 'ar-SA' }, // Abu Fahad: Deep, slow, authoritative
    BALANCED: { pitch: 1.0, rate: 1.0, lang: 'ar-SA' }     // Saad: Normal
};

export const useVoice = () => {
    const synthesis = window.speechSynthesis;
    // Cache voices to avoid getVoices() lag
    const voicesRef = useRef<SpeechSynthesisVoice[]>([]);

    const speak = useCallback((text: string, personality: VoicePersonality = 'BALANCED') => {
        if (!synthesis) return;

        // Retry fetching voices if empty (browser async loading)
        if (voicesRef.current.length === 0) {
            voicesRef.current = synthesis.getVoices();
        }

        // Cancel current speech if any (to make it snappy trash talk, interrupting previous)
        synthesis.cancel();

        const utterance = new SpeechSynthesisUtterance(text);
        const profile = VOICES[personality];

        utterance.pitch = profile.pitch;
        utterance.rate = profile.rate;
        utterance.lang = profile.lang;

        // Try to find a specific Arabic voice
        const arabicVoice = voicesRef.current.find(v => v.lang.includes('ar'));
        if (arabicVoice) {
            utterance.voice = arabicVoice;
        }

        synthesis.speak(utterance);
    }, [synthesis]);

    return { speak };
};

```

### FILE: frontend\src\pages\AcademyPage.tsx
```tsx

import React, { useEffect, useState } from 'react';
import { motion } from 'framer-motion';
import { Trophy, ArrowRight, GraduationCap, AlertCircle, ArrowLeft, BookOpen, Clock } from 'lucide-react';
import { API_BASE_URL } from '../config';

interface PuzzleSummary {
    id: string;
    title: string;
    description: string;
    difficulty: 'Beginner' | 'Intermediate' | 'Advanced';
    tags: string[];
}

interface AcademyPageProps {
    onSelectPuzzle: (id: string) => void;
    onBack: () => void;
}

const AcademyPage: React.FC<AcademyPageProps> = ({ onSelectPuzzle, onBack }) => {
    const [puzzles, setPuzzles] = useState<PuzzleSummary[]>([]);
    const [loading, setLoading] = useState(true);
    const [filter, setFilter] = useState<string>('All');

    useEffect(() => {
        fetch(`${API_BASE_URL}/academy/puzzles`)
            .then(res => res.json())
            .then(data => {
                if (data.puzzles) setPuzzles(data.puzzles);
                setLoading(false);
            })
            .catch(err => {
                console.error("Failed to fetch academy puzzles", err);
                setLoading(false);
            });
    }, []);

    const filteredPuzzles = filter === 'All' 
        ? puzzles 
        : puzzles.filter(p => p.difficulty === filter);

    return (
        <div className="min-h-screen bg-slate-950 text-white p-6 sm:p-12 font-tajawal" dir="rtl">
            <header className="max-w-6xl mx-auto mb-12 flex flex-col md:flex-row items-center justify-between gap-6">
                <div className="text-right">
                    <button onClick={onBack} className="flex items-center gap-2 text-white/50 hover:text-white mb-4 transition-colors">
                        <ArrowRight size={20} className="rotate-180" /> Back to Lobby
                    </button>
                    <h1 className="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-l from-amber-300 to-yellow-600 mb-2">
                         ÿ£ŸÉÿßÿØŸäŸÖŸäÿ© ÿßŸÑÿ®ŸÑŸàÿ™
                    </h1>
                    <p className="text-slate-400 text-lg">The Academy: Master the art of Baloot with tailored scenarios.</p>
                </div>
                <div className="bg-amber-500/10 p-6 rounded-full border border-amber-500/20 shadow-[0_0_50px_rgba(245,158,11,0.2)]">
                    <GraduationCap size={64} className="text-amber-400" />
                </div>
            </header>

            <main className="max-w-6xl mx-auto">
                {/* Filters */}
                <div className="flex gap-4 mb-8 overflow-x-auto pb-2">
                    {['All', 'Beginner', 'Intermediate', 'Advanced'].map(f => (
                        <button
                            key={f}
                            onClick={() => setFilter(f)}
                            className={`px-6 py-2 rounded-full font-bold transition-all whitespace-nowrap ${
                                filter === f 
                                ? 'bg-amber-500 text-black shadow-lg shadow-amber-500/20' 
                                : 'bg-white/5 hover:bg-white/10 text-slate-400'
                            }`}
                        >
                            {f === 'All' ? 'ÿßŸÑŸÉŸÑ' : f}
                        </button>
                    ))}
                </div>

                {loading ? (
                    <div className="text-center py-20 text-slate-500 animate-pulse">Checking Curriculum...</div>
                ) : (
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        {filteredPuzzles.length === 0 ? (
                            <div className="col-span-full text-center py-20 bg-white/5 rounded-3xl border border-dashed border-white/10">
                                <AlertCircle className="mx-auto mb-4 text-slate-500" size={48} />
                                <p className="text-slate-400 text-xl">No puzzles found in this category.</p>
                            </div>
                        ) : (
                            filteredPuzzles.map((puzzle, idx) => (
                                <motion.div
                                    key={puzzle.id}
                                    initial={{ opacity: 0, y: 20 }}
                                    animate={{ opacity: 1, y: 0 }}
                                    transition={{ delay: idx * 0.05 }}
                                    onClick={() => onSelectPuzzle(puzzle.id)}
                                    className="group relative overflow-hidden bg-white/5 hover:bg-white/10 border border-white/5 hover:border-amber-500/50 rounded-2xl p-6 transition-all duration-300 cursor-pointer hover:-translate-y-1 shadow-xl"
                                >
                                    {/* Difficulty Badge */}
                                    <div className="absolute top-4 left-4">
                                        <span className={`text-xs font-bold px-3 py-1 rounded-full border ${
                                            puzzle.difficulty === 'Beginner' ? 'bg-green-500/20 text-green-400 border-green-500/30' :
                                            puzzle.difficulty === 'Intermediate' ? 'bg-blue-500/20 text-blue-400 border-blue-500/30' :
                                            'bg-red-500/20 text-red-400 border-red-500/30'
                                        }`}>
                                            {puzzle.difficulty}
                                        </span>
                                    </div>

                                    <div className="mb-4 mt-2">
                                        <h3 className="text-2xl font-bold mb-2 group-hover:text-amber-400 transition-colors">{puzzle.title}</h3>
                                        <p className="text-slate-400 text-sm h-10 line-clamp-2">{puzzle.description}</p>
                                    </div>

                                    {/* Tags */}
                                    <div className="flex flex-wrap gap-2 mb-6">
                                        {puzzle.tags.map(tag => (
                                            <span key={tag} className="text-[10px] bg-slate-800 text-slate-300 px-2 py-1 rounded">#{tag}</span>
                                        ))}
                                    </div>

                                    <div className="flex justify-between items-center text-sm text-slate-500 font-mono group-hover:text-amber-500 transition-colors">
                                        <span className="flex items-center gap-2"><BookOpen size={14} /> Lesson {idx + 1}</span>
                                        <span className="flex items-center gap-1">Start <ArrowLeft size={14} /></span>
                                    </div>
                                </motion.div>
                            ))
                        )}
                    </div>
                )}
            </main>
        </div>
    );
};

export default AcademyPage;

```

### FILE: frontend\src\pages\PuzzleBoard.tsx
```tsx
import React, { useEffect, useState } from 'react';
import Table from '../components/Table';
import { API_BASE_URL } from '../config';
import { GameState, GamePhase } from '../types';
import { ArrowLeft, CheckCircle, XCircle, RotateCcw } from 'lucide-react';
import { soundManager } from '../services/SoundManager';
// import confetti from 'canvas-confetti'; // Optional: Add later for pizzazz

interface PuzzleBoardProps {
    id: string;
    onBack: () => void;
}

const PuzzleBoard: React.FC<PuzzleBoardProps> = ({ id, onBack }) => {

    const [puzzle, setPuzzle] = useState<any>(null);
    const [gameState, setGameState] = useState<GameState | null>(null);
    const [result, setResult] = useState<'PENDING' | 'CORRECT' | 'WRONG'>('PENDING');
    const [feedback, setFeedback] = useState<string>("");

    useEffect(() => {
        // Load Puzzle
        console.log("Fetching Puzzle ID:", id);
        fetch(`${API_BASE_URL}/puzzles/${id}`)
            .then(res => {
                console.log("Fetch Status:", res.status);
                return res.json();
            })
            .then(data => {
                console.log("Puzzle Data:", data);
                if (data.puzzle) {
                    setPuzzle(data.puzzle);
                    const initial = data.puzzle.game_state;

                    // Force state for UI
                    // Ensure the 'players' array has 'Me' as the active turn player if possible?
                    // The puzzle stores the state exactly as the bot saw it.
                    // If bot was index 2 (Top), we need to rotate the view so Index 2 is "Bottom" (Me).
                    // This requires a rotation helper similar to 'get_relative_index'.

                    // But 'Table.tsx' expects Player 0 to be 'Me'. 
                    // We need to adapt the gameState so clarity is maintained.

                    // ADAPTER: Find the puzzle player
                    const heroIndex = initial.currentTurnIndex;

                    // Rotate players so heroIndex is at 0
                    const players = initial.players || [];
                    const rotatedPlayers = [
                        ...players.slice(heroIndex),
                        ...players.slice(0, heroIndex)
                    ];

                    // Remap positions standard (Bottom, Right, Top, Left)
                    const heroPos = initial.players[heroIndex].position;
                    // Actually, let's just cheat and force the UI to treat hero as "Me"
                    // But Table component assumes players[0] is Me.

                    rotatedPlayers.forEach((p: any, idx) => {
                        if (idx === 0) p.name = "You (Bot)";
                        p.index = (heroIndex + idx) % 4; // Virtual index? No, keep original index for logic
                    });

                    // Update Table Cards to match visual rotation? 
                    // Table uses 'playedBy' position. 
                    // If we don't rotate positions, the avatars might be wrong place, but gameplay is correct.
                    // For now, pass state as is, but ensure players[0] corresponds to the hero?

                    // Better approach: Just set 'players' such that the first element IS the current turn player.
                    // And Table renders players[0] as Bottom.

                    setGameState({
                        ...initial,
                        players: rotatedPlayers,
                        // Ensure phase is Playing
                        phase: GamePhase.Playing
                    });
                }
            })
            .catch(err => {
                console.error("Puzzle Fetch Error:", err);
                setFeedback("Failed to load puzzle: " + err.message);
                setResult('WRONG');
            });
    }, [id]);

    const handleAction = (action: string, payload: any) => {
        if (result !== 'PENDING') return;

        // Check Solution
        const correct = puzzle.solution;

        let isCorrect = false;

        if (action === 'PLAY') {
            // Compare card index? 
            // BEWARE: The index in Payload corresponds to the ROTATED hand (0-7 for the user).
            // The Solution usually expects the original absolute index or card content.
            // The best way is to compare the *Card Content* (Rank/Suit).

            // Get played card
            const card = gameState?.players[0].hand[payload.cardIndex];
            // Get expected card (we might need to find it in hand if solution stores index)
            // Solution from BotTrainingData usually has 'cardIndex' relative to the original state.

            if (correct.action === 'PLAY') {
                // If solution has rank/suit, compare that
                if (correct.card) {
                    isCorrect = (card.rank === correct.card.rank && card.suit === correct.card.suit);
                } else {
                    // Fallback: If generic index, it's risky. 
                    // Assume for now 'correct' has been hydrated with reasoning or strict check.
                    // Let's assume ANY Valid Play that matches Expected Logic is OK?
                    // No, duplicate the strict index check from the validation script? 

                    // Hack for MVP: Check if card index matches exactly?
                    // Since we rotated players[0] to be the Hero, their hand is players[0].hand.
                    // The 'correct.cardIndex' is relative to that player's hand.
                    isCorrect = (payload.cardIndex === correct.cardIndex);
                }
            }
        }

        if (isCorrect) {
            setResult('CORRECT');
            setFeedback(`‚úÖ Correct! ${correct.reasoning || "Perfect move."}`);
            soundManager.playProjectSound(); // Success sound
        } else {
            setResult('WRONG');
            setFeedback(`‚ùå Incorrect. Gemini suggests: ${correct.reasoning}`);
        }
    };

    // If loading and no error, show loading
    if (!gameState && result !== 'WRONG') return <div className="bg-slate-900 h-screen flex items-center justify-center text-white">Loading Puzzle...</div>;

    return (
        <div className="relative h-screen w-full overflow-hidden bg-slate-900">
            {/* Overlay UI */}
            {/* Top Right: Exit */}
            <div className="absolute top-4 right-4 z-50">
                <button onClick={onBack} className="bg-black/50 hover:bg-black/70 text-white px-4 py-2 rounded-full flex items-center gap-2 backdrop-blur-md transition-all border border-white/10">
                    <ArrowLeft size={16} /> Exit Class
                </button>
            </div>

            {/* Top Center: Title Badge */}
            <div className="absolute top-4 left-1/2 -translate-x-1/2 z-50 bg-amber-500 text-black px-6 py-2 rounded-full font-bold shadow-lg flex items-center gap-2">
                üéì Puzzle Mode
            </div>

            {/* Game Table (Only if we have state) */}
            {gameState && (
                <Table
                    gameState={gameState}
                    onPlayerAction={handleAction}
                />
            )}

            {/* Result Overlay */}
            {result !== 'PENDING' && (
                <div className="absolute inset-0 z-[100] flex items-center justify-center bg-black/60 backdrop-blur-sm animate-in fade-in">
                    <div className="bg-slate-900 border border-white/10 p-8 rounded-3xl max-w-lg w-full text-center shadow-2xl transform scale-100 animate-in zoom-in-95 duration-200">
                        {result === 'CORRECT' ? (
                            <CheckCircle size={64} className="mx-auto text-green-400 mb-4" />
                        ) : (
                            <XCircle size={64} className="mx-auto text-red-400 mb-4" />
                        )}

                        <h2 className={`text-3xl font-black mb-2 ${result === 'CORRECT' ? 'text-green-400' : 'text-red-400'}`}>
                            {result === 'CORRECT' ? 'Excellent!' : 'Try Again'}
                        </h2>

                        <div className="bg-white/5 p-4 rounded-xl text-white/90 text-left mb-6 font-mono text-sm leading-relaxed border-l-4 border-amber-500">
                            {feedback}
                        </div>

                        <div className="flex gap-3 justify-center">
                            <button onClick={() => window.location.reload()} className="px-6 py-3 bg-white/10 hover:bg-white/20 text-white rounded-xl font-bold flex items-center gap-2 transition-colors">
                                <RotateCcw size={18} /> Retry
                            </button>
                            {result === 'CORRECT' && (
                                <button onClick={onBack} className="px-6 py-3 bg-green-500 hover:bg-green-600 text-white rounded-xl font-bold shadow-lg shadow-green-500/20 transition-all">
                                    Finish
                                </button>
                            )}
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
};

export default PuzzleBoard;

```

### FILE: frontend\src\pages\PuzzleList.tsx
```tsx

import React, { useEffect, useState } from 'react';
import { motion } from 'framer-motion';
import { Trophy, ArrowRight, BrainCircuit, AlertCircle, ArrowLeft } from 'lucide-react';
// import { Button } from '@/components/ui/button'; 
import { API_BASE_URL } from '../config';

interface PuzzleSummary {
    id: string;
    difficulty: string;
    description: string;
    context_hash: string;
}

interface PuzzleListProps {
    onSelectPuzzle: (id: string) => void;
    onBack: () => void;
}

const PuzzleList: React.FC<PuzzleListProps> = ({ onSelectPuzzle, onBack }) => {
    const [puzzles, setPuzzles] = useState<PuzzleSummary[]>([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        fetch(`${API_BASE_URL}/puzzles`)
            .then(res => res.json())
            .then(data => {
                if (data.puzzles) setPuzzles(data.puzzles);
                setLoading(false);
            })
            .catch(err => {
                console.error("Failed to fetch puzzles", err);
                setLoading(false);
            });
    }, []);

    return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-white p-6 sm:p-12 font-sans">
            <header className="max-w-4xl mx-auto mb-12 flex items-center justify-between">
                <div>
                    <button onClick={onBack} className="flex items-center gap-2 text-white/50 hover:text-white mb-4 transition-colors">
                        <ArrowLeft size={20} /> Back to Lobby
                    </button>
                    <h1 className="text-4xl font-black bg-clip-text text-transparent bg-gradient-to-r from-amber-300 to-yellow-500 mb-2">
                        AI Classroom
                    </h1>
                    <p className="text-white/60">Test your Baloot logic against the AI's "Golden Puzzles".</p>
                </div>
                <div className="bg-white/10 p-3 rounded-full">
                    <BrainCircuit size={32} className="text-amber-400" />
                </div>
            </header>

            <main className="max-w-4xl mx-auto">
                {loading ? (
                    <div className="text-center py-20 text-white/50 animate-pulse">Loading Puzzles...</div>
                ) : (
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        {puzzles.length === 0 ? (
                            <div className="col-span-2 text-center py-12 bg-white/5 rounded-2xl border border-dashed border-white/10">
                                <AlertCircle className="mx-auto mb-4 text-white/40" />
                                <p>No puzzles generated yet.</p>
                                <p className="text-sm text-white/40 mt-1">Run the Scout to find mistakes!</p>
                            </div>
                        ) : (
                            puzzles.map((puzzle, idx) => (
                                <motion.div
                                    key={puzzle.id}
                                    initial={{ opacity: 0, y: 20 }}
                                    animate={{ opacity: 1, y: 0 }}
                                    transition={{ delay: idx * 0.1 }}
                                    className="group relative overflow-hidden bg-white/5 hover:bg-white/10 border border-white/10 hover:border-amber-500/50 rounded-2xl p-6 transition-all duration-300 shadow-lg hover:shadow-amber-500/10"
                                >
                                    <div className="flex justify-between items-start mb-4">
                                        <div className="bg-amber-500/20 text-amber-300 text-xs font-bold px-2 py-1 rounded-md border border-amber-500/30 uppercase tracking-wider">
                                            {puzzle.difficulty}
                                        </div>
                                        <Trophy size={20} className="text-white/20 group-hover:text-amber-400 transition-colors" />
                                    </div>

                                    <h3 className="text-xl font-bold mb-2">Puzzle #{idx + 1}</h3>
                                    <p className="text-sm text-white/60 mb-6 line-clamp-2 h-10">
                                        {puzzle.description}
                                    </p>

                                    <button
                                        onClick={() => onSelectPuzzle(puzzle.id)}
                                        className="inline-flex items-center gap-2 text-amber-400 font-bold group-hover:gap-3 transition-all cursor-pointer"
                                    >
                                        Solve Now <ArrowRight size={16} />
                                    </button>
                                </motion.div>
                            ))
                        )}
                    </div>
                )}
            </main>
        </div>
    );
};

export default PuzzleList;

```

### FILE: frontend\src\pages\ReplayPage.tsx (SKIPPED - >10KB)
### FILE: frontend\src\services\AccountingEngine.ts (SKIPPED - >10KB)
### FILE: frontend\src\services\botService.ts (SKIPPED - >10KB)
### FILE: frontend\src\services\geminiService.ts
```ts
import { GameState, PlayerPosition, GamePhase } from "../types";

export const getSimpleBotDecision = async (gameState: GameState, playerPos: PlayerPosition): Promise<{ action: string, cardIndex?: number }> => {
  // Simulate "thinking" delay
  // await new Promise(resolve => setTimeout(resolve, 500)); 

  if (gameState.phase === GamePhase.Bidding) {
    // Simple Bidding Logic: 20% chance to buy SUN, 10% HOKUM, else PASS
    const rand = Math.random();
    if (rand < 0.2) return { action: 'SUN' };
    if (rand < 0.3) return { action: 'HOKUM' };
    return { action: 'PASS' };
  }

  if (gameState.phase === GamePhase.Playing) {
    const playerIndex = gameState.players.findIndex(p => p.position === playerPos);
    const hand = gameState.players[playerIndex].hand;

    // Simple Playing Logic: Play valid card (for now random valid)
    // In a real game, you'd check for suit following, etc.
    // Since validation happens in backend/state mostly, we just pick an index.

    const randomIndex = Math.floor(Math.random() * hand.length);
    return { action: 'PLAY', cardIndex: randomIndex };
  }

  return { action: 'PASS' };
};
```

### FILE: frontend\src\services\index.ts
```ts
export * from './AccountingEngine';
export * from './SocketService';
export * from './SoundManager';
export * from './botService';
export * from './geminiService';
export * from './trainingService';

```

### FILE: frontend\src\services\SocketService.ts
```ts
import { io, Socket } from "socket.io-client";
import { GameState } from "../types";

const SERVER_URL = "http://localhost:3005"; // Direct connection to Backend (Bypasses Proxy)

interface ApiResponse {
    success: boolean;
    error?: string;
    [key: string]: unknown;
}

class SocketService {
    public socket: Socket | null = null;

    connect() {
        if (!this.socket) {
            this.socket = io(SERVER_URL, {
                transports: ['websocket', 'polling'], // Try websocket first
                reconnection: true,
            });
            this.socket.on('connect', () => {
                console.log('Connected to Game Server:', this.socket?.id);
            });
            this.socket.on('connect_error', (err) => {
                console.error('Socket Connection Error:', err);
            });
        } else if (!this.socket.connected) {
            this.socket.connect();
        }
        return this.socket;
    }

    disconnect() {
        if (this.socket && this.socket.connected) {
            this.socket.disconnect();
        }
    }

    createRoom(callback: (res: ApiResponse) => void) {
        if (!this.socket) return;
        this.socket.emit('create_room', {}, callback);
    }

    joinRoom(roomId: string, playerName: string, callback: (res: ApiResponse) => void) {
        if (!this.socket) return;
        this.socket.emit('join_room', { roomId, playerName }, callback);
    }

    sendAction(roomId: string, action: string, payload: Record<string, unknown>, callback?: (res: ApiResponse) => void) {
        if (!this.socket) {
            if (callback) callback({ success: false, error: "Socket not connected" });
            return;
        }
        this.socket.emit('game_action', { roomId, action, payload }, (res: ApiResponse) => {
            // @ts-ignore
            import('../utils/devLogger').then(({ devLogger }) => {
                if (res.success) devLogger.log('SOCKET', 'Action Success', { action });
                else devLogger.error('SOCKET', 'Action Failed', { action, error: res.error });
            });

            if (callback) {
                callback(res);
            } else if (!res.success) {
                console.error("Action Failed:", res.error);
            }
        });
    }

    sendDebugAction(roomId: string, action: string, payload: Record<string, unknown>) {
        if (!this.socket) return;
        this.socket.emit('debug_action', { roomId, action, payload }, (res: ApiResponse) => {
            if (!res.success) {
                console.error("Debug Action Failed:", res.error);
            }
        });
    }

    onGameUpdate(callback: (gameState: GameState) => void) {
        if (!this.socket) return () => { };

        const handler = (data: { gameState: GameState }) => {
            // @ts-ignore
            import('../utils/devLogger').then(({ devLogger }) => devLogger.log('SOCKET', 'Game Update Received', { phase: data.gameState.phase, turn: data.gameState.currentTurnIndex }));
            callback(data.gameState)
        };

        this.socket.on('game_update', handler);
        return () => {
            this.socket?.off('game_update', handler);
        };
    }

    onGameStart(callback: (gameState: GameState) => void) {
        if (!this.socket) return () => { };
        const handler = (data: { gameState: GameState }) => callback(data.gameState);
        this.socket.on('game_start', handler);
        return () => {
            this.socket?.off('game_start', handler);
        };
    }

    addBot(roomId: string, callback: (res: ApiResponse) => void) {
        if (!this.socket) return;
        this.socket.emit('add_bot', { roomId }, callback);
    }


    onBotSpeak(callback: (data: { playerIndex: number, text: string, emotion: string }) => void) {
        if (!this.socket) return () => { };
        const handler = (data: { playerIndex: number, text: string, emotion: string }) => callback(data);
        this.socket.on('bot_speak', handler);
        return () => {
            this.socket?.off('bot_speak', handler);
        };
    }

    // Add more event wrappers here
}

export default new SocketService();

```

### FILE: frontend\src\services\SoundManager.ts
```ts
export class SoundManager {
    private ctx: AudioContext | null = null;
    private isMuted: boolean = false;

    constructor() {
        // Initialize AudioContext only on user interaction usually, but here we prep it
        try {
            const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;
            this.ctx = new AudioContextClass();
        } catch (e) {
            console.error("Web Audio API not supported", e);
        }
    }

    public setMute(muted: boolean) {
        this.isMuted = muted;
    }

    private getContext(): AudioContext | null {
        if (!this.ctx) return null;
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
        return this.ctx;
    }

    // SFX: Card Flip / Play (Realistic "Snap")
    public playCardSound() {
        if (this.isMuted) return;
        const ctx = this.getContext();
        if (!ctx) return;

        const t = ctx.currentTime;

        // 1. Whitenoise "Swish" (Air resistance)
        const noiseBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
        const data = noiseBuffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;

        const noise = ctx.createBufferSource();
        noise.buffer = noiseBuffer;

        const noiseFilter = ctx.createBiquadFilter();
        noiseFilter.type = 'lowpass';
        noiseFilter.frequency.setValueAtTime(1000, t);
        noiseFilter.frequency.linearRampToValueAtTime(100, t + 0.1);

        const noiseGain = ctx.createGain();
        noiseGain.gain.setValueAtTime(0.4, t);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.08);

        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(ctx.destination);
        noise.start(t);

        // 2. Card "Snap" (High pitched impulse)
        const osc = ctx.createOscillator();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(200, t);
        osc.frequency.exponentialRampToValueAtTime(40, t + 0.05);

        const oscGain = ctx.createGain();
        oscGain.gain.setValueAtTime(0.3, t);
        oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);

        osc.connect(oscGain);
        oscGain.connect(ctx.destination);
        osc.start(t);
        osc.stop(t + 0.1);
    }

    // SFX: Shuffle (Rhythmic ripple)
    public playShuffleSound() {
        if (this.isMuted) return;
        this.playCardSound(); // Just one crisp sound, or a controlled burst
    }

    public playDealSequence() {
        if (this.isMuted) return;
        // Rapid succession of card sounds
        let count = 0;
        const interval = setInterval(() => {
            this.playCardSound();
            count++;
            if (count > 5) clearInterval(interval);
        }, 80);
    }

    // SFX: Success / Win Trick (Gold Coin Chime)
    public playWinSound() {
        if (this.isMuted) return;
        const ctx = this.getContext();
        if (!ctx) return;

        const t = ctx.currentTime;

        // Primary Bell
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(880, t); // A5
        osc.frequency.exponentialRampToValueAtTime(880, t + 1);

        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.2, t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 1.5);

        // Harmonics for "shine"
        const osc2 = ctx.createOscillator();
        osc2.type = 'sine';
        osc2.frequency.setValueAtTime(1760, t); // A6

        const gain2 = ctx.createGain();
        gain2.gain.setValueAtTime(0.1, t);
        gain2.gain.exponentialRampToValueAtTime(0.001, t + 1.0);

        osc.connect(gain);
        osc2.connect(gain2);
        gain.connect(ctx.destination);
        gain2.connect(ctx.destination);

        osc.start(t);
        osc2.start(t);
        osc.stop(t + 2);
        osc2.stop(t + 2);
    }

    // SFX: Your Turn (Glassy "Ding")
    public playTurnSound() {
        if (this.isMuted) return;
        const ctx = this.getContext();
        if (!ctx) return;

        const t = ctx.currentTime;
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1200, t);

        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.3, t + 0.05); // Soft attack
        gain.gain.exponentialRampToValueAtTime(0.001, t + 1.0); // Long decay

        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(t);
        osc.stop(t + 1.2);
    }

    // SFX: Error / Invalid Move (Low Buzz)
    public playErrorSound() {
        if (this.isMuted) return;
        const ctx = this.getContext();
        if (!ctx) return;

        const t = ctx.currentTime;
        const osc = ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.linearRampToValueAtTime(100, t + 0.3);

        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.2, t);
        gain.gain.linearRampToValueAtTime(0.01, t + 0.3);

        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(t);
        osc.stop(t + 0.3);
    }
    // SFX: Project Declaration (Wow effect)
    public playProjectSound() {
        if (this.isMuted) return;
        const ctx = this.getContext();
        if (!ctx) return;
        const t = ctx.currentTime;

        // Ascending harp-like arpeggio
        const frequencies = [440, 554, 659, 880]; // A major
        frequencies.forEach((f, i) => {
            const osc = ctx.createOscillator();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(f, t + i * 0.1);

            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0, t + i * 0.1);
            gain.gain.linearRampToValueAtTime(0.2, t + i * 0.1 + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, t + i * 0.1 + 1.0);

            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start(t + i * 0.1);
            osc.stop(t + i * 0.1 + 1.2);
        });
    }

    // SFX: Akka Declaration (Strong Impact)
    public playAkkaSound() {
        if (this.isMuted) return;
        const ctx = this.getContext();
        if (!ctx) return;
        const t = ctx.currentTime;

        // "Akka" - Two hits? Or one strong hit? 
        // Let's do a strong "Boom-Chime"

        // Low boom
        const osc1 = ctx.createOscillator();
        osc1.type = 'sawtooth';
        osc1.frequency.setValueAtTime(110, t); // A2
        osc1.frequency.exponentialRampToValueAtTime(55, t + 0.3);

        const gain1 = ctx.createGain();
        gain1.gain.setValueAtTime(0.5, t);
        gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

        // High chime
        const osc2 = ctx.createOscillator();
        osc2.type = 'sine';
        osc2.frequency.setValueAtTime(880, t); // A5
        osc2.frequency.exponentialRampToValueAtTime(1760, t + 0.1);

        const gain2 = ctx.createGain();
        gain2.gain.setValueAtTime(0.3, t);
        gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

        osc1.connect(gain1);
        osc2.connect(gain2);
        gain1.connect(ctx.destination);
        gain2.connect(ctx.destination);

        osc1.start(t);
        osc1.stop(t + 0.5);
        osc2.start(t);
        osc2.stop(t + 0.5);
    }

    // SFX: UI Click (Short mechanical tick)
    public playClick() {
        if (this.isMuted) return;
        const ctx = this.getContext();
        if (!ctx) return;
        const t = ctx.currentTime;

        const osc = ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(800, t);
        osc.frequency.exponentialRampToValueAtTime(100, t + 0.05);

        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);

        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(t);
        osc.stop(t + 0.05);
    }
}

export const soundManager = new SoundManager();

```

### FILE: frontend\src\services\trainingService.ts
```ts
import { GameState } from "../types";

const API_BASE = 'http://127.0.0.1:3005/react-py4web'; // Updated to match run_game_server.py port

export interface TrainingExample {
    contextHash: string;
    gameState: string;
    badMove: string;
    correctMove: string;
    reason: string;
    imageFilename?: string;
}

export const submitTrainingData = async (data: TrainingExample) => {
    try {
        console.log("[Studio-Service] Submitting Training Data...", data);
        const response = await fetch(`${API_BASE}/submit_training`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data),
        });
        return await response.json();
    } catch (error) {
        console.error("Failed to submit training data", error);
        throw error;
    }
};

export const getTrainingData = async () => {
    try {
        console.log("[Studio-Service] Fetching Training Data...");
        const response = await fetch(`${API_BASE}/training_data`);
        return await response.json();
    } catch (error) {
        console.error("Failed to fetch training data", error);
        return { data: [] };
    }
};

export const analyzeScreenshot = async (file: File) => {
    const formData = new FormData();
    formData.append('screenshot', file);

    try {
        console.log("[Studio-Service] Uploading Screenshot...", file.name);
        const response = await fetch(`${API_BASE}/analyze_screenshot`, {
            method: 'POST',
            body: formData,
        });
        return await response.json();
    } catch (error) {
        console.error("Failed to analyze screenshot", error);
        throw error;
    }
};

export const askStrategy = async (gameState: GameState) => {
    try {
        console.log("[Studio-Service] Asking AI Strategy...", gameState);
        const response = await fetch(`${API_BASE}/ask_strategy`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ gameState }),
        });
        return await response.json();
    } catch (error) {
        console.error("Failed to ask strategy", error);
        throw error;
    }
};

export const generateScenario = async (text: string) => {
    try {
        const response = await fetch(`${API_BASE}/generate_scenario`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text })
        });
        return await response.json();
    } catch (error) {
        console.error("Failed to generate scenario", error);
        throw error;
    }
};

export const analyzeMatch = async (gameId: string) => {
    try {
        const response = await fetch(`${API_BASE}/analyze_match`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ gameId })
        });
        return await response.json();
    } catch (error) {
        console.error("Failed to analyze match", error);
        throw error;
    }
};

export const getBrainMemory = async () => {
    try {
        console.log("[Studio-Service] Fetching Brain Memory...");
        const res = await fetch(`${API_BASE}/brain/memory`);
        return await res.json();
    } catch (error) {
        console.error("Error fetching brain memory:", error);
        return { error: "Network Error" };
    }
};

export const deleteBrainMemory = async (hash: string) => {
    try {
        const res = await fetch(`${API_BASE}/brain/memory/${hash}`, {
            method: 'DELETE'
        });
        return await res.json();
    } catch (error) {
        console.error("Error deleting brain memory:", error);
        return { error: "Network Error" };
    }
};

```

### FILE: frontend\src\utils\animationUtils.ts
```ts
import { Player } from '../types';

interface AnimationParams {
    playerIndex: number;
    isLatest: boolean;
    myIndex: number;
    players: Player[];
    tableCards: any[]; // Using any because table structure might be complex
}

/**
 * Calculates the animation trajectory for a played card.
 * Moves card from player's position (Bottom/Right/Top/Left) to the table center.
 */
export const getPlayedCardAnimation = ({
    playerIndex,
    isLatest,
    myIndex,
    players,
    tableCards
}: AnimationParams) => {
    const relativeIndex = (playerIndex - myIndex + 4) % 4; // 0=Me, 1=Right, 2=Partner, 3=Left

    const cardWidth = window.innerWidth < 640 ? 60 : 85;
    const cardHeight = window.innerWidth < 640 ? 84 : 118;
    const offsetDistance = window.innerWidth < 640 ? 25 : 40; // Tighter

    // 1. Determine Final Position (Target)
    let targetX = 0;
    let targetY = 0;
    let rotation = 0;
    let initialX = 0;
    let initialY = 0;

    const range = 500; // Throw distance

    switch (relativeIndex) {
        case 0: // Me (Bottom)
            targetX = 0;
            targetY = offsetDistance;
            initialX = 0;
            initialY = range; // Come from bottom
            rotation = -2 + ((playerIndex * 7) % 5);
            break;
        case 1: // Right
            targetX = offsetDistance * 1.5;
            targetY = 0;
            initialX = range; // Come from right
            initialY = 0;
            rotation = 85 + ((playerIndex * 7) % 5);
            break;
        case 2: // Partner (Top)
            targetX = 0;
            targetY = -offsetDistance;
            initialX = 0;
            initialY = -range; // Come from top
            rotation = 180 + ((playerIndex * 7) % 5);
            break;
        case 3: // Left
            targetX = -offsetDistance * 1.5;
            targetY = 0;
            initialX = -range; // Come from left
            initialY = 0;
            rotation = -85 + ((playerIndex * 7) % 5);
            break;
    }

    // Z-Index Logic
    // We try to find the player's card in the tableCards to see play order
    const playOrder = tableCards.findIndex(c => (c as any).playedBy === players[playerIndex].position);
    const zIndex = 40 + (playOrder >= 0 ? playOrder : 0);

    // Telemetry for Verification
    if (isLatest) {
        // We use a dynamic import for logger if needed, or just console in dev
        // Keeping it side-effect free for now, moving logging out or keeping purely calculation
        // If logging is strictly required here, we'd need to inject the logger or handle it in the component.
        // For "Clean Code", we prefer pure functions. We'll leave the logging in the component or remove it if excessive.
    }

    return {
        initial: { opacity: 0, x: initialX, y: initialY, scale: 0.8, rotate: rotation },
        animate: { opacity: 1, x: targetX, y: targetY, scale: 1, rotate: rotation },
        exit: { opacity: 0, scale: 0.5 },
        style: {
            position: 'absolute' as 'absolute',
            top: '50%',
            left: '50%',
            width: `${cardWidth}px`,
            height: `${cardHeight}px`,
            marginTop: `-${cardHeight / 2}px`, // Center anchor
            marginLeft: `-${cardWidth / 2}px`, // Center anchor
            zIndex: zIndex,
            boxShadow: '0 4px 6px rgba(0,0,0,0.3)'
        },
        animClass: isLatest ? 'animate-thump' : '' // Custom tailwind class for thump impact
    };
};

```

### FILE: frontend\src\utils\devLogger.ts
```ts

// Simple Event-based Logger for Sidebar
type LogLevel = 'INFO' | 'WARN' | 'ERROR' | 'SUCCESS';

export interface LogEntry {
    id: string;
    timestamp: string;
    level: LogLevel;
    category: string;
    message: string;
    data?: unknown;
}

class DevLogger {
    private logs: LogEntry[] = [];
    private listeners: ((log: LogEntry) => void)[] = [];
    private maxLogs = 100;

    log(category: string, message: string, data?: unknown) {
        this.addLog('INFO', category, message, data);
    }

    warn(category: string, message: string, data?: unknown) {
        this.addLog('WARN', category, message, data);
    }

    error(category: string, message: string, data?: unknown) {
        this.addLog('ERROR', category, message, data);
    }

    success(category: string, message: string, data?: unknown) {
        this.addLog('SUCCESS', category, message, data);
    }

    private socket: any = null; // Leaving as any or specific Socket type if imported

    setSocket(socket: any) {
        this.socket = socket;
    }

    private addLog(level: LogLevel, category: string, message: string, data?: unknown) {
        const entry: LogEntry = {
            id: Math.random().toString(36).substr(2, 9),
            timestamp: new Date().toLocaleTimeString(),
            level,
            category,
            message,
            data
        };

        this.logs.push(entry);
        if (this.logs.length > this.maxLogs) {
            this.logs.shift();
        }

        // Notify listeners
        this.listeners.forEach(l => l(entry));

        // Stream to Server (Telemetry)
        // Stream to Server (Telemetry)
        if (this.socket) {
            // Send everything to server for analysis (Agent Request)
            // Filter out extremely noisy stuff if needed, but for now send all.
            try {
                this.socket.emit('client_log', entry);
            } catch (e) { /* ignore */ }
        }

        // Also log to console for backup
        const style = level === 'ERROR' ? 'color: red' : level === 'WARN' ? 'color: orange' : level === 'SUCCESS' ? 'color: green' : 'color: blue';
        console.log(`%c[${category}] ${message}`, style, data || '');
    }

    subscribe(listener: (log: LogEntry) => void) {
        this.listeners.push(listener);
        return () => {
            this.listeners = this.listeners.filter(l => l !== listener);
        };
    }

    getHistory() {
        return [...this.logs];
    }

    clear() {
        this.logs = [];
        // Notify clear? Or just let UI handle it on next update?
        // Ideally emit a clear event or just let UI refresh.
        // For simplicity, we won't emit a special clear event strictly yet, 
        // but UI usually just appends. 
        // Let's add a special 'CLEAR' event handling if needed, or just let UI call getHistory().
    }
}

export const devLogger = new DevLogger();

```

### FILE: frontend\src\utils\gameLogic.test.ts
```ts

import { describe, it, expect } from 'vitest';
import { canDeclareAkka } from './gameLogic';
import { CardModel, Suit, Rank } from '../types';

// Helper to create card
const createCard = (suit: Suit, rank: Rank): CardModel => ({
    id: `${suit}-${rank}`,
    suit,
    rank,
    value: 0
});

describe('canDeclareAkka', () => {
    const tableEmpty: { card: CardModel }[] = [];
    const currentRoundTricksEmpty: { cards: CardModel[] }[] = [];
    const modeHokum = 'HOKUM';
    const modeSun = 'SUN';
    const trumpSpades = Suit.Spades;

    it('should return false if not HOKUM', () => {
        const card = createCard(Suit.Hearts, Rank.Ace);
        expect(canDeclareAkka(card, [card], tableEmpty, modeSun, null, currentRoundTricksEmpty)).toBe(false);
    });

    it('should return false if not leading (table not empty)', () => {
        const card = createCard(Suit.Hearts, Rank.Ace);
        const table = [{ card: createCard(Suit.Clubs, Rank.Ten) }];
        expect(canDeclareAkka(card, [card], table, modeHokum, trumpSpades, currentRoundTricksEmpty)).toBe(false);
    });

    it('should return false if card is Trump', () => {
        const card = createCard(Suit.Spades, Rank.Ace);
        expect(canDeclareAkka(card, [card], tableEmpty, modeHokum, trumpSpades, currentRoundTricksEmpty)).toBe(false);
    });

    it('should return false for absolute master (Ace of non-trump) as per exclusion rule', () => {
        const card = createCard(Suit.Hearts, Rank.Ace);
        expect(canDeclareAkka(card, [card], tableEmpty, modeHokum, trumpSpades, currentRoundTricksEmpty)).toBe(false);
    });

    it('should return true for King if Ace and Ten are played (Graveyard)', () => {
        const card = createCard(Suit.Hearts, Rank.King);
        // Ace and Ten played
        const tricks = [{ cards: [createCard(Suit.Hearts, Rank.Ace), createCard(Suit.Hearts, Rank.Ten)] }];

        expect(canDeclareAkka(card, [card], tableEmpty, modeHokum, trumpSpades, tricks)).toBe(true);
    });

    it('should return false for King if Ace is played but Ten is missing', () => {
        const card = createCard(Suit.Hearts, Rank.King);
        const tricks = [{ cards: [createCard(Suit.Hearts, Rank.Ace)] }]; // Ten is missing
        expect(canDeclareAkka(card, [card], tableEmpty, modeHokum, trumpSpades, tricks)).toBe(false);
    });

    it('should return false for King if Ace is suspected (not played and not in hand)', () => {
        const card = createCard(Suit.Hearts, Rank.King);
        // Ace is missing (opponent has it presumably)
        expect(canDeclareAkka(card, [card], tableEmpty, modeHokum, trumpSpades, currentRoundTricksEmpty)).toBe(false);
    });

    it('should return false for King if I hold the Ace (I should play Ace first)', () => {
        const king = createCard(Suit.Hearts, Rank.King);
        const ace = createCard(Suit.Hearts, Rank.Ace);
        const hand = [king, ace];

        expect(canDeclareAkka(king, hand, tableEmpty, modeHokum, trumpSpades, currentRoundTricksEmpty)).toBe(false);
    });

    it('should return true for 10 if A and K are played', () => {
        // In Hokum Non-Trump: A > 10 > K > Q ... 
        // Wait, Strength Order for Non-Trump Hokum?
        // GameLogic: STRENGTH_ORDER.HOKUM_NORMAL = [7, 8, 9, J, Q, K, 10, A]
        // So 10 is stronger than K.
        // So if I have 10, I only need to check Ace.

        const ten = createCard(Suit.Hearts, Rank.Ten);
        // Ace played.
        const tricks = [{ cards: [createCard(Suit.Hearts, Rank.Ace)] }];
        // I have K and Q in hand.
        const hand = [ten, createCard(Suit.Hearts, Rank.King)];

        // 10 is 2nd strongest. Ace played. 10 is now master.
        expect(canDeclareAkka(ten, hand, tableEmpty, modeHokum, trumpSpades, tricks)).toBe(true);
    });
});

```

### FILE: frontend\src\utils\gameLogic.ts (SKIPPED - >10KB)
### FILE: frontend\src\utils\index.ts
```ts
export * from './devLogger';
// Tests excluded from barrel export

```

### FILE: frontend\src\utils\scoring.test.ts
```ts

import { describe, it, expect } from 'vitest';
import { calculateFinalScore, POINT_VALUES } from './gameLogic';
import { Rank, ProjectType } from '../types';

describe('Scoring System', () => {

    describe('Point Values', () => {
        it('should have correct point values for SUN', () => {
            expect(POINT_VALUES.SUN[Rank.Ace]).toBe(11);
            expect(POINT_VALUES.SUN[Rank.Ten]).toBe(10);
            expect(POINT_VALUES.SUN[Rank.King]).toBe(4);
            expect(POINT_VALUES.SUN[Rank.Queen]).toBe(3);
            expect(POINT_VALUES.SUN[Rank.Jack]).toBe(2); // In Sun, Jack is weak
            expect(POINT_VALUES.SUN[Rank.Nine]).toBe(0);
            expect(POINT_VALUES.SUN[Rank.Eight]).toBe(0);
            expect(POINT_VALUES.SUN[Rank.Seven]).toBe(0);
        });

        it('should have correct point values for HOKUM', () => {
            expect(POINT_VALUES.HOKUM[Rank.Jack]).toBe(20); // Top trump usually
            expect(POINT_VALUES.HOKUM[Rank.Nine]).toBe(14);
            expect(POINT_VALUES.HOKUM[Rank.Ace]).toBe(11);
            expect(POINT_VALUES.HOKUM[Rank.Ten]).toBe(10);
            expect(POINT_VALUES.HOKUM[Rank.King]).toBe(4);
            expect(POINT_VALUES.HOKUM[Rank.Queen]).toBe(3);
            expect(POINT_VALUES.HOKUM[Rank.Eight]).toBe(0);
            expect(POINT_VALUES.HOKUM[Rank.Seven]).toBe(0);
        });
    });

    describe('calculateFinalScore - SUN', () => {
        // Formula: Round( (RawPoints + Projects) * 2 / 10 )

        it('should calculate normal score correctly', () => {
            // 15 Points -> 30 -> 3
            expect(calculateFinalScore(15, 0, false, 'SUN', 1, true)).toBe(3);
        });

        it('should calculate max card score correctly', () => {
            // Max Card Points in Sun = 130. 
            // 130 * 2 / 10 = 26.
            expect(calculateFinalScore(130, 0, false, 'SUN', 1, true)).toBe(26);
        });

        it('should include projects in calculation', () => {
            // 15 Cards + 100 Project = 115.
            // 115 * 2 = 230. / 10 = 23.
            expect(calculateFinalScore(15, 100, false, 'SUN', 1, true)).toBe(23);
        });

        it('should handle Kaboot (Capot) in SUN', () => {
            // Kaboot in Sun is fixed at 44 (if established rules usually say 26*2? or 44 fixed?)
            // Our code returns 44.
            expect(calculateFinalScore(130, 0, true, 'SUN', 1, true)).toBe(44);
        });

        it('should return 0 if losing a Kaboot round', () => {
            expect(calculateFinalScore(10, 0, true, 'SUN', 1, false)).toBe(0);
        });
    });

    describe('calculateFinalScore - HOKUM', () => {
        // Formula: Round( (RawPoints + Projects) / 10 )

        it('should calculate normal score correctly', () => {
            // 15 Points -> 1.5 -> 2
            expect(calculateFinalScore(15, 0, false, 'HOKUM', 1, true)).toBe(2);
            // 14 Points -> 1.4 -> 1
            expect(calculateFinalScore(14, 0, false, 'HOKUM', 1, true)).toBe(1);
        });

        it('should calculate max card score correctly', () => {
            // Max Points in Hokum = 152 (162 total including last trick bonus usually? The input is RAW points).
            // Sum of all cards in Hokum = 152.
            // 152 / 10 = 15.2 -> 15.
            expect(calculateFinalScore(152, 0, false, 'HOKUM', 1, true)).toBe(15);
        });

        it('should include projects in calculation', () => {
            // 20 Cards + 100 Project = 120.
            // 120 / 10 = 12.
            expect(calculateFinalScore(20, 100, false, 'HOKUM', 1, true)).toBe(12);
        });

        it('should handle Kaboot in HOKUM', () => {
            // Kaboot in Hokum = 25 + (Projects / 10)?
            // Case 1: No projects. 25.
            expect(calculateFinalScore(152, 0, true, 'HOKUM', 1, true)).toBe(25);

            // Case 2: With Projects (e.g. 100). 
            // 25 + (100 / 10) = 35.
            expect(calculateFinalScore(152, 100, true, 'HOKUM', 1, true)).toBe(35);
        });
    });

    describe('Score Doubling', () => {
        it('should double the score if level is 2', () => {
            // Sun: 15 pts -> 3. Doubled -> 6.
            expect(calculateFinalScore(15, 0, false, 'SUN', 2, true)).toBe(6);
        });

        it('should quadruple the score if level is 4 (if supported)', () => {
            // Hokum: 20 pts -> 2. Quadrupled -> 8.
            expect(calculateFinalScore(20, 0, false, 'HOKUM', 4, true)).toBe(8); // Assuming 4 is valid multiplier
        });
    });

});

```

### FILE: game_engine\arena.py
```py
import time
import json
import logging
from game_engine.logic.game import Game
from game_engine.models.player import Player
from ai_worker.strategies.playing import PlayingStrategy
from ai_worker.strategies.bidding import BiddingStrategy
from ai_worker.bot_context import BotContext
from game_engine.logic.utils import scan_hand_for_projects

# Configure logging for Arena (suppress debug noise)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("Arena")

class Arena:
    def __init__(self):
        self.playing_strategy = PlayingStrategy()
        self.bidding_strategy = BiddingStrategy()

    def run_match(self, match_id="sim_1"):
        """
        Runs a full headless match between self-playing bots.
        Returns the full match history and result.
        """
        game = Game(room_id=match_id)
        
        # Add Players
        names = ["Bot_Bottom", "Bot_Right", "Bot_Top", "Bot_Left"]
        for i, name in enumerate(names):
            p = game.add_player(f"sid_{i}", name)
            p.is_bot = True
            
        # Start Game (Deals cards, sets phase to BIDDING)
        success = game.start_game()
        if not success:
            return {"error": "Failed to start game (not enough players?)"}
        
        steps = 0
        MAX_STEPS = 50000 # Safety limit (approx 2000 steps per game)
        
        while max(game.match_scores.values()) < 152 and steps < MAX_STEPS:
            steps += 1
            # 1. Get State
            if hasattr(game, 'bidding_engine') and game.bidding_engine:
                 game.bidding_engine.GABLAK_DURATION = -1 # Force Expiry
            
            if steps % 10000 == 0:
                 logger.info(f"Match {match_id} Step {steps}. Scores: {game.match_scores}")

            current_player_idx = game.current_turn
            
            # 1. Get State
            sid = game.players[current_player_idx].id
            state = game.get_game_state()
            ctx = BotContext(state, current_player_idx)
            
            decision = None
            
            # 2. Decision Logic
            # Note: We group all bidding-related phases
            if game.phase in ["BIDDING", "DOUBLING", "VARIANT_SELECTION", "GABLAK_WINDOW"]:
                try:
                    decision = self.bidding_strategy.get_decision(ctx)
                    action = decision.get('action')
                    suit = decision.get('suit')
                    
                    # Apply
                    res = game.handle_bid(current_player_idx, action, suit)
                    if res.get('error'):
                        logger.warning(f"Bid Error ({action}): {res}")
                        # Fallback to PASS to unblock
                        game.handle_bid(current_player_idx, "PASS")
                        
                except Exception as e:
                    logger.error(f"Bidding Crash: {e}")
                    game.handle_bid(current_player_idx, "PASS")
            elif game.phase == "PLAYING":
                try:
                    decision = self.playing_strategy.get_decision(ctx)
                    card_idx = decision.get('cardIndex', 0)
                    
                    # Calculate Projects if Trick 1
                    metadata = {}
                    if len(game.round_history) == 0:
                         # Scan for projects
                         # Note: ctx.hand is List[Card]. game.game_mode is 'SUN'/'HOKUM'
                         if game.game_mode:
                              projects = scan_hand_for_projects(ctx.hand, game.game_mode)
                              if projects:
                                   metadata['declarations'] = projects
                                   # logger.info(f"P{current_player_idx} Declarations: {[p['type'] for p in projects]}")

                    # Apply
                    res = game.play_card(current_player_idx, card_idx, metadata)
                    
                    if res.get('error'):
                         logger.warning(f"Play Error ({card_idx}): {res}")
                         # Fallback: Try playing card 0, then 1...
                         for k in range(len(ctx.hand)):
                             res_retry = game.play_card(current_player_idx, k)
                             if not res_retry.get('error'):
                                 break
                except Exception as e:
                     logger.error(f"Playing Crash: {e}")
                     # Try to recover?
                     pass
            
            elif game.phase == "FINISHED":
                 # Round Finished. Start Next Round.
                 # Note: start_game() in current engine preserves match scores but re-rolls dealer (known quirk)
                 game.start_game()
                 logger.info(f"Round Finished. Scores: {game.match_scores}. Starting next round.")
                 
            else:
                # Should not happen in headless unless phase drift
                logger.warning(f"Unknown Phase in Arena: {game.phase}")
                break

        return {
            "match_id": match_id,
            "winner": "us" if game.match_scores["us"] >= 152 else ("them" if game.match_scores["them"] >= 152 else None),
            "steps": steps,
            "final_scores": game.match_scores,
            "history_length": len(game.full_match_history),
            "match_history": game.full_match_history
        }

if __name__ == "__main__":
    arena = Arena()
    start = time.time()
    result = arena.run_match()
    duration = time.time() - start
    print(f"Match Finished in {duration:.2f}s")
    print(f"Winner: {result['winner']}")
    print(f"History Rounds: {result['history_length']}")

```

### FILE: game_engine\__init__.py
```py

```

### FILE: game_engine\logic\bidding_engine.py (SKIPPED - >10KB)
### FILE: game_engine\logic\forensic.py (SKIPPED - >10KB)
### FILE: game_engine\logic\game.py (SKIPPED - >10KB)
### FILE: game_engine\logic\project_manager.py (SKIPPED - >10KB)
### FILE: game_engine\logic\qayd_manager.py
```py

import time
import logging
from typing import Dict, Any, Optional

from game_engine.models.constants import GamePhase
from server.logging_utils import log_event, logger

# Avoid circular imports
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from game_engine.logic.game import Game

class QaydManager:
    def __init__(self, game: 'Game'):
        self.game = game
        self.state = {
            'active': False,
            'reporter': None,
            'reason': None,
            'status': 'NONE', # NONE, INVESTIGATING, REVIEW, RESOLVED
            'target_play': None,
            'verdict_message': None,
            'crime_card_index': -1,
            'proof_card_index': -1,
            'loser_team': None,
            'penalty_points': 0
        }

    def reset(self):
        """Reset state for new round"""
        self.state = {
            'active': False,
            'reporter': None,
            'reason': None,
            'status': 'NONE',
            'target_play': None,
            'verdict_message': None,
            'crime_card_index': -1,
            'proof_card_index': -1,
            'loser_team': None,
            'penalty_points': 0
        }

    def initiate_challenge(self, player_index: int) -> Dict[str, Any]:
        """
        Starts a Forensic Challenge (Qayd).
        Pauses the game and sets state to CHALLENGE.
        """
        if self.game.phase != GamePhase.PLAYING.value:
             return {"error": "Can only challenge during Playing phase."}
        
        if self.state.get('active'):
             return {"error": "Challenge already active."}
             
        self.game.phase = GamePhase.CHALLENGE.value
        self.game.pause_timer()
        
        player = self.game.players[player_index]
        self.state['active'] = True
        self.state['reporter'] = player.position
        self.state['status'] = 'INVESTIGATING'
        self.state['reason'] = None
        
        log_event("CHALLENGE_STARTED", self.game.room_id, details={'reporter': player.position})
        return {"success": True}

    def process_accusation(self, player_index: int, accusation_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validates the accusation using ForensicReferee.
        """
        if self.game.phase != GamePhase.CHALLENGE.value:
             return {"error": "Not in Challenge phase."}
             
        player = self.game.players[player_index]
        if player.position != self.state['reporter']:
             return {"error": "Only the reporter can submit accusation."}
             
        from game_engine.logic.forensic import ForensicReferee
        
        gameState = self.game.get_game_state()
        
        # Call Referee
        verdict = ForensicReferee.validate_accusation(
             game_snapshot=gameState,
             crime_card=accusation_data['crime_card'],
             proof_card=accusation_data['proof_card'],
             violation_type=accusation_data['violation_type']
        )
        
        logger.info(f"FORENSIC VERDICT: {verdict}")
        
        reason = verdict['reason']
        self.state['verdict_message'] = reason
        
        if verdict['is_guilty']:
             # Offender Loses
             offender_pos = accusation_data['crime_card']['playedBy']
             offender = next(p for p in self.game.players if p.position == offender_pos)
             
             reason = f"Qayd PROVEN: {reason}"
             
             # Apply Khasara to Offender Team
             points = verdict.get('penalty_score')
             self.game.trick_manager.apply_khasara(offender.team, reason, points_override=points)
             self.state['status'] = 'RESOLVED'
             self.state['loser_team'] = offender.team
             
        else:
             # Challenger Loses (False Accusation)
             reason = f"Qayd FAILED: {reason}"
             reason = f"Qayd FAILED: {reason}"
             # Logic fix: If accusation fails, applying Khasara to ACCUSER (player.team)
             self.game.trick_manager.apply_khasara(player.team, reason)
             self.state['status'] = 'RESOLVED'
             self.state['loser_team'] = player.team
             
             self.state['status'] = 'RESOLVED'
             self.state['loser_team'] = player.team
             
        # Enrich verdict for Frontend
        verdict['isGuilty'] = verdict['is_guilty']
        verdict['violationType'] = accusation_data['violation_type']
        verdict['accusedPlayer'] = accusation_data['crime_card']['playedBy']
        
        return verdict
        
    def cancel_challenge(self) -> Dict[str, Any]:
        """Cancels changes and resumes game. Handles 'Close' action."""
        logger.info(f"QaydManager.cancel_challenge called. Active: {self.state['active']}, Status: {self.state['status']}")
        
        # DEADLOCK FIX: If status is RESOLVED, we allow closing even if active is accidentally False
        # This ensures the user is never stuck looking at a Result screen
        if not self.state['active'] and self.state['status'] != 'RESOLVED':
             return {"error": "No active challenge"}
             
        # Capture status before clearing
        was_resolved = (self.state['status'] == 'RESOLVED')
             
        self.state['active'] = False
        self.state['status'] = 'NONE'
        self.state['reporter'] = None
        
        # Resume Game
        # Only set phase to PLAYING if we haven't already finished the round
        if not was_resolved:
             self.game.phase = GamePhase.PLAYING.value
             logger.info("Qayd Cancelled (False Alarm/User Cancel) -> Game Phase PLAYING")
        else:
             logger.info("Qayd Closed (Result Viewed) -> Game Phase preserved (FINISHED/GAMEOVER)")
             
        self.game.timer_paused = False
        
        # Force unlocking game (handled by caller usually, but good to be safe)
        if hasattr(self.game, 'is_locked'):
             self.game.is_locked = False
             
        return {"success": True}

```

### FILE: game_engine\logic\referee.py (SKIPPED - >10KB)
### FILE: game_engine\logic\scoring_engine.py
```py
from typing import Dict, List, Tuple
from server.logging_utils import logger

class ScoringEngine:
    def __init__(self, game):
        self.game = game

    def resolve_project_scores(self) -> Tuple[int, int, List[Dict], List[Dict]]:
        """Resolves Mashaari (Projects) and calculates points."""
        project_abnat_us = 0
        project_abnat_them = 0
        winning_projects_us = []
        winning_projects_them = []

        for pos, projects in self.game.declarations.items():
            player = next((p for p in self.game.players if p.position == pos), None)
            if not player: continue
            
            for proj in projects:
                score = proj['score']
                item = {'type': proj['type'], 'rank': proj['rank'], 'suit': proj.get('suit'), 'owner': pos, 'score': score}
                
                if player.team == 'us':
                    project_abnat_us += score
                    winning_projects_us.append(item)
                else:
                    project_abnat_them += score
                    winning_projects_them.append(item)
                    
        return project_abnat_us, project_abnat_them, winning_projects_us, winning_projects_them

    def calculate_card_abnat(self) -> Tuple[int, int, Dict[str, int]]:
        """Calculates raw card points (Abnat) for both teams including Last Trick bonus."""
        card_abnat_us = 0
        card_abnat_them = 0
        
        for trick in self.game.round_history:
             winner_pos = trick['winner']
             winner_p = next(p for p in self.game.players if p.position == winner_pos)
             if winner_p.team == 'us': card_abnat_us += trick['points']
             else: card_abnat_them += trick['points']
             
        # Last Trick Bonus (10 Raw Points / Abnat)
        last_trick_bonus = {'us': 0, 'them': 0}
        if self.game.round_history:
            last_winner_pos = self.game.round_history[-1]['winner']
            last_p = next((p for p in self.game.players if p.position == last_winner_pos), None)
            if last_p: 
                 if last_p.team == 'us': last_trick_bonus['us'] = 10
                 else: last_trick_bonus['them'] = 10
        
        card_abnat_us += last_trick_bonus['us']
        card_abnat_them += last_trick_bonus['them']
        
        return card_abnat_us, card_abnat_them, last_trick_bonus

    def _calculate_score_for_team(self, raw_val: int, mode: str) -> int:
        if mode == 'SUN':
             val = (raw_val * 2) / 10.0
             decimal_part = val % 1
             if decimal_part >= 0.5:
                  return int(val) + 1
             else:
                  return int(val)
        else:
             val = raw_val / 10.0
             decimal_part = val % 1
             if decimal_part > 0.5: 
                  return int(val) + 1
             else:
                  return int(val)

    def calculate_game_points_with_tiebreak(self, card_points_us, card_points_them, ardh_points_us, ardh_points_them, bidder_team):
        raw_us = card_points_us + ardh_points_us
        raw_them = card_points_them + ardh_points_them
        
        gp_us = self._calculate_score_for_team(raw_us, self.game.game_mode)
        gp_them = self._calculate_score_for_team(raw_them, self.game.game_mode)
        
        total_gp = gp_us + gp_them
        target_total = 26 if self.game.game_mode == 'SUN' else 16
        
        # If mismatch fix it.
        if total_gp < target_total:
             diff = target_total - total_gp
             if bidder_team == 'us':
                  gp_them += diff
             else:
                  gp_us += diff
        elif total_gp > target_total:
             pass

        if gp_us > gp_them:
             winner = 'us'
        elif gp_them > gp_us:
             winner = 'them'
        else:
             winner = bidder_team 
        
        return {
            'game_points': {'us': gp_us, 'them': gp_them},
            'lost_in_rounding': {'us': 0, 'them': 0}, 
            'counting_team': 'us', 
            'winner': winner
        }

    def calculate_final_scores(self):
        """Orchestrates the entire scoring calculation for the round end."""
        
        # 1. Abnat Calculation
        card_abnat_us, card_abnat_them, last_trick_bonus = self.calculate_card_abnat()
        
        # 2. Project Calculation
        project_abnat_us, project_abnat_them, winning_projects_us, winning_projects_them = self.resolve_project_scores()

        # 3. Final Round Score Logic
        total_abnat_us = card_abnat_us + project_abnat_us
        total_abnat_them = card_abnat_them + project_abnat_them

        bidder_pos = self.game.bid.get('bidder')
        bidder_team = 'them' 
        if bidder_pos:
            bidder_p = next((p for p in self.game.players if p.position == bidder_pos), None)
            if bidder_p: bidder_team = bidder_p.team

        game_points_us = 0
        game_points_them = 0
        
        # --- KABOOT CHECK ---
        tricks_us = sum(1 for t in self.game.round_history if next(p for p in self.game.players if p.position == t['winner']).team == 'us')
        tricks_them = sum(1 for t in self.game.round_history if next(p for p in self.game.players if p.position == t['winner']).team == 'them')
        
        kaboot_winner = None
        if tricks_them == 0 and tricks_us > 0: kaboot_winner = 'us'
        elif tricks_us == 0 and tricks_them > 0: kaboot_winner = 'them'
        
        ardh_us = last_trick_bonus['us']
        ardh_them = last_trick_bonus['them']
        
        pure_card_us = card_abnat_us - ardh_us
        pure_card_them = card_abnat_them - ardh_them

        if kaboot_winner:
            if self.game.game_mode == 'SUN':
                if kaboot_winner == 'us': game_points_us = 44
                else: game_points_them = 44
            else: # HOKUM
                if kaboot_winner == 'us': game_points_us = 25
                else: game_points_them = 25
        else:
            gp_result = self.calculate_game_points_with_tiebreak(
                pure_card_us, pure_card_them,
                ardh_us, ardh_them,
                bidder_team
            )
            
            game_points_us = gp_result['game_points']['us']
            game_points_them = gp_result['game_points']['them']
        
        # Add Project Game Points (Applied to both Kaboot and Normal results)
        if self.game.game_mode == 'SUN':
            proj_gp_us = (project_abnat_us * 2) // 10
            proj_gp_them = (project_abnat_them * 2) // 10
        else:
            proj_gp_us = project_abnat_us // 10
            proj_gp_them = project_abnat_them // 10
        
        game_points_us += proj_gp_us
        game_points_them += proj_gp_them

        score_us = game_points_us
        score_them = game_points_them
            
        # Khasara Check
        khasara = False
        
        if self.game.sawa_failed_khasara:
            khasara = True
            claimer_pos = self.game.sawa_state['claimer']
            if claimer_pos in ['Bottom', 'Top']: bidder_team = 'us'
            else: bidder_team = 'them'
        elif not kaboot_winner: 
            if bidder_team == 'us':
                if score_us <= score_them: khasara = True
            else: # them
                if score_them <= score_us: khasara = True
                
        # Apply Khasara Penalty
        if khasara: 
            total_pot = score_us + score_them
            if bidder_team == 'us':
                score_us = 0
                score_them = total_pot
            else:
                score_them = 0
                score_us = total_pot
        
        # Doubling (Gahwa Chain)
        multiplier = 1
        if self.game.doubling_level >= 2:
            if self.game.doubling_level >= 100: # GAHWA 
                multiplier = 1 
                if score_us > 0 and score_them == 0: 
                    score_us = 152
                elif score_them > 0 and score_us == 0:
                    score_them = 152
            else:
                multiplier = self.game.doubling_level # 2, 3, 4
                score_us *= multiplier
                score_them *= multiplier
        
        is_kaboot_us = (kaboot_winner == 'us')
        is_kaboot_them = (kaboot_winner == 'them')

        round_result = {
            'roundNumber': len(self.game.past_round_results) + 1,
            'bid': self.game.bid, 
            'us': {
                'aklat': pure_card_us, 
                'ardh': ardh_us,
                'projectPoints': project_abnat_us,
                'abnat': card_abnat_us + project_abnat_us, 
                'result': score_us,
                'isKaboot': is_kaboot_us,
                'multiplierApplied': multiplier,
                'projects': winning_projects_us
            },
            'them': {
                'aklat': pure_card_them,
                'ardh': ardh_them,
                'projectPoints': project_abnat_them,
                'abnat': card_abnat_them + project_abnat_them, 
                'result': score_them,
                'isKaboot': is_kaboot_them,
                'multiplierApplied': multiplier,
                'projects': winning_projects_them
            },
            'winner': 'us' if score_us > score_them else 'them',
            'baida': (score_us == score_them),
            'project': self.game.game_mode 
        }
        
        return round_result, score_us, score_them

```

### FILE: game_engine\logic\timer_manager.py
```py
import time
import logging

logger = logging.getLogger(__name__)

class TimerManager:
    """
    Centralized timer logic for the Game Engine.
    Handles duration tracking, expiration checks, and drift calculations.
    """
    def __init__(self, default_duration=30):
        self.start_time = 0
        self.duration = default_duration
        self.active = False
        self.last_reset_time = 0

    def reset(self, duration=None):
        """Reset the timer with an optional new duration."""
        if duration is not None:
            self.duration = duration
        
        self.start_time = time.time()
        self.active = True
        self.last_reset_time = self.start_time
        self.paused = False
        self.paused_at = 0
        # logger.info(f"Timer RESET. Duration: {self.duration}s")

    def stop(self):
        """Stop the timer."""
        self.active = False

    def pause(self):
        """Pause the timer, freezing the elapsed time."""
        if not self.active or self.paused:
            return
        self.paused_at = time.time()
        self.paused = True
        logger.info("Timer PAUSED")

    def resume(self):
        """Resume the timer, adjusting start_time for the paused duration."""
        if not self.active or not self.paused:
            return
        
        pause_duration = time.time() - self.paused_at
        self.start_time += pause_duration # Shift start time forward
        self.paused = False
        logger.info(f"Timer RESUMED (Paused for {pause_duration:.2f}s)")

    def get_time_elapsed(self):
        """Return seconds elapsed since start."""
        if not self.active:
            return 0
        
        if self.paused:
            # If paused, elapsed time is fixed at the pause moment
            return self.paused_at - self.start_time
            
        return time.time() - self.start_time

    def get_time_remaining(self):
        """Return seconds remaining. Returns 0 if expired or inactive."""
        if not self.active:
            return 0
        elapsed = self.get_time_elapsed() # Handles paused state
        return max(0, self.duration - elapsed)

    def is_expired(self):
        """Check if timer has exceeded duration."""
        if not self.active or self.paused:
            return False
        return self.get_time_elapsed() > self.duration
        
    def get_lag(self):
        """Return how many seconds PAST the deadline we are."""
        if not self.active or self.paused:
            return 0
        elapsed = self.get_time_elapsed()
        return max(0, elapsed - self.duration)

```

### FILE: game_engine\logic\trick_manager.py (SKIPPED - >10KB)
### FILE: game_engine\logic\utils.py
```py
from game_engine.models.constants import ORDER_PROJECTS, ORDER_SUN, ORDER_HOKUM

def sort_hand(hand, game_mode, trump_suit=None):
    """Sorts a hand of cards based on the game mode."""
    def sort_key(card):
        # Primary sort: Suit
        # Secondary sort: Rank strength
        
        # Determine Suit Order (Alternating Colors: Red, Black, Red, Black)
        # Hearts(R), Spades(B), Diamonds(R), Clubs(B)
        suit_order = {
            '‚ô•': 0, '‚ô†': 1, '‚ô¶': 2, '‚ô£': 3
        }
        
        # Adjust suit order for Hokum: Trump first
        current_suit_order = suit_order[card.suit]
        if game_mode == 'HOKUM' and trump_suit and card.suit == trump_suit:
             current_suit_order = -1 # Trump always first
             
        # Determine Rank Strength
        # User feedback: "sequence are not good".
        # Current: A, K, Q, J... (Descending)
        # Proposed: 7, 8, 9, 10, J, Q, K, A (Ascending)
        # This often makes reading "runs" easier (e.g. 7-8-9 vs 9-8-7).
        
        # ORDER_PROJECTS = ['A', 'K', 'Q', 'J', '10', '9', '8', '7']
        # Top down.
        # We want Bottom Up.
        # Index of A is 0. Index of 7 is 7.
        # To get 7 first, we want smaller key for 7.
        # If we use reverse index: 7->0, A->7.
        # Or -index: A->0, 7->-7. (Descending output if sorting ascendingly? No).
        # Python sorts Low to High.
        # If we want 7 (Index 7) to be FIRST (Low), and A (Index 0) to be LAST (High).
        # We need Key(7) < Key(A).
        # CURRENT: Key(A)=0, Key(7)=7. Sort: 0..7 -> A..7. (Descending Rank).
        # NEW GOAL: 7..A.
        # We need Key(7) < Key(A).
        # Let's use negative index? Key(A)=0, Key(7)=-7. Sort: -7..0 -> 7..A.
        # Wait, -7 < 0. So 7 comes first.
        # So using NEGATIVE index of ORDER_PROJECTS gives us 7->A.
        
        strength = -ORDER_PROJECTS.index(card.rank)
        
        return (current_suit_order, strength) # Group by suit, then 7 -> A sequence
        
    return sorted(hand, key=sort_key)

def add_sequence_project(projects_list, cards, game_mode):
    length = len(cards)
    high_rank = cards[0].rank # First is highest because sorted by ORDER_PROJECTS (A..7)
    
    if length >= 5: # 100 -> 100 Abnat
        projects_list.append({'type': 'HUNDRED', 'rank': high_rank, 'score': 100, 'kind': 'SEQ', 'cards': cards})
    elif length == 4: # 50 -> 50 Abnat
        projects_list.append({'type': 'FIFTY', 'rank': high_rank, 'score': 50, 'kind': 'SEQ', 'cards': cards})
    elif length == 3: # Sira -> 20 Abnat
        projects_list.append({'type': 'SIRA', 'rank': high_rank, 'score': 20, 'kind': 'SEQ', 'cards': cards})

def scan_hand_for_projects(hand, game_mode):
    """
    Scans a hand to find ALL valid projects.
    Hierarchy:
    - 400 (4 Aces in Sun) - Distinct from sequences usually.
    - 100 (4 of a Kind: K, Q, J, 10).
    - Sequences (100, 50, Sira).
    
    Returns a list of dicts: [{'type': 'SIRA', 'rank': 'A', 'score': 4}, ...]
    """
    projects = []
    
    # Sort hand by rank index (A..7) for 4-kind check and Suit/Rank for sequences
    # Helper to get rank index
    ranks = [c.rank for c in hand]
    rank_counts = {r: ranks.count(r) for r in set(ranks)}
    
    # 1. Check 4-of-a-Kind (400, 100)
    # These usually DO NOT consume cards for sequences? (Standard: They are independent)
    # i.e. You can have 4 Aces (400) AND A-K-Q (Sira).
    
    # 1. Check 4-of-a-Kind (400, 100)
    for r, count in rank_counts.items():
        if count == 4:
            if r == 'A' and game_mode == 'SUN':
                # 400 Project -> 200 Abnat (Raw) -> 40 Game Points (Sun)
                projects.append({'type': 'FOUR_HUNDRED', 'rank': 'A', 'score': 200, 'cards': [c for c in hand if c.rank == 'A']})
            elif r in ['K', 'Q', 'J', '10', 'A']:
                # 100 Project -> 100 Abnat (Raw)
                t = 'HUNDRED'
                projects.append({'type': t, 'rank': r, 'score': 100, 'kind': '4KIND', 'cards': [c for c in hand if c.rank == r]})

    # 2. Check Sequences
    # Group by Suit
    suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£']
    for s in suits:
        suit_cards = sorted([c for c in hand if c.suit == s], key=lambda x: ORDER_PROJECTS.index(x.rank)) # Sort A, K, Q...
        # Check for consecutive sequences
        if not suit_cards: continue
        
        # Iterate to find longest sequences
        current_seq = [suit_cards[0]]
        
        for i in range(1, len(suit_cards)):
            prev = suit_cards[i-1]
            curr = suit_cards[i]
            idx_prev = ORDER_PROJECTS.index(prev.rank)
            idx_curr = ORDER_PROJECTS.index(curr.rank)
            
            if idx_curr == idx_prev + 1:
                current_seq.append(curr)
            else:
                # End of a sequence
                if len(current_seq) >= 3:
                     add_sequence_project(projects, current_seq, game_mode)
                current_seq = [curr]
        
        # Check last seq
        if len(current_seq) >= 3:
            add_sequence_project(projects, current_seq, game_mode)
            
    return projects

def validate_project(hand, type_req, game_mode, trump_suit=None):
    # Refactored to use scan_hand
    # This function is now mostly a verificator for specific request?
    # Or legacy. If frontend asks "Declare SIRA", we check if ANY Sira exists.
    
    all_projects = scan_hand_for_projects(hand, game_mode)
    
    # Filter by requested type
    matches = [p for p in all_projects if p['type'] == type_req]
    
    if matches:
        # Return the best one? Or just the first valid one?
        # Typically we declare the BEST one.
        # But if user has two Siras, does he declare Sira once or twice?
        # Usually button just says "Sira". We register ALL Siras?
        # Return the 'best' match for scoring validation
        best = matches[0] # They are usually sorted or processing order
        return {'valid': True, 'score': best['score'], 'rank': best['rank'], 'type': best['type'], 'matches': matches}
    
    # Special Case: Baloot
    if type_req == 'BALOOT' and game_mode == 'HOKUM' and trump_suit:
        has_king = any(c.rank == 'K' and c.suit == trump_suit for c in hand)
        has_queen = any(c.rank == 'Q' and c.suit == trump_suit for c in hand)
        if has_king and has_queen:
             return {'valid': True, 'score': 20, 'rank': 'K', 'type': 'BALOOT'}
             
    return {'valid': False}

def get_project_rank_order(rank_char):
    """Helper to get rank order for comparison (A > K > Q...). Lower index is better."""
    return ORDER_PROJECTS.index(rank_char)

def compare_projects(p1, p2, game_mode, dealer_index, p1_index, p2_index):
    """
    Compare two projects to decide which is stronger.
    Returns:
       1 if p1 > p2
      -1 if p2 > p1
       0 if p1 == p2 (Strict tie in value/rank)
       
    Hierarchy:
    1. Score (Type Strength): 400 > 100 (Seq 5 or 4Kind) > 50 > Sira
       - Note: 4Kind 100 vs Seq 5 100? Usually 4Kind > Seq. Or score counts?
       - Standard Baloot: 400 > 100 > 50 > Sira.
       - If scores equal (e.g. both 100), check type?
       - Usually 4Kind beats Sequence of same score? Or just Rank?
       - Let's use Score First.
    
    2. Rank Strength: A > K > Q...
    
    3. Position (Distance from Dealer): Handled OUTSIDE or passed in indices?
       Passed indices to help break tie here or return 0 and handle outside.
       Let's handle purely Value/Rank here.
    """
    
    # Priority Scores dict
    # 400 > 100 > 50 > Sira (Sira=Score 4 or 2)
    # Map types to abstract strength levels if scores effectively same?
    def get_tier(p):
        t = p['type']
        if t == 'FOUR_HUNDRED': return 4
        if t == 'HUNDRED': return 3
        if t == 'FIFTY': return 2
        if t == 'SIRA': return 1
        return 0

    tier1 = get_tier(p1)
    tier2 = get_tier(p2)
    
    if tier1 > tier2: return 1
    if tier2 > tier1: return -1
    
    # Same Tier. Compare Rank.
    r1 = get_project_rank_order(p1['rank']) # Lower is better (0=Ace)
    r2 = get_project_rank_order(p2['rank'])
    
    if r1 < r2: return 1 # p1 has better rank (lower index)
    if r2 < r1: return -1
    
    # Strict Tie in Value and Rank.
    # Winner is one closer to Dealer (Who played first).
    # Turn Order: D+1, D+2, D+3, D.
    # Dist = (PlayerIndex - (DealerIndex + 1)) % 4. Lower is better.
    
    d1 = (p1_index - (dealer_index + 1)) % 4
    d2 = (p2_index - (dealer_index + 1)) % 4
    
    if d1 < d2: return 1
    else: return -1 # d2 < d1 or equal (impossible if indices distinct)

def is_kawesh_hand(hand):
    """
    Checks if a hand qualifies for 'Kawesh' (No court cards: A, K, Q, J, 10).
    Hand must be devoid of these ranks.
    """
    court_ranks = ['A', 'K', 'Q', 'J', '10']
    for card in hand:
         if card.rank in court_ranks:
              return False
    return True

```

### FILE: game_engine\logic\validation.py
```py
from typing import List, Dict, Tuple, Any
from game_engine.models.card import Card
from game_engine.models.constants import ORDER_SUN, ORDER_HOKUM
from server.logging_utils import logger

def get_trick_winner_index(table_cards: List[Dict], game_mode: str, trump_suit: str = None) -> int:
    """
    Determines the index of the current winning card in the table_cards list.
    table_cards expected format: [{'card': CardObject, ...}, ...]
    """
    if not table_cards:
        return -1

    lead_card = table_cards[0]['card']
    lead_suit = _get_suit(lead_card)
    best_idx = 0
    current_best = -1
    
    for i, play in enumerate(table_cards):
        card = play['card']
        card_suit = _get_suit(card)
        card_rank = _get_rank(card)
        strength = -1
        
        if game_mode == "SUN":
            if card_suit == lead_suit:
                try:
                    strength = ORDER_SUN.index(card_rank)
                except ValueError:
                    strength = -1 
        else:
            # HOKUM
            if card_suit == trump_suit:
                try:
                    strength = 100 + ORDER_HOKUM.index(card_rank)
                except ValueError:
                    strength = -1
            elif card_suit == lead_suit:
                try:
                    strength = ORDER_SUN.index(card_rank)
                except ValueError:
                    strength = -1
        
        if strength > current_best:
            current_best = strength
            best_idx = i
            
    return best_idx

def can_beat_trump_card(winning_card: Card, hand: List[Card], trump_suit: str) -> Tuple[bool, List[Card]]:
    """ Returns True if hand contains a trump higher than winning_card. """
    try:
        winning_strength = 100 + ORDER_HOKUM.index(_get_rank(winning_card))
    except ValueError:
        return False, []

    beating_cards = []
    for c in hand:
        if _get_suit(c) == trump_suit:
             try:
                 s = 100 + ORDER_HOKUM.index(_get_rank(c))
                 if s > winning_strength:
                      beating_cards.append(c)
             except ValueError:
                 pass
    return (len(beating_cards) > 0), beating_cards

def _get_suit(card) -> str:
    if hasattr(card, 'suit'): return card.suit
    if isinstance(card, dict): return card.get('suit')
    return None

def _get_rank(card) -> str:
    if hasattr(card, 'rank'): return card.rank
    if isinstance(card, dict): return card.get('rank')
    return None
    
def is_move_legal(
    card: Any, 
    hand: List[Any], 
    table_cards: List[Dict], 
    game_mode: str, 
    trump_suit: str, 
    my_team: str,
    players_team_map: Dict[str, str],
    contract_variant: str = None
) -> bool:
    """
    Pure validation logic for Baloot.
    players_team_map: Dict mapping 'position' -> 'team' ('us', 'them')
    """
    # DEBUG: Verbose Input Logging
    c_suit = _get_suit(card)
    # logger.info(f"VALIDATE: Card={card} (Suit={c_suit}) | Mode={game_mode} | Trump={trump_suit}")
    if table_cards:
         lead = table_cards[0]['card']
         l_suit = _get_suit(lead)
         # logger.info(f"VALIDATE: Table Lead={lead} (Suit={l_suit}) in Table len={len(table_cards)}")
    else:
         pass # logger.info("VALIDATE: Table Empty (Lead)")
         
    # 0. Check Closed Doubling Constraint (Magfool / Locked)
    if not table_cards and contract_variant == 'CLOSED' and game_mode == 'HOKUM':
        card_suit = _get_suit(card)
        if card_suit == trump_suit:
            has_non_trump = any(_get_suit(c) != trump_suit for c in hand)
            if has_non_trump:
                return False

    if not table_cards:
        return True
    
    lead_play = table_cards[0]
    lead_card = lead_play['card']
    lead_suit = _get_suit(lead_card)
    card_suit = _get_suit(card)
    
    # 1. Follow Suit (Mandatory in Sun & Hokum)
    try:
        has_suit = any(_get_suit(c) == lead_suit for c in hand)
        # DEBUG: Log Hand State for Revoke Check
        if table_cards:
             hand_suits = [_get_suit(c) for c in hand]
             # logger.info(f"VALIDATE CHECK: Lead={lead_suit} | Hand Suits={hand_suits} | HasSuit={has_suit}")
    except Exception as e:
        logger.error(f"CRITICAL ERROR in validation.py has_suit check: {e}")
        return True # Fail open to avoid crash
        
    if has_suit:
        if card_suit != lead_suit:
            # logger.info(f"VALIDATE RESULT: ILLEGAL (Revoke) - Played {card_suit} on {lead_suit}")
            return False
            
        # If following suit in Hokum and Lead is Trump, we are good (must follow).
        if game_mode == 'HOKUM' and lead_suit == trump_suit:
             pass 
        else:
             return True

    if game_mode == 'SUN':
        return True # If can't follow suit (or followed correctly above), play anything.
    
    # --- HOKUM STRICT RULES ---
    
    # Determine Current Winner of the Trick
    winner_idx = get_trick_winner_index(table_cards, game_mode, trump_suit)
    curr_winner_play = table_cards[winner_idx]
    curr_winner_pos = curr_winner_play['playedBy']
    
    # Is partner winning?
    winner_team = players_team_map.get(curr_winner_pos)
    is_partner_winning = (winner_team == my_team)
    
    # 2. Partner Winning? -> Play Anything (unless forced to follow suit, handled above)
    if is_partner_winning:
        return True

    # 3. Enemy Winning
    # Must Trump if possible OR Must Over-Trump
    
    has_trump = any(_get_suit(c) == trump_suit for c in hand)
    
    # Case A: Void in Lead Suit
    if lead_suit == trump_suit and has_suit:
         # We are following trump. Must we beat the current winner (who is also trump)?
         can_beat, beating_cards = can_beat_trump_card(curr_winner_play['card'], hand, trump_suit)
         if can_beat:
              # Must play a beating card
              # Check safely
              # beating_cards logic relies on can_beat_trump_card which we might need to update too?
              # Let's inspect can_beat_trump_card next.
              
              if card not in beating_cards:
                   # Try manual check if object identity fails (dicts don't compare equal unless contents same)
                   pass
                   # Actually beating_cards returns list of objects from hand.
                   # If card is from hand, identity check works if usage is consistent.
                   
                   # But let's verify strength manually
                   played_rank = _get_rank(card)
                   winning_rank = _get_rank(curr_winner_play['card'])
                   
                   try:
                       played_strength = 100 + ORDER_HOKUM.index(played_rank)
                       winning_strength = 100 + ORDER_HOKUM.index(winning_rank)
                       if played_strength <= winning_strength:
                           return False 
                   except:
                       return True # Soft fail?
                       
              return True


    # Case B: Void in Lead Suit (Really void)
    if not has_suit:
        if has_trump:
            # Must play Trump
            if _get_suit(card) != trump_suit:
                return False
            
            # Must Over-Trump?
            if _get_suit(curr_winner_play['card']) == trump_suit:
                can_beat, beating_cards = can_beat_trump_card(curr_winner_play['card'], hand, trump_suit)
                if can_beat:
                     if card not in beating_cards: 
                          # Check strength manually just to be safe or rely on list check
                          played_rank = _get_rank(card)
                          winning_rank = _get_rank(curr_winner_play['card'])
                          
                          try:
                              played_strength = 100 + ORDER_HOKUM.index(played_rank)
                              winning_strength = 100 + ORDER_HOKUM.index(winning_rank)
                              if played_strength <= winning_strength:
                                   return False
                          except:
                               pass
            return True

    return True

```

### FILE: game_engine\logic\__init__.py
```py
from .game import Game
from .bidding_engine import BiddingEngine
from .trick_manager import TrickManager
from .project_manager import ProjectManager
from .scoring_engine import ScoringEngine
from . import utils

```

### FILE: game_engine\logic\phases\bidding_phase.py
```py
import logging
import random
from typing import Dict, Optional, Any

from game_engine.logic.phases.challenge_phase import GamePhase
# We might need to import Game dynamically or use TYPE_CHECKING to avoid circular imports
# from game_engine.logic.game import Game

logger = logging.getLogger(__name__)

class BiddingPhase:
    """
    Handles the BIDDING phase logic.
    Delegates to BiddingEngine but orchestrates the turn flow and state updates.
    """
    
    def __init__(self, game_instance):
        self.game = game_instance

    def handle_bid(self, player_index: int, action: str, suit: Optional[str] = None, reasoning: Optional[str] = None) -> Dict[str, Any]:
        """
        Process a bid action from a player.
        """
        if self.game.phase != GamePhase.BIDDING.value:
            return {'success': False, 'error': f"Not in bidding phase (Current: {self.game.phase})"}

        try:
            result = self.game.bidding_engine.process_bid(
                player_idx=player_index,
                action=action,
                suit=suit
            )
        except Exception as e:
             logger.error(f"Error in BiddingEngine: {e}")
             return {'success': False, 'error': str(e)}

        if result['success']:
            # Log reasoning/thought if provided (for AI)
            if reasoning and 'thoughts' in self.game.players[player_index].__dict__:
                 self.game.players[player_index].thoughts.append(f"Bid {action} {suit}: {reasoning}")
            
            # Sync Game state with Engine state
            # This is a critical step: Game.bid dictionary must match Engine.current_bid
            self.game._sync_bid_state()
            
            # Check if bidding is complete
            if self.game.bidding_engine.is_bidding_complete():
                winner = self.game.bidding_engine.get_winner()
                if winner:
                   self.game.complete_deal(winner['player_index'])
                else:
                   # All pass -> redeal
                   logger.info("All players passed. Redealing.")
                   self.game.reset_round_state()
                   self.game.deal_initial_cards()
            else:
                 # Move to next turn
                 self.game.current_turn = self.game.bidding_engine.current_turn
                 self.game.reset_timer()
                 
        logger.info(f"BiddingPhase Handle Bid Result: {result}")
        return result

    def handle_double(self, player_index: int) -> Dict[str, Any]:
        """
        Process a Double/Redouble action.
        """
         # This logic is currently part of handle_bid in some flows, or separate. 
         # In the original game.py, handle_double is separate.
        return self.game.handle_double(player_index) # For now, delegate back or move logic here.
        # Ideally, we move the logic here.

```

### FILE: game_engine\logic\phases\challenge_phase.py (SKIPPED - >10KB)
### FILE: game_engine\logic\phases\playing_phase.py
```py
import logging
import time
from typing import Dict, Optional, Any

from game_engine.models.constants import GamePhase

logger = logging.getLogger(__name__)

class PlayingPhase:
    """
    Handles the PLAYING phase logic (Trick taking).
    """

    def __init__(self, game_instance):
        self.game = game_instance

    def play_card(self, player_index: int, card_idx: int, metadata: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Orchestrates playing a card.
        """
        if self.game.phase != GamePhase.PLAYING.value:
             return {'success': False, 'error': f"Not in playing phase (Current: {self.game.phase})"}
        
        # 1. Validate turn
        if player_index != self.game.current_turn:
             return {'success': False, 'error': 'Not your turn'}
        
        # 2. Get Card
        try:
            player = self.game.players[player_index]
            if not (0 <= card_idx < len(player.hand)):
                return {'success': False, 'error': 'Invalid card index'}
            card = player.hand[card_idx]
        except Exception as e:
             return {'success': False, 'error': str(e)}

        # 3. Check Valid Move
        is_legal = self.game.trick_manager.is_valid_move(card, player.hand)
        
        # 4. Handle Illegal Moves (Strict vs Permissive)
        if not is_legal:
            if self.game.strictMode:
                 return {'success': False, 'error': 'Invalid move (Strict Mode)', 'code': 'INVALID_MOVE'}
            else:
                 # Flag as illegal but proceed (for Qayd)
                 logger.warning(f"Player {player_index} played ILLEGAL card: {card}")
                 if not metadata: metadata = {}
                 metadata['is_illegal'] = True
                 metadata['illegal_reason'] = 'Rule Violation' # capture details if possible

        # 5. Execute Play
        played_card = player.hand.pop(card_idx)
        
        # Ensure metadata has cardId if provided (for frontend tracking)
        if metadata is None: metadata = {}
        
        self.game.table_cards.append({
            'playerId': player.id, 
            'card': played_card,
            'playedBy': player.position,
            'metadata': metadata
        })
        
        # 6. Notify TrickManager / Resolve Trick
        if len(self.game.table_cards) == 4:
            self.game.resolve_trick()
        else:
            # Next player
             self.game.current_turn = (player_index + 1) % 4
             self.game.reset_timer()
             
        return {'success': True, 'card': played_card.to_dict(), 'table': [tc['card'].to_dict() for tc in self.game.table_cards]}


```

### FILE: game_engine\logic\phases\__init__.py
```py
# Phases package

```

### FILE: game_engine\utils\serialization.py
```py
"""
Serialization utilities to prevent JSON serialization errors.
"""
import json
import logging
from typing import Any, Dict

logger = logging.getLogger(__name__)


def ensure_serializable(obj: Any, context: str = "") -> Any:
    """
    Validate that an object is JSON-serializable.
    
    Args:
        obj: Object to validate
        context: Context string for error messages
        
    Returns:
        The object if serializable
        
    Raises:
        TypeError: If object is not JSON-serializable
    """
    try:
        json.dumps(obj)
        return obj
    except TypeError as e:
        error_msg = f"Object not JSON-serializable"
        if context:
            error_msg += f" in {context}"
        error_msg += f": {e}"
        logger.error(error_msg)
        logger.error(f"Problematic object type: {type(obj)}")
        raise TypeError(error_msg)


def serialize_card(card) -> Dict[str, Any]:
    """
    Serialize a Card object to a dict.
    
    Args:
        card: Card object or dict
        
    Returns:
        Dict representation of the card
    """
    if hasattr(card, 'to_dict'):
        return card.to_dict()
    elif isinstance(card, dict):
        return card
    else:
        raise TypeError(f"Cannot serialize card of type {type(card)}")


def serialize_state(state: Dict[str, Any], context: str = "") -> Dict[str, Any]:
    """
    Recursively serialize a state dictionary, converting Card objects to dicts.
    
    Args:
        state: State dictionary to serialize
        context: Context string for error messages
        
    Returns:
        Serialized state dictionary
    """
    serialized = {}
    
    for key, value in state.items():
        if value is None:
            serialized[key] = None
        elif hasattr(value, 'to_dict'):
            # Object with to_dict method (e.g., Card)
            serialized[key] = value.to_dict()
        elif isinstance(value, dict):
            # Nested dict - recurse
            serialized[key] = serialize_state(value, f"{context}.{key}" if context else key)
        elif isinstance(value, list):
            # List - serialize each item
            serialized[key] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in value
            ]
        else:
            # Primitive type
            serialized[key] = value
    
    # Validate the result
    ensure_serializable(serialized, context or "state")
    return serialized

```

### FILE: game_engine\visionary\visionary.py
```py
import cv2
import numpy as np
from dataclasses import dataclass
from typing import Dict, List, Tuple, Optional
import os

@dataclass
class ROI:
    x: int
    y: int
    w: int
    h: int
    name: str

class Profile:
    COMPETITOR_WEB = "COMPETITOR_WEB"
    COMPETITOR_ARCHIVE = "COMPETITOR_ARCHIVE"

class VisionaryProcessor:
    def __init__(self, profile_name: str = Profile.COMPETITOR_WEB):
        self.profile_name = profile_name
        self.rois = self._load_rois(profile_name)

    def _load_rois(self, profile_name: str) -> Dict[str, ROI]:
        """
        Defines Regions of Interest for supported layouts.
        Coordinates are based on a normalized 1920x1080 reference canvas.
        """
        if profile_name == Profile.COMPETITOR_WEB:
            rois = {
                # Center Table (The "Floor")
                "floor": ROI(800, 400, 320, 240, "floor"),
                
                # Scores
                "score_us": ROI(100, 100, 200, 50, "score_us"),
                "score_them": ROI(1620, 100, 200, 50, "score_them"),
                
                # Bid Info
                "bid_info": ROI(800, 300, 320, 80, "bid_info")
            }

            # Parametrically define 8 hand cards
            # Base position for card 1 (approximate, based on previous value 600)
            # Assuming cards are overlapping or spaced. 
            # If card 1 is at 600, let's assume a spacing of ~80-100px.
            start_x = 550
            y_pos = 900
            card_w = 100
            card_h = 150
            spacing = 110 # Tunable parameter

            for i in range(8):
                idx = i + 1
                rois[f"hand_card_{idx}"] = ROI(
                    x=start_x + (i * spacing),
                    y=y_pos,
                    w=card_w,
                    h=card_h,
                    name=f"hand_{idx}"
                )
            return rois
        return {}

    def load_image(self, path: str) -> Optional[np.ndarray]:
        if not os.path.exists(path):
            print(f"Error: File not found {path}")
            return None
        return cv2.imread(path)

    def extract_rois(self, image: np.ndarray) -> Dict[str, np.ndarray]:
        """
        Extracts sub-images for each defined ROI.
        Resizes input image to reference 1920x1080 before extraction to match ROI coords.
        """
        # Resize to reference resolution for consistent ROI extraction
        target_h, target_w = 1080, 1920
        resized = cv2.resize(image, (target_w, target_h))
        
        extracted = {}
        for name, roi in self.rois.items():
            # Basic bounds check
            y2 = min(roi.y + roi.h, target_h)
            x2 = min(roi.x + roi.w, target_w)
            
            crop = resized[roi.y:y2, roi.x:x2]
            extracted[name] = crop
            
        return extracted

    def compute_dhash(self, image: np.ndarray, hash_size: int = 8) -> int:
        """
        Computes a 'difference hash' for the image.
        Robust against slight lighting changes and exact pixel noise.
        """
        # 1. Resize to (hash_size + 1, hash_size)
        resized = cv2.resize(image, (hash_size + 1, hash_size))
        # 2. Convert to grayscale
        gray = cv2.cvtColor(resized, cv2.COLOR_BGR2GRAY)
        # 3. Compute differences between adjacent pixels
        diff = gray[:, 1:] > gray[:, :-1]
        # 4. Convert boolean array to int
        return sum([2 ** i for (i, v) in enumerate(diff.flatten()) if v])

    def are_images_similar(self, hash1: int, hash2: int, threshold: int = 5) -> bool:
        """Returns True if Hamming distance between hashes is <= threshold."""
        return bin(hash1 ^ hash2).count('1') <= threshold

    def extract_frames_from_video(self, video_path: str, interval_seconds: float = 0.5, min_change_threshold: int = 5) -> List[np.ndarray]:
        """
        Extracts frames from a video file, skipping duplicates using dHash.
        
        Args:
            video_path: Path to video.
            interval_seconds: Minimum time between frames (lower = more candidates).
            min_change_threshold: Hamming distance threshold. If diff <= this, frame is skipped.
        """
        if not os.path.exists(video_path):
            print(f"Error: Video file not found {video_path}")
            return []

        cap = cv2.VideoCapture(video_path)
        if not cap.isOpened():
            print(f"Error: Could not open video {video_path}")
            return []

        fps = cap.get(cv2.CAP_PROP_FPS)
        if fps <= 0: fps = 30

        frames = []
        frame_interval = int(fps * interval_seconds)
        
        count = 0
        last_hash = None
        duplicates_skipped = 0
        
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            
            # Check interval first
            if count % frame_interval == 0:
                current_hash = self.compute_dhash(frame)
                
                is_duplicate = False
                if last_hash is not None:
                    if self.are_images_similar(last_hash, current_hash, min_change_threshold):
                        is_duplicate = True
                        duplicates_skipped += 1
                
                if not is_duplicate:
                    frames.append(frame)
                    last_hash = current_hash
            
            count += 1
            
        cap.release()
        print(f"Extracted {len(frames)} unique frames from {video_path} (Skipped {duplicates_skipped} duplicates)")
        return frames

    def debug_show_rois(self, image: np.ndarray, save_path: str = "debug_rois.png"):
        """Draws rectangles around ROIs for visual validation"""
        if image is None:
            print("Error: No image provided for debug")
            return

        target_h, target_w = 1080, 1920
        # Check aspect ratio to decide if we crop or pad, but for now strict resize
        debug_img = cv2.resize(image, (target_w, target_h))
        
        for name, roi in self.rois.items():
            # Draw Outer Box
            cv2.rectangle(debug_img, (roi.x, roi.y), (roi.x + roi.w, roi.y + roi.h), (0, 255, 0), 2)
            
            # Draw semi-transparent fill
            overlay = debug_img.copy()
            cv2.rectangle(overlay, (roi.x, roi.y), (roi.x + roi.w, roi.y + roi.h), (0, 255, 0), -1)
            alpha = 0.2
            debug_img = cv2.addWeighted(overlay, alpha, debug_img, 1 - alpha, 0)
            
            # Label
            label = f"{name} ({roi.w}x{roi.h})"
            cv2.putText(debug_img, label, (roi.x, roi.y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
            
        cv2.imwrite(save_path, debug_img)
        print(f"Saved ROI debug image to {save_path}")

class CardRecognizer:
    def __init__(self, model_path: str = "models/yolo_v8n_baloot.pt"):
        self.model_path = model_path
        self.model = None
        self._load_model()

    def _load_model(self):
        try:
            from ultralytics import YOLO
            if os.path.exists(self.model_path):
                print(f"Loading CardRecognizer model from {self.model_path}")
                self.model = YOLO(self.model_path)
            else:
                print(f"Warning: Model not found at {self.model_path}")
        except ImportError:
            print("Error: ultralytics not installed. Card recognition disabled.")

    def predict(self, roi_image: np.ndarray, conf_threshold: float = 0.5) -> List[str]:
        """
        Returns a list of detected card codes (e.g. ['AS', 'KH', '7D'])
        """
        if self.model is None or roi_image is None:
            return []

        results = self.model.predict(roi_image, conf=conf_threshold, verbose=False)
        cards = []
        for result in results:
            for box in result.boxes:
                # Get class name
                cls_id = int(box.cls[0])
                label = self.model.names[cls_id]
                cards.append(label)
        
        return list(set(cards)) # Return unique cards found

class DatasetGenerator:
    def __init__(self, output_dir: str = "dataset"):
        self.output_dir = output_dir
        self.images_dir = os.path.join(output_dir, "images")
        self.labels_dir = os.path.join(output_dir, "labels")
        os.makedirs(self.images_dir, exist_ok=True)
        os.makedirs(self.labels_dir, exist_ok=True)
        self.processor = VisionaryProcessor()

    def process_video_for_training(self, video_path: str, interval: float = 0.5):
        """
        Extracts frames from video, crops valid play areas (Hand 1-8, Floor),
        and saves them for labeling.
        """
        # Capture more frequently (0.5s) because deduplication will filter out the static ones
        frames = self.processor.extract_frames_from_video(video_path, interval)
        video_name = os.path.splitext(os.path.basename(video_path))[0]
        
        count = 0
        for i, frame in enumerate(frames):
            rois = self.processor.extract_rois(frame)
            
            for roi_name, roi_img in rois.items():
                # Capture 'floor' and ALL 'hand_card_X' rois
                if roi_name == "floor" or roi_name.startswith("hand_card_"):
                    filename = f"{video_name}_{i:04d}_{roi_name}.jpg"
                    path = os.path.join(self.images_dir, filename)
                    cv2.imwrite(path, roi_img)
                    count += 1
                    
        print(f"Smart Generator Created {count} training images in {self.images_dir}")

# Example Usage
if __name__ == "__main__":
    VP = VisionaryProcessor()
    # Test execution logic can go here
    print("Visionary Processor Initialized")


```

### FILE: game_engine\visionary\__init__.py
```py

```

### FILE: scripts\analyze_logs.py
```py
import sys
import os
import re
import argparse
from datetime import datetime

def analyze_log(log_path):
    if not os.path.exists(log_path):
        print(f"‚ùå Log file not found: {log_path}")
        return

    print(f"üîç Analyzing {log_path}...")
    
    with open(log_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    errors = []
    suspicious = []
    game_starts = 0
    game_ends = 0
    
    # regex for timestamps if needed: \d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}
    
    for i, line in enumerate(lines):
        line = line.strip()
        if "ERROR" in line:
            errors.append((i+1, line))
        elif "Exception" in line or "Traceback" in line:
            errors.append((i+1, line))
        elif "CRITICAL" in line:
             errors.append((i+1, line))
             
        if "GAME START" in line:
            game_starts += 1
        if "GAME_END" in line or "GamePhase.GAMEOVER" in line:
            game_ends += 1
            
        # Detect Lag (heuristic)
        if "Latency" in line:
             # Extract duration
             # Auto-Play Decision Latency for Bot: 0.1234s
             match = re.search(r'Latency.*:\s*([\d\.]+)s', line)
             if match:
                  dur = float(match.group(1))
                  if dur > 1.0:
                       suspicious.append((i+1, f"High Latency: {dur}s - {line}"))

    print(f"\nüìä Summary:")
    print(f"   Lines Read: {len(lines)}")
    print(f"   Game Starts: {game_starts}")
    print(f"   Game Ends: {game_ends}")
    print(f"   Errors Found: {len(errors)}")
    print(f"   Suspicious Events: {len(suspicious)}")

    if errors:
        print("\n‚ùå Errors:")
        for ln, msg in errors[-5:]: # Show last 5
            print(f"   [L{ln}] {msg}")
            
    if suspicious:
        print("\n‚ö†Ô∏è Suspicious (High Latency > 1.0s):")
        for ln, msg in suspicious[-5:]:
             print(f"   [L{ln}] {msg}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('file', nargs='?', default='logs/server_manual.log')
    args = parser.parse_args()
    
    analyze_log(args.file)

```

### FILE: scripts\auto_label.py
```py
from ultralytics import YOLO
import os
import yaml
import glob
from tqdm import tqdm

def auto_label_dataset(images_dir, labels_dir, data_yaml_path):
    """
    Uses YOLO-World to zero-shot detect cards and save labels.
    """
    print("Loading YOLO-World model (yolov8l-worldv2)...")
    # Using 'l' (large) model for better accuracy during labeling
    model = YOLO('yolov8l-worldv2.pt') 

    # Load class names from yaml
    with open(data_yaml_path, 'r') as f:
        data_cfg = yaml.safe_load(f)
        class_names = data_cfg['names']

    # Define natural language prompts for YOLO-World
    # We map the class ID to a descriptive prompt
    prompts = []
    
    # Map '7S' to "playing card seven of spades", etc.
    suit_map = {'S': 'spades', 'H': 'hearts', 'D': 'diamonds', 'C': 'clubs'}
    rank_map = {
        '7': 'seven', '8': 'eight', '9': 'nine', '10': 'ten', 
        'J': 'jack', 'Q': 'queen', 'K': 'king', 'A': 'ace'
    }

    print("Setting custom vocabulary for Baloot cards...")
    custom_vocab = []
    
    # Iterate through classes in order of ID to ensure alignment
    sorted_ids = sorted(class_names.keys())
    
    for cls_id in sorted_ids:
        name = class_names[cls_id]
        if name == "CARD_BACK":
            prompt = "back of playing card"
        else:
            # Parse 7S, 10H, etc.
            rank = name[:-1]
            suit = name[-1]
            
            rank_text = rank_map.get(rank, rank)
            suit_text = suit_map.get(suit, suit)
            
            prompt = f"playing card {rank_text} of {suit_text}"
        
        custom_vocab.append(prompt)
        
    print(f"Vocabulary: {custom_vocab}")
    model.set_classes(custom_vocab)

    # Process Images
    image_files = glob.glob(os.path.join(images_dir, "*.jpg")) + \
                  glob.glob(os.path.join(images_dir, "*.png"))
    
    print(f"Labeling {len(image_files)} images...")
    os.makedirs(labels_dir, exist_ok=True)

    for img_path in tqdm(image_files):
        # Run inference with higher resolution and lower confidence
        results = model.predict(img_path, conf=0.05, iou=0.5, imgsz=1280, save=False, verbose=False)
        
        result = results[0]
        filename = os.path.basename(img_path)
        label_filename = os.path.splitext(filename)[0] + ".txt"
        label_path = os.path.join(labels_dir, label_filename)
        
        with open(label_path, 'w') as f:
            for box in result.boxes:
                # YOLO format: class x_center y_center width height
                # All normalized 0-1
                cls_id = int(box.cls[0])
                xywhn = box.xywhn[0].tolist()
                
                line = f"{cls_id} {xywhn[0]:.6f} {xywhn[1]:.6f} {xywhn[2]:.6f} {xywhn[3]:.6f}\n"
                f.write(line)

    print(f"Finished auto-labeling to {labels_dir}")

if __name__ == "__main__":
    auto_label_dataset(
        "dataset/images/train", 
        "dataset/labels/train", 
        "dataset/data.yaml"
    )

```

### FILE: scripts\auto_play.py
```py
import time
import json
import os
import logging
from game_engine.arena import Arena

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger("AutoPlay")

def run_campaign(num_games=10):
    arena = Arena()
    results = []
    
    os.makedirs("matches", exist_ok=True)
    
    logger.info(f"Starting Campaign of {num_games} matches...")
    start_time = time.time()
    
    wins = {"us": 0, "them": 0, "draw": 0}
    
    for i in range(num_games):
        match_id = f"sim_{int(time.time())}_{i}"
        try:
            res = arena.run_match(match_id)
            
            winner = res.get('winner')
            if winner == 'us': wins['us'] += 1
            elif winner == 'them': wins['them'] += 1
            else: wins['draw'] += 1
            
            # Save Match Log
            match_file = f"matches/{match_id}.json"
            with open(match_file, "w") as f:
                json.dump(res, f, indent=2)
                
            logger.info(f"Match {i+1}/{num_games} - Winner: {winner} - Steps: {res.get('steps')}")
            
        except Exception as e:
            logger.error(f"Match {i} failed: {e}")
            
    duration = time.time() - start_time
    logger.info(f"Campaign Finished in {duration:.2f}s")
    logger.info(f"Results: {wins}")
    
if __name__ == "__main__":
    run_campaign(5) # Run small batch first

```

### FILE: scripts\cat_logs.py
```py

import os
import glob

log_dir = "logs"
files = glob.glob(os.path.join(log_dir, "*.log"))

for f in files:
    print(f"\n--- {f} ---")
    try:
        with open(f, 'rb') as fh:
            fh.seek(0, 2)
            size = fh.tell()
            fh.seek(max(0, size - 2000), 0)
            print(fh.read().decode('utf-8', errors='ignore'))
    except Exception as e:
        print(f"Error reading {f}: {e}")

```

### FILE: scripts\check_img.py
```py

import struct
import os

def get_png_dimensions(file_path):
    with open(file_path, 'rb') as f:
        data = f.read(24)
        if data[:8] != b'\x89PNG\r\n\x1a\n':
            return "Not a PNG"
        w, h = struct.unpack('>LL', data[16:24])
        return w, h

print(get_png_dimensions('c:/Users/MiEXCITE/Projects/baloot-ai/frontend/public/cards.png'))

```

### FILE: scripts\check_puzzles_api.py
```py

import requests
import json

def check_api():
    url = "http://127.0.0.1:3005/puzzles"
    try:
        print(f"Fetching {url}...")
        res = requests.get(url, timeout=5)
        print(f"Status Code: {res.status_code}")
        
        if res.status_code == 200:
            data = res.json()
            print("Response Data:")
            print(json.dumps(data, indent=2))
            
            puzzles = data.get("puzzles", [])
            print(f"Found {len(puzzles)} puzzles in response.")
        else:
            print("Error response:", res.text)
            
    except Exception as e:
        print(f"Failed to connect: {e}")

if __name__ == "__main__":
    check_api()

```

### FILE: scripts\check_puzzle_detail_api.py
```py

import requests
import json

def check_puzzle_detail():
    # Try to fetch puzzle_3 (one of the seeded ones)
    url = "http://127.0.0.1:3005/puzzles/puzzle_3"
    try:
        print(f"Fetching {url}...")
        res = requests.get(url, timeout=5)
        print(f"Status Code: {res.status_code}")
        
        if res.status_code == 200:
            data = res.json()
            print("Response Data:")
            print(json.dumps(data, indent=2))
        else:
            print("Error response:", res.text)
            
    except Exception as e:
        print(f"Failed to connect: {e}")

if __name__ == "__main__":
    check_puzzle_detail()

```

### FILE: scripts\cleanup.ps1
```ps1
Write-Host "üßπ Cleaning up Baloot Game Processes..." -ForegroundColor Cyan

function Kill-By-Command ($pattern) {
    $procs = Get-WmiObject Win32_Process | Where-Object { $_.CommandLine -match $pattern }
    foreach ($p in $procs) {
        # Avoid killing self or tools
        if ($p.Name -match "python" -and $_.CommandLine -match "cortex") { continue }
        
        Write-Host "   üî™ Killing PID $($p.ProcessId): $($p.CommandLine.Substring(0, [math]::Min(50, $p.CommandLine.Length)))..." -ForegroundColor Yellow
        Stop-Process -Id $p.ProcessId -Force -ErrorAction SilentlyContinue
    }
}

function Kill-Port ($port) {
    $conns = Get-NetTCPConnection -LocalPort $port -ErrorAction SilentlyContinue
    if ($conns) {
        foreach ($c in $conns) {
            $pid_val = $c.OwningProcess
            if ($pid_val -gt 0) {
                 Write-Host "   üîå Killing PID $pid_val on port $port" -ForegroundColor Yellow
                 Stop-Process -Id $pid_val -Force -ErrorAction SilentlyContinue
            }
        }
    }
}

function Wait-For-Port-Release ($port) {
    Write-Host "   ‚è≥ Waiting for port $port to release..." -NoNewline
    for ($i = 0; $i -lt 10; $i++) {
        $conns = Get-NetTCPConnection -LocalPort $port -ErrorAction SilentlyContinue
        if (-not $conns) {
            Write-Host " Done." -ForegroundColor Green
            return $true
        }
        Start-Sleep -Milliseconds 500
        Write-Host "." -NoNewline
    }
    Write-Host " TIMEOUT!" -ForegroundColor Red
    return $false
}

# 1. Kill by Port (Most Accurate)
Kill-Port 3005 # Backend
Kill-Port 5173 # Frontend

# 2. Kill by Signature (Cleanup orphans)
Kill-By-Command "server.main"
Kill-By-Command "vite"

# 2.5 Kill by Window Title (Close PowerShell Windows)
$targets = @("Baloot Backend", "Baloot Frontend")
foreach ($t in $targets) {
    $wins = Get-Process | Where-Object { $_.MainWindowTitle -eq $t }
    if ($wins) {
        Write-Host "   ü™ü Closing Window: $t" -ForegroundColor Yellow
        Stop-Process -InputObject $wins -Force -ErrorAction SilentlyContinue
    }
}

# 3. Redis
$redis = Get-Process redis-server -ErrorAction SilentlyContinue
if ($redis) {
    Write-Host "   üõë Stopping Local Redis..." -ForegroundColor Yellow
    Stop-Process -Id $redis.Id -Force -ErrorAction SilentlyContinue
}

# 4. Verify Release
Wait-For-Port-Release 3005
Wait-For-Port-Release 5173

Write-Host "‚úÖ Cleanup Complete. Ports 3005, 5173 should be free." -ForegroundColor Green

```

### FILE: scripts\cleanup_bot.py
```py

lines = []
with open('bot_agent.py', 'r', encoding='utf-8') as f:
    lines = f.readlines()

# Lines to delete: 408 to 478 (1-based index)
# Python list is 0-based.
# So delete index 407 to 478 (exclusive of 478? No 478 is included).
# Index 407 = Line 408.
# Index 477 = Line 478.
# Slice to keep: :407 + 478:

new_lines = lines[:407] + lines[478:]

with open('bot_agent.py', 'w', encoding='utf-8') as f:
    f.writelines(new_lines)

print(f"Deleted lines 408-478. New line count: {len(new_lines)}")

```

### FILE: scripts\cleanup_bot_2.py
```py

lines = []
with open('bot_agent.py', 'r', encoding='utf-8') as f:
    lines = f.readlines()

# Lines to delete: 555 to 577 (1-based index)
# Python list slice: [:554] + [577:]
# Index 554 = Line 555.
# Index 577 = Line 578.

new_lines = lines[:554] + lines[577:]

with open('bot_agent.py', 'w', encoding='utf-8') as f:
    f.writelines(new_lines)

print(f"Deleted lines 555-577. New line count: {len(new_lines)}")

```

### FILE: scripts\cli_test_runner.py (SKIPPED - >10KB)
### FILE: scripts\debug_revoke.py
```py

import sys
import os
import logging

# Setup path
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(current_dir)
sys.path.insert(0, project_root)

from game_engine.logic.game import Game
from game_engine.models.card import Card
from game_engine.models.player import Player
from game_engine.models.constants import GamePhase

# Setup Logging
logging.basicConfig(level=logging.INFO)

def test_revoke_detection():
    print("=== Debugging Revoke Detection ===")
    
    # 1. Setup Game
    game = Game("debug_room")
    game.phase = GamePhase.PLAYING.value
    game.game_mode = 'SUN' # Sun mode: Must follow suit
    
    # 2. Setup Players
    # P1 (Bottom) - Leads
    # P2 (Right) - Has Suit, but Revokes
    p1 = Player("P1", "Lead", 0, game)
    p2 = Player("P2", "Cheat", 1, game)
    game.players = [p1, p2, Player("P3", "Top", 2, game), Player("P4", "Left", 3, game)]
    
    # 3. Deal Hands
    # P1 has Heart A
    p1.hand = [Card('‚ô•', 'A')]
    # P2 has Heart K and Spade 7
    p2.hand = [Card('‚ô•', 'K'), Card('‚ô†', '7')]
    
    # 4. P1 Plays Heart A (Lead)
    print(f"P1 leads with {p1.hand[0]}")
    game.current_turn = 0
    res = game.play_card(0, 0) # Index 0
    if "error" in res:
        print(f"P1 play failed: {res}")
        return
        
    # 5. P2 Plays Spade 7 (Revoke!)
    # Should be flagged as illegal
    print(f"P2 tries to play {p2.hand[1]} (Spades) while holding Hearts...")
    game.current_turn = 1
    # Card is at index 1 in hand
    res = game.play_card(1, 1) 
    
    # 6. Verify Result
    if "error" in res:
         print(f"P2 play rejected (Correct if strict, Incorrect if allowing illegal): {res}")
         return

    # Check Table Card Metadata
    last_play = game.table_cards[-1]
    print(f"P2 played: {last_play['card']}")
    metadata = last_play.get('metadata', {})
    print(f"Metadata: {metadata}")
    
    if metadata.get('is_illegal'):
        print("‚úÖ SUCCESS: Illegal move flagged correctly.")
    else:
        print("‚ùå FAILURE: Illegal move NOT flagged.")
        
    # 7. Check is_valid_move direct call
    print("\n--- Direct Validation Check ---")
    card_played = Card('‚ô†', '7')
    hand = [Card('‚ô•', 'K'), Card('‚ô†', '7')] # P2's hand BEFORE play
    # Note: play_card removes card from hand usually, so we reconstruct
    
    # Validation args: card, hand, table_cards
    # table_cards has P1's play
    # We must pass the hand AS IT WAS
    
    # Creating a temporary game or just calling validation helper if possible
    # accessing game.is_valid_move
    
    is_valid = game.is_valid_move(card_played, hand)
    print(f"game.is_valid_move result: {is_valid} (Expected: False)")

if __name__ == "__main__":
    test_revoke_detection()

```

### FILE: scripts\debug_validation_real.py
```py
import sys
import os

# Setup path
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(current_dir)
sys.path.insert(0, project_root)

from game_engine.logic.validation import is_move_legal
from game_engine.models.card import Card

def test_validation_logic():
    print("=== Testing Validation Logic (is_move_legal) ===")

    # 1. Setup Common Objects
    # Hand has Hearts and Spades
    hand = [Card('H', 'K'), Card('H', '9'), Card('S', 'A')]
    
    # Table: Partner led Hearts
    table_cards = [{'card': Card('H', '7'), 'playedBy': 'Top'}]
    
    # Players Map
    players_team_map = {'Bottom': 'us', 'Right': 'them', 'Top': 'us', 'Left': 'them'}
    
    # 2. Test Case A: Revoke in SUN (Has suit, plays different)
    # Player (Bottom) has Hearts (K, 9). Plays Spades (A).
    # Expected: False (Illegal)
    print("\nTest A: SUN - Revoke (Have H, Play S, Lead H)")
    card_played = Card('S', 'A') 
    
    is_legal = is_move_legal(
        card=card_played,
        hand=hand,
        table_cards=table_cards,
        game_mode='SUN',
        trump_suit='D', # Irrelevant in Sun
        my_team='us',
        players_team_map=players_team_map
    )
    
    if is_legal:
         print(f"‚ùå FAILED: Algorithm says {card_played} is LEGAL (Should be Illegal/Revoke)")
    else:
         print(f"‚úÖ PASSED: Algorithm says {card_played} is ILLEGAL")

    # 3. Test Case B: Revoke in HOKUM (Trump=D)
    # Lead H. Have H. Play S.
    # Expected: False
    print("\nTest B: HOKUM - Revoke (Have H, Play S, Lead H)")
    is_legal = is_move_legal(
        card=card_played,
        hand=hand,
        table_cards=table_cards,
        game_mode='HOKUM',
        trump_suit='D', 
        my_team='us',
        players_team_map=players_team_map
    )
    
    if is_legal:
         print(f"‚ùå FAILED: Algorithm says {card_played} is LEGAL (Should be Illegal/Revoke)")
    else:
         print(f"‚úÖ PASSED: Algorithm says {card_played} is ILLEGAL")
         
    # 4. Test Case C: Eating Check (Hokum)
    # Enemy is winning with Ace of Hearts. We have H King. We play H King. (Legal)
    # Enemy is winning with Ace of Trump. We have 9 Trump (Menel). We play 7 Trump. (Illegal if we have King? No, must beat if possible)
    
    # Let's focus on the User Report: "Wrong suit card". likely Revoke.
    
    # Test Case D: Lead is Trump (H). We have Trump. We play non-Trump.
    print("\nTest D: HOKUM - Revoke (Lead Trump H, Have Trump H, Play S)")
    table_trump_lead = [{'card': Card('H', '7'), 'playedBy': 'Right'}] # Enemy Led
    is_legal = is_move_legal(
        card=Card('S', 'A'),
        hand=hand, # Has H K, H 9
        table_cards=table_trump_lead,
        game_mode='HOKUM',
        trump_suit='H',
        my_team='us',
        players_team_map=players_team_map
    )
    if is_legal:
         print(f"‚ùå FAILED: Algorithm says S A is LEGAL (Should be Illegal/Revoke vs Trump Lead)")
    else:
         print(f"‚úÖ PASSED: Algorithm says S A is ILLEGAL")


if __name__ == "__main__":
    test_validation_logic()

```

### FILE: scripts\debug_yolo_prediction.py
```py
import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from ultralytics import YOLO
import cv2
import glob
from game_engine.visionary.visionary import VisionaryProcessor

def debug_prediction(model_path, image_path):
    print(f"Loading Model: {model_path}")
    model = YOLO(model_path)
    
    print(f"Loading Image: {image_path}")
    img = cv2.imread(image_path)
    if img is None:
        print("Failed to load image")
        return

    # 1. Predict on FULL image (1280px)
    print("Predicting on FULL image...")
    results_full = model.predict(img, conf=0.10, imgsz=1280)
    
    # Save visualized full image
    res_plotted = results_full[0].plot()
    cv2.imwrite("debug_prediction_full.jpg", res_plotted)
    print("Saved debug_prediction_full.jpg")
    
    # 2. Predict on ROIs
    vp = VisionaryProcessor()
    # ROIs rely on 1920x1080 normalization
    rois = vp.extract_rois(img)
    
    for name, roi in rois.items():
        if name in ["floor", "hand_card_1"]:
            print(f"Predicting on ROI: {name}")
            results_roi = model.predict(roi, conf=0.10, imgsz=640)
            roi_plotted = results_roi[0].plot()
            cv2.imwrite(f"debug_prediction_{name}.jpg", roi_plotted)
            print(f"Saved debug_prediction_{name}.jpg")

def draw_yolo_labels(img, label_path, class_names):
    if not os.path.exists(label_path):
        return img
    
    with open(label_path, 'r') as f:
        lines = f.readlines()
        
    h, w, _ = img.shape
    for line in lines:
        parts = line.strip().split()
        cls_id = int(parts[0])
        x_center = float(parts[1]) * w
        y_center = float(parts[2]) * h
        width = float(parts[3]) * w
        height = float(parts[4]) * h
        
        x1 = int(x_center - width/2)
        y1 = int(y_center - height/2)
        x2 = int(x_center + width/2)
        y2 = int(y_center + height/2)
        
        # Draw GT in Green
        cv2.rectangle(img, (x1, y1), (x2, y2), (0, 255, 0), 2)
        label = class_names[cls_id] if cls_id < len(class_names) else str(cls_id)
        cv2.putText(img, f"GT: {label}", (x1, y1-10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 1)
    return img

if __name__ == "__main__":
    # Load class names
    import yaml
    with open("dataset/data.yaml", 'r') as f:
        data = yaml.safe_load(f)
        names = data['names']

    # Find a test image
    images = glob.glob("dataset/images/train/*.jpg")
    import random
    random.shuffle(images)
    
    for i, img_path in enumerate(images[:5]): # Test on 5 random images
        print(f"--- Debugging Image {i+1}: {img_path} ---")
        debug_prediction("models/yolo_v8n_baloot.pt", img_path)
        
        # Visualize GT
        img = cv2.imread(img_path)
        label_path = img_path.replace("images", "labels").replace(".jpg", ".txt")
        img_gt = draw_yolo_labels(img, label_path, names)
        cv2.imwrite(f"debug_gt_{i}.jpg", img_gt)
        print(f"Saved debug_gt_{i}.jpg")

```

### FILE: scripts\diagnose_imports.py
```py

import sys
import os
import traceback

sys.path.append(os.getcwd())

try:
    print("Attempting to import game_engine.logic.game...")
    from game_engine.logic.game import Game
    print("Import SUCCESS!")
except Exception:
    with open("import_error.log", "w") as f:
        traceback.print_exc(file=f)
    print("Import FAILED. Traceback written to import_error.log")

```

### FILE: scripts\ensure_docker.ps1
```ps1
$dockerExe = "C:\Program Files\Docker\Docker\Docker Desktop.exe"

Write-Host "üîç Checking Docker Status..." -ForegroundColor Cyan

# 1. Check if Process is Running
$process = Get-Process "Docker Desktop" -ErrorAction SilentlyContinue
if ($process) {
    Write-Host "‚úÖ Docker Desktop process is running." -ForegroundColor Green
} else {
    Write-Host "‚ö†Ô∏è  Docker Desktop not running. Attempting to start..." -ForegroundColor Yellow
    if (Test-Path $dockerExe) {
        Start-Process $dockerExe
        Write-Host "üöÄ Docker Desktop launched. Waiting for initialization..." -ForegroundColor Cyan
    } else {
        Write-Host "‚ùå Could not find Docker Desktop at expected path: $dockerExe" -ForegroundColor Red
        exit 1
    }
}

# 2. Wait for Socket / CLI Responsiveness
$maxRetries = 60
$retry = 0
$ready = $false

while ($retry -lt $maxRetries) {
    $retry++
    Write-Host "‚è≥ Waiting for Docker Daemon ($retry/$maxRetries)..." -NoNewline
    
    try {
        $res = docker info 2>&1
        if ($LASTEXITCODE -eq 0) {
            Write-Host " ‚úÖ Ready!" -ForegroundColor Green
            $ready = $true
            break
        }
    } catch {
        # ignore
    }
    Write-Host "."
    Start-Sleep -Seconds 2
}

if ($ready) {
    Write-Host "üéâ Docker is fully operational." -ForegroundColor Green
    exit 0
} else {
    Write-Host "‚ùå Timed out waiting for Docker Daemon." -ForegroundColor Red
    exit 1
}

```

### FILE: scripts\extract_frames.py
```py
import sys
import os
import cv2

def extract_frames_stream(video_path, output_dir, interval=1.0):
    if not os.path.exists(video_path):
        print(f"Video not found: {video_path}")
        return

    print(f"Extracting frames from {video_path} every {interval}s to {output_dir}")
    os.makedirs(output_dir, exist_ok=True)
    
    cap = cv2.VideoCapture(video_path)
    if not cap.isOpened():
        print("Error opening video stream or file")
        return

    fps = cap.get(cv2.CAP_PROP_FPS)
    if fps <= 0: fps = 30
    
    frame_interval = int(fps * interval)
    print(f"FPS: {fps}, Interval frames: {frame_interval}")
    
    count = 0
    saved_count = 0
    
    while True:
        ret, frame = cap.read()
        if not ret:
            break
            
        if count % frame_interval == 0:
            fname = f"frame_{saved_count:04d}.jpg"
            path = os.path.join(output_dir, fname)
            cv2.imwrite(path, frame)
            saved_count += 1
            if saved_count % 10 == 0:
                print(f"Saved {saved_count} frames...")
        
        count += 1
        
    cap.release()
    print(f"Done! Saved {saved_count} frames to {output_dir}")

if __name__ == "__main__":
    video = "dataset/Project.mp4"
    out = "dataset/images/train" 
    extract_frames_stream(video, out, interval=2.0)

```

### FILE: scripts\fix_test_imports.py
```py
import os

TESTS_DIR = 'tests'

REPLACEMENTS = {
    'from server.bidding_engine': 'from game_engine.logic.bidding_engine',
    'import server.bidding_engine': 'import game_engine.logic.bidding_engine',
    'from server.bot_agent': 'from ai_worker.agent',
    'import server.bot_agent': 'import ai_worker.agent',
    'from bot_agent': 'from ai_worker.agent', # Case where server was in path
    'import bot_agent': 'import ai_worker.agent',
    'from server.bot_memory': 'from ai_worker.memory',
    'from bot_memory': 'from ai_worker.memory',
    'from server.game_engine': 'from game_engine.logic.game', # Assuming Logic exists
}

def fix_imports():
    count = 0
    for root, dirs, files in os.walk(TESTS_DIR):
        for file in files:
            if not file.endswith('.py'):
                continue
            
            path = os.path.join(root, file)
            with open(path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            new_content = content
            modified = False
            for old, new in REPLACEMENTS.items():
                if old in new_content:
                    new_content = new_content.replace(old, new)
                    modified = True
            
            if modified:
                print(f"Fixing {path}...")
                with open(path, 'w', encoding='utf-8') as f:
                    f.write(new_content)
                count += 1
    
    print(f"Fixed {count} files.")

if __name__ == '__main__':
    fix_imports()

```

### FILE: scripts\generate_benchmark.py
```py
import os
import sys
import json
import logging

# Setup Paths
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from server.common import db
# Ensure tables are defined
import server.models

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("BenchmarkGenerator")

def generate_benchmark():
    """
    Extracts 'Golden' training examples from the database and saves them 
    as a standardized Benchmark Set (Puzzles).
    """
    try:
        # Fetch training data that has a "correct_move" (Generated by Gemini)
        # We assume any row in bot_training_data is a "correction" of a mistake, 
        # so it's a perfect puzzle: "Bot did X, but should have done Y".
        rows = db(db.bot_training_data).select()
        
        puzzles = []
        for row in rows:
            try:
                state = json.loads(row.game_state_json)
                correct_move = json.loads(row.correct_move_json)
                
                # Validate structure (Must be a playable game state)
                players = state.get('players', [])
                if not state or not correct_move or len(players) != 4: 
                    # logger.warning(f"Skipping row {row.id}: Invalid Structure (Players={len(players)})")
                    continue
                
                puzzle = {
                    "id": f"puzzle_{row.id}",
                    "context_hash": row.context_hash,
                    "description": row.reason or "Find the best move.",
                    "game_state": state,
                    "solution": correct_move,
                    "difficulty": "Hard" # All mistakes are hard by definition
                }
                puzzles.append(puzzle)
            except Exception as e:
                logger.warning(f"Skipping row {row.id}: {e}")
                
        logger.info(f"Extracted {len(puzzles)} puzzles from database.")
        
        # Save to file
        output_path = os.path.join("ai_worker", "benchmarks", "golden_puzzles.json")
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(puzzles, f, indent=2)
            
        logger.info(f"Saved benchmark set to {output_path}")
        print(f"‚úÖ Generated {len(puzzles)} puzzles in {output_path}")
        
    except Exception as e:
        logger.error(f"Failed to generate benchmark: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    generate_benchmark()

```

### FILE: scripts\generate_cards.py
```py
import os
from PIL import Image, ImageDraw, ImageFont

# Canvas Setup
CARD_WIDTH = 200
CARD_HEIGHT = 280
COLS = 13
ROWS = 4
SHEET_WIDTH = CARD_WIDTH * COLS
SHEET_HEIGHT = CARD_HEIGHT * ROWS

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (220, 20, 60) # Crimson Red
GRAY = (200, 200, 200)

# Suits & Ranks
# Row 0: Hearts (Red)
# Row 1: Diamonds (Red)
# Row 2: Clubs (Black)
# Row 3: Spades (Black)
# My Code Logic: Hearts=0, Diamonds=1, Clubs=2, Spades=3
SUITS = [
    {'symbol': '‚ô•', 'color': RED, 'name': 'Hearts'},
    {'symbol': '‚ô¶', 'color': RED, 'name': 'Diamonds'},
    {'symbol': '‚ô£', 'color': BLACK, 'name': 'Clubs'},
    {'symbol': '‚ô†', 'color': BLACK, 'name': 'Spades'}
]
RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']

# Determine Output Path
OUTPUT_PATH = r"c:\Users\MiEXCITE\Downloads\py4web\examples\react-py4web\frontend\public\react-py4web\static\build\cards.png"
OUTPUT_DIR = os.path.dirname(OUTPUT_PATH)

if not os.path.exists(OUTPUT_DIR):
    os.makedirs(OUTPUT_DIR)

# Initialize Image
sprite_sheet = Image.new('RGBA', (SHEET_WIDTH, SHEET_HEIGHT), (0, 0, 0, 0))
draw_sheet = ImageDraw.Draw(sprite_sheet)

# Font Loading (Try to find a system font or use default)
try:
    # Windows typically has arial
    font_rank = ImageFont.truetype("arial.ttf", 60)
    font_suit = ImageFont.truetype("arial.ttf", 100) # Big suit center
    font_corner = ImageFont.truetype("arial.ttf", 30) # Small corner suit
    font_court = ImageFont.truetype("times.ttf", 120) # Letter for court
except IOError:
    font_rank = ImageFont.load_default()
    font_suit = ImageFont.load_default()
    font_corner = ImageFont.load_default()
    font_court = ImageFont.load_default()

def draw_card(rank_idx, suit_idx):
    rank_str = RANKS[rank_idx]
    suit_info = SUITS[suit_idx]
    
    # Calculate position
    x_offset = rank_idx * CARD_WIDTH
    y_offset = suit_idx * CARD_HEIGHT
    
    # Create card face
    # Draw White Background with border
    # Use a SAFE_MARGIN to prevent bleeding
    MARGIN = 4
    
    draw_sheet.rectangle(
        [x_offset + MARGIN, y_offset + MARGIN, x_offset + CARD_WIDTH - MARGIN, y_offset + CARD_HEIGHT - MARGIN], 
        fill=WHITE, 
        outline=GRAY, 
        width=2
    )
    
    # Draw Corner Rank (Top Left)
    draw_sheet.text(
        (x_offset + MARGIN + 6, y_offset + MARGIN + 6), 
        rank_str, 
        font=font_rank, 
        fill=suit_info['color']
    )
    
    # Draw Corner Suit (Below Rank)
    draw_sheet.text(
        (x_offset + MARGIN + 10, y_offset + MARGIN + 60), 
        suit_info['symbol'], 
        font=font_corner, 
        fill=suit_info['color']
    )
    
    # Draw Center
    # For J, Q, K -> Draw Big Letter + Suit? Or a "Court" Box?
    # For A -> Big Suit
    # For others -> Number of pips (Too hard to code perfect pips now).
    # Strategy: Big Center Text for Rank + Big Suit below it.
    
    # Center Coordinates
    cx = x_offset + CARD_WIDTH // 2
    cy = y_offset + CARD_HEIGHT // 2
    
    rank_bbox = draw_sheet.textbbox((0, 0), rank_str, font=font_rank)
    rank_w = rank_bbox[2] - rank_bbox[0]
    
    suit_bbox = draw_sheet.textbbox((0, 0), suit_info['symbol'], font=font_suit)
    suit_w = suit_bbox[2] - suit_bbox[0]
    suit_h = suit_bbox[3] - suit_bbox[1]

    # Draw Big Suit in Center
    draw_sheet.text(
        (cx - suit_w // 2, cy - suit_h // 2), 
        suit_info['symbol'], 
        font=font_suit, 
        fill=suit_info['color']
    )
    
    # Invert for bottom right? No, just keep it simple classic.
    # Bottom Right Rank/Suit inverted is classic.
    # Let's Skip inversion logic for now or try simple rotation is hard on single canvas object.
    # Just standard top-left + center is enough for gameplay visibility.

    # Border Inner (to make it look like a card)
    draw_sheet.rectangle(
        [x_offset + 5, y_offset + 5, x_offset + CARD_WIDTH - 5, y_offset + CARD_HEIGHT - 5],
        outline=None,
        width=0
    )

# Execution Loop
print("Generating 52 cards...")
for r in range(ROWS):
    for c in range(COLS):
        draw_card(c, r)

print(f"Saving to {OUTPUT_PATH}")
sprite_sheet.save(OUTPUT_PATH)
# Also save to source public for dev
source_path = r"c:\Users\MiEXCITE\Downloads\py4web\examples\react-py4web\frontend\public\cards.png"
sprite_sheet.save(source_path)
print(f"Also saved to {source_path}")

```

### FILE: scripts\generate_codebase_context.py
```py
import os
import fnmatch
from typing import List, Set

# üöÄ CONFIGURATION
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
OUTPUT_FULL = os.path.join(PROJECT_ROOT, "claude_context_FULL.txt")
OUTPUT_LITE = os.path.join(PROJECT_ROOT, "claude_context_LITE.txt")

# üö´ EXCLUSIONS (Save Tokens!)
EXCLUDE_DIRS = {
    ".git", ".env", "node_modules", "logs", "__pycache__", "venv", 
    "dist", "build", "coverage", "htmlcov", ".pytest_cache", ".mypy_cache",
    "ai_training", "models", "static", "docs", ".agent", ".gemini"
}

EXCLUDE_EXTENSIONS = {
    ".png", ".jpg", ".jpeg", ".gif", ".ico", ".svg", ".mp4", ".mp3", ".wav",
    ".pyc", ".pyo", ".pyd", ".so", ".dll", ".exe", ".bin", ".pkl", ".joblib",
    ".pt", ".pth", ".onnx", ".db", ".sqlite", ".log", ".csv", ".tsv",
    ".lock", ".map", ".min.js", ".min.css", ".pdf", ".docx", ".zip"
}

# üìè SIZE LIMIT (Files larger than this are skipped to save tokens)
MAX_FILE_SIZE_KB = 50 
LITE_MODE_MAX_KB = 10 # Strict limit for Lite mode

# üß† SMART CONTEXT PATTERNS (Files to prioritized/injected at top)
PRIORITY_FILES = [
    "README.md",
    "current_state.md",
    "architecture.md", 
    "developer_tips.md",
    "handoff.md",
    "task.md",
    "CODEBASE_MAP.md"
]

def load_gitignore_patterns(root):
    """Load gitignore patterns into a simple list."""
    patterns = []
    gitignore_path = os.path.join(root, ".gitignore")
    if os.path.exists(gitignore_path):
        with open(gitignore_path, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#"):
                    patterns.append(line)
    return patterns

def is_ignored(path, patterns):
    """Simple fnmatch check for gitignore patterns."""
    name = os.path.basename(path)
    for pattern in patterns:
        if fnmatch.fnmatch(name, pattern):
            return True
        if fnmatch.fnmatch(path, pattern):
            return True
    return False

def get_file_tree(root_path, exclude_dirs, patterns) -> str:
    """Generates a visual tree of the codebase."""
    tree_lines = ["\n# üå≥ PROJECT STRUCTURE (File Tree)\n"]
    
    for root, dirs, files in os.walk(root_path):
        # Filter dirs in-place
        dirs[:] = [d for d in dirs if d not in exclude_dirs and not d.startswith(".")]
        
        level = root.replace(root_path, '').count(os.sep)
        indent = ' ' * 4 * level
        subindent = ' ' * 4 * (level + 1)
        
        # Don't print root
        if root != root_path:
            tree_lines.append(f"{indent}{os.path.basename(root)}/")
            
        for f in files:
            rel_path = os.path.relpath(os.path.join(root, f), root_path)
            if not is_ignored(rel_path, patterns):
                 # Check extension
                _, ext = os.path.splitext(f)
                if ext.lower() not in EXCLUDE_EXTENSIONS:
                    tree_lines.append(f"{subindent}{f}")
                    
    tree_lines.append("\n" + "="*50 + "\n")
    return "\n".join(tree_lines)

def find_priority_files(root_path) -> List[tuple]:
    """Scans for high-value docs to inject at the top."""
    found = []
    # 1. Check local root
    for fname in PRIORITY_FILES:
        path = os.path.join(root_path, fname)
        if os.path.exists(path):
             found.append((fname, path))
    
    # 2. Check .agent/knowledge (common pattern)
    knowledge_path = os.path.join(root_path, ".agent", "knowledge")
    if os.path.exists(knowledge_path):
         for f in os.listdir(knowledge_path):
             if f in PRIORITY_FILES or f.endswith("_tips.md"):
                  found.append((f"knowledge/{f}", os.path.join(knowledge_path, f)))
                  
    return found

def generate_snapshots():
    print(f"üöÄ Generating Smart Context from: {PROJECT_ROOT}")
    patterns = load_gitignore_patterns(PROJECT_ROOT)
    
    # 1. Generate Tree
    print("   üå≥ Building File Tree...")
    file_tree = get_file_tree(PROJECT_ROOT, EXCLUDE_DIRS, patterns)
    
    # 2. Find Priority Context
    print("   üß† Hunting for Knowledge artifacts...")
    priority_docs = find_priority_files(PROJECT_ROOT)
    
    # 3. Generate FULL and LITE snapshots
    modes = [
        ("FULL", OUTPUT_FULL, MAX_FILE_SIZE_KB), 
        ("LITE", OUTPUT_LITE, LITE_MODE_MAX_KB)
    ]
    
    for mode_name, output_path, max_size in modes:
        file_count = 0
        token_est = 0
        
        with open(output_path, "w", encoding="utf-8") as out:
            # HEADER
            out.write(f"# BALOOT AI: {mode_name} CONTEXT SNAPSHOT\n")
            out.write(f"# Generated for Claude Desktop. Mode: {mode_name}\n\n")
            
            # INJECT PRIORITY DOCS
            if priority_docs:
                out.write("# üß† CRITICAL CONTEXT (Read This First)\n\n")
                for name, path in priority_docs:
                    try:
                        with open(path, "r", encoding="utf-8") as f:
                            content = f.read()
                        out.write(f"### DOC: {name}\n")
                        out.write(content + "\n\n")
                        token_est += len(content) / 4
                    except: pass
            
            # INJECT TREE
            out.write(file_tree)
            token_est += len(file_tree) / 4
            
            # INJECT FILES
            out.write(f"\n# üìù SOURCE CODE (Max Size: {max_size}KB)\n\n")
            
            for root, dirs, files in os.walk(PROJECT_ROOT):
                dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS and not d.startswith(".")]

                for file in files:
                    file_path = os.path.join(root, file)
                    rel_path = os.path.relpath(file_path, PROJECT_ROOT)
                    
                    if is_ignored(rel_path, patterns): continue
                    
                    _, ext = os.path.splitext(file)
                    if ext.lower() in EXCLUDE_EXTENSIONS: continue
                    
                    # Logic: Only include file content if it passes filters
                    # In LITE mode, we might skip implementation files unless they are small
                    
                    size_kb = os.path.getsize(file_path) / 1024
                    
                    # Skip logic
                    if size_kb > max_size:
                        out.write(f"### FILE: {rel_path} (SKIPPED - >{max_size}KB)\n")
                        continue
                        
                    try:
                        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                            content = f.read()
                        out.write(f"### FILE: {rel_path}\n")
                        out.write("```" + ext.replace(".", "") + "\n")
                        out.write(content)
                        out.write("\n```\n\n")
                        file_count += 1
                        token_est += len(content) / 4
                    except: pass

        print(f"   ‚úÖ {mode_name} Snapshot: {os.path.basename(output_path)} ({int(token_est)} tokens)")

    print("\nüí° TIP: Use 'FULL' for deep coding tasks. Use 'LITE' for architecture questions.")

if __name__ == "__main__":
    generate_snapshots()


```

### FILE: scripts\generate_mind_data.py
```py

import json
import torch
import glob
import os
import sys
from pathlib import Path

# Add project root to path
sys.path.append(str(Path(__file__).parent.parent))
from ai_worker.learning.mind_utils import MindVocab

def parse_card_str(card_obj):
    # Input: {'suit': '‚ô•', 'rank': 'A', ...}
    # Output: 'HA'
    suit_map = {'‚ô•': 'H', '‚ô¶': 'D', '‚ô†': 'S', '‚ô£': 'C'}
    s = suit_map.get(card_obj['suit'])
    r = card_obj['rank']
    if not s: return None
    return f"{s}{r}"

def process_match(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    sequences = [] # List of (X, Y) tuples
    # X: Tensor [SeqLen]
    # Y: Tensor [4, 32] (Hands of all 4 players, 1=Held, 0=Not Held) - We will mask 'Self' later at training time
    
    mh = data.get('match_history', [])
    for round_data in mh:
        tricks = round_data.get('tricks', [])
        if not tricks: continue
        
        # 1. Reconstruct Hands (Ground Truth)
        # player_hands[player_idx] = set(card_indices)
        player_hands = {0: set(), 1: set(), 2: set(), 3: set()}
        
        # We map string "Bottom", "Right", "Top", "Left" to 0, 1, 2, 3
        p_map = {"Bottom": 0, "Right": 1, "Top": 2, "Left": 3}
        
        # First pass: Collect all ownership
        all_plays = [] # (player_idx, card_token) ordered by time
        
        for trick in tricks:
            played_by_names = trick.get('playedBy', [])
            cards = trick.get('cards', [])
            
            for i, p_name in enumerate(played_by_names):
                if i >= len(cards): break
                pid = p_map.get(p_name)
                c_obj = cards[i]
                c_str = parse_card_str(c_obj)
                if pid is not None and c_str:
                    c_idx = MindVocab.card_to_index(c_str) # 0-31
                    c_token = MindVocab.get_card_token(c_str)
                    
                    if c_idx >= 0:
                        player_hands[pid].add(c_idx)
                        all_plays.append((pid, c_token))

        # 2. Build Temporal Sequences
        # At each step T, the input is History[0...T-1].
        # The Target is the contents of hands at time T.
        # Note: As cards are played, they leave the hand.
        
        history_tokens = [MindVocab.START]
        
        # Add Bidding info (simplified for now - just Bid type)
        bid = round_data.get('bid', {})
        if bid:
            b_token = MindVocab.get_bid_token(bid.get('type', 'PASS'))
            if b_token: history_tokens.append(b_token)

        # Iterate through plays matrix
        current_hands = {k: v.copy() for k,v in player_hands.items()}
        
        for pid, c_token in all_plays:
            # Snapshot State BEFORE this card is played
            # Input: history_tokens
            # Target: current_hands
            
            # Construct Target Tensor
            # Shape [4, 32]
            target = torch.zeros((4, 32))
            for p in range(4):
                for c in current_hands[p]:
                    target[p, c] = 1.0
            
            sequences.append((
                torch.tensor(history_tokens, dtype=torch.long), 
                target.clone()
            ))
            
            # Update State
            # 1. Add this play to history
            history_tokens.append(c_token)
            # 2. Remove card from hand (it's revealed, no longer hidden/held)
            # Actually, standard Mind Reader predicts REMAINING hands.
            c_idx = c_token - MindVocab.PLAY_OFFSET
            if c_idx in current_hands[pid]:
                current_hands[pid].remove(c_idx)
                
    return sequences

def main():
    print("Generating MindReader Dataset...")
    files = glob.glob("matches/*.json")
    print(f"Found {len(files)} replay files.")
    
    all_data = []
    total_samples = 0
    
    for f in files:
        try:
            seqs = process_match(f)
            all_data.extend(seqs)
            total_samples += len(seqs)
            print(f"Processed {f}: +{len(seqs)} samples")
        except Exception as e:
            print(f"Skipping {f}: {e}")
            
    print(f"Total Samples: {total_samples}")
    
    if total_samples > 0:
        torch.save(all_data, "ai_worker/data/mind_data.pt")
        print("Saved to ai_worker/data/mind_data.pt")
    else:
        print("No samples generated. Play more games.")

if __name__ == "__main__":
    main()

```

### FILE: scripts\generate_neural_data.py (SKIPPED - >10KB)
### FILE: scripts\generate_roi_dataset.py
```py
import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

import shutil
import glob
from game_engine.visionary.visionary import DatasetGenerator

def reset_dataset():
    # Clear existing data
    dirs = [
        "dataset/images/train",
        "dataset/images/val",
        "dataset/labels/train",
        "dataset/labels/val"
    ]
    for d in dirs:
        if os.path.exists(d):
            print(f"Clearing {d}...")
            files = glob.glob(os.path.join(d, "*"))
            for f in files:
                os.remove(f)
        os.makedirs(d, exist_ok=True)

def generate_rois():
    # Initialize Generator
    # We hack the output_dir to be 'dataset' so it uses 'dataset/images'
    # But we want 'dataset/images/train'. 
    # The DatasetGenerator hardcodes 'images' and 'labels' subdirs.
    # So we will let it generate to 'dataset_temp' and move them.
    
    temp_dir = "dataset_temp"
    if os.path.exists(temp_dir):
        shutil.rmtree(temp_dir)
        
    print("Initializing DatasetGenerator...")
    generator = DatasetGenerator(output_dir=temp_dir)
    
    video_path = "dataset/Project.mp4"
    if not os.path.exists(video_path):
        print(f"Error: Video not found at {video_path}")
        return

    print(f"Processing {video_path}...")
    # interval=0.5 to get more frames since we are splitting them
    generator.process_video_for_training(video_path, interval=1.0) 
    
    # Move to train dir
    src_images = os.path.join(temp_dir, "images")
    dst_images = "dataset/images/train"
    
    count = 0
    if os.path.exists(src_images):
        for f in os.listdir(src_images):
            shutil.move(os.path.join(src_images, f), os.path.join(dst_images, f))
            count += 1
            
    print(f"Moved {count} ROI images to {dst_images}")
    
    # Clean up
    shutil.rmtree(temp_dir)

if __name__ == "__main__":
    reset_dataset()
    generate_rois()

```

### FILE: scripts\inspect_py4web.py
```py
import py4web
import py4web.core
from py4web import action

print("--- py4web ---")
print(dir(py4web))

print("\n--- py4web.core ---")
print(dir(py4web.core))

print("\n--- action ---")
print(dir(action))

# PATCH logic from server/main.py
from py4web import core
import os

def safe_module2filename(module):
    try:
        if '.' not in module:
            return module + ".py"
        parts = module.split(".")[1:]
        if not parts:
            return module + ".py"
        return os.path.join(*parts)
    except:
        return module
        
core.module2filename = safe_module2filename

@action("test_route", method=["GET"])
def test_func():
    return "ok"

print(f"\nAction Registered? {len(action.registered)}")
if action.registered:
    act = action.registered[0]
    print(f"Action Object: {act}")
    print(f"Dir: {dir(act)}")
    print(f"Path: {getattr(act, 'path', 'N/A')}")
    print(f"Method: {getattr(act, 'method', 'N/A')}")
    print(f"Func: {getattr(act, 'f', 'N/A')}")
    print(f"Is it callable? {callable(act)}")

```

### FILE: scripts\launch_ww.ps1
```ps1
param (
    [switch]$Headless
)

Write-Host "=== üöÄ Launching Full Baloot Game Stack (/WW) ===" -ForegroundColor Cyan
if ($Headless) { Write-Host "   üëª HEADLESS MODE ACTIVE" -ForegroundColor DarkGray }

# 1. Cleanup First
Write-Host "invoking cleanup..." -ForegroundColor Gray
& ./scripts/cleanup.ps1

function Wait-For-Http ($port, $name) {
    Write-Host "   ‚è≥ Waiting for $name (Port $port)..." -NoNewline
    $url = "http://127.0.0.1:$port"
    if ($name -eq "Backend") { $url += "/health" }
    for ($i = 0; $i -lt 30; $i++) {
        try {
            $response = Invoke-WebRequest -Uri $url -UseBasicParsing -Method Get -TimeoutSec 1 -ErrorAction Stop
            if ($response.StatusCode -eq 200) {
                Write-Host " ‚úÖ UP" -ForegroundColor Green
                return $true
            }
        } catch {
            Start-Sleep -Milliseconds 1000
            Write-Host "." -NoNewline
        }
    }
    Write-Host " ‚ùå TIMEOUT" -ForegroundColor Red
    return $false
}

# 2. Redis Strategy (Local -> Docker)
$redis_running = Get-Process redis-server -ErrorAction SilentlyContinue

if ($redis_running) {
    Write-Host "‚úÖ Local Redis is running (PID: $($redis_running.Id))." -ForegroundColor Green
} else {
    Write-Host "‚ö†Ô∏è Local Redis not running. Checking for Docker..." -ForegroundColor Yellow
    
    # 1. Ensure Docker is running (Only if we need it)
    & ./scripts/ensure_docker.ps1
    if ($LASTEXITCODE -ne 0) {
        Write-Host "Wrapper: Docker failed to start AND Local Redis is missing." -ForegroundColor Red
        # Fallthrough to error message below...
    }
    
    # Check Docker
    $docker_running = docker ps --filter "name=baloot-redis" --format "{{.Names}}"
    $docker_exists = docker ps -a --filter "name=baloot-redis" --format "{{.Names}}"
    
    if ($docker_running -match "baloot-redis") {
        Write-Host "‚úÖ Redis Container is running." -ForegroundColor Green
    } elseif ($docker_exists -match "baloot-redis") {
        Write-Host "üîÑ Starting existing Redis Container..." -ForegroundColor Yellow
        docker start baloot-redis
    } else {
        # Try to run container if docker is available
        if (Get-Command docker -ErrorAction SilentlyContinue) {
             Write-Host "üöÄ Creating and Starting Redis Container..." -ForegroundColor Yellow
             docker run --name baloot-redis -p 6379:6379 -d redis
        } else {
             Write-Host "‚ùå Redis not found (Local or Docker). Please install Redis or Docker." -ForegroundColor Red
             # We don't exit here, might be running elsewhere? But huge risk.
             Write-Host "   Continuing, but Game State persistence will fail." -ForegroundColor Red
        }
    }
}

# 3. Start Game Server (SocketIO)
Write-Host "`n[3/4] Starting Game Server..." -ForegroundColor Yellow
if ($Headless) {
    $serverLogOut = "logs/server_headless.out.log"
    $serverLogErr = "logs/server_headless.err.log"
    Write-Host "   Log -> $serverLogOut" -ForegroundColor Gray
    Stop-Process -Name "python" -ErrorAction SilentlyContinue # Double check cleanup
    Start-Process python -ArgumentList "-m", "server.main" -WindowStyle Hidden -RedirectStandardOutput $serverLogOut -RedirectStandardError $serverLogErr
} else {
    # Clear Log
    "" | Out-File "logs/server_debug.log" -Encoding utf8
    $cmd = '$host.ui.RawUI.WindowTitle = ''Baloot Backend''; python -m server.main'
    Start-Process powershell -ArgumentList "-NoExit", "-Command", $cmd
}

# 4. Start Frontend (Vite)
Write-Host "`n[4/4] Starting Frontend..." -ForegroundColor Yellow
if ($Headless) {
    $frontendLogOut = "logs/frontend_headless.out.log"
    $frontendLogErr = "logs/frontend_headless.err.log"
    Write-Host "   Log -> $frontendLogOut" -ForegroundColor Gray
    Start-Process cmd -ArgumentList "/c", "cd frontend && npm run dev" -WindowStyle Hidden -RedirectStandardOutput $frontendLogOut -RedirectStandardError $frontendLogErr
} else {
    $cmd = '$host.ui.RawUI.WindowTitle = ''Baloot Frontend''; cd frontend; npm run dev'
    Start-Process powershell -ArgumentList "-NoExit", "-Command", $cmd
}

Write-Host "`n‚úÖ All services initiated!" -ForegroundColor Green

# 5. Robust Health Check (Agent Verification)
if ($Headless) {
    Write-Host "`nüîç Verifying Service Health..." -ForegroundColor Cyan
    $be = Wait-For-Http 3005 "Backend"
    $fe = Wait-For-Http 5173 "Frontend"
    
    if (-not ($be -and $fe)) {
        Write-Host "‚ùå Health Check Failed. Dumping last logs:" -ForegroundColor Red
        Get-Content "logs/server_headless.err.log" -Tail 20
        Write-Error "Deployment failed."
    }
    
    Write-Host "   Use 'Get-Content logs/server_headless.out.log -Tail 10' to monitor." -ForegroundColor Cyan
} else {
    Write-Host "   Check the 2 new windows." -ForegroundColor Cyan
    Write-Host "   Main window will close in 5 seconds..." -ForegroundColor Gray
    Start-Sleep -Seconds 5
}

```

### FILE: scripts\lint.py
```py
import os
import subprocess
import sys

def run_command(command):
    print(f"Running: {command}")
    result = subprocess.run(command, shell=True)
    return result.returncode == 0

def main():
    print("=== üßπ Linting Project ===")
    
    # Check if tools exist
    try:
        subprocess.run(["flake8", "--version"], capture_output=True)
        has_flake8 = True
    except FileNotFoundError:
        has_flake8 = False
        print("‚ö†Ô∏è  flake8 not found. Skipping python linting.")

    all_passed = True

    if has_flake8:
        # Exclude venv and migration folders
        print("\n--> Python (flake8)...")
        if not run_command("flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude .git,__pycache__,.env,node_modules,venv"):
            all_passed = False

    print("\n--> Frontend (npm run lint)...")
    if os.path.exists("frontend/package.json"):
        if not run_command("cd frontend && npm run lint --if-present"):
             # Don't fail the whole script if just frontend lint fails for now
             print("‚ö†Ô∏è  Frontend lint found issues.")

    if all_passed:
        print("\n‚úÖ All checks passed!")
    else:
        print("\n‚ùå Some checks failed.")
        sys.exit(1)

if __name__ == "__main__":
    main()

```

### FILE: scripts\list_db.py
```py
import sys
import os
import json
import datetime

# Add project root to path
sys.path.append(os.getcwd())

# Setup DB
try:
    from server.common import db
    import server.models # Ensure tables are defined
    
    print("DB Connected.")
    
    if 'match_archive' not in db.tables:
        print("ERROR: match_archive table NOT found!")
        sys.exit(1)
        
    print("Querying match_archive...")
    
    rows = db(db.match_archive.id > 0).select()
    print(f"Total Records: {len(rows)}")
    
    for r in rows:
        print(f"ID: {r.id}, GameID: {r.game_id}, Score: {r.final_score_us}-{r.final_score_them}, Time: {r.timestamp}")
        
except Exception as e:
    print(f"CRITICAL ERROR: {e}")
    import traceback
    traceback.print_exc()

```

### FILE: scripts\list_models.py
```py
import google.generativeai as genai
import os

env_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), '.env')
if os.path.exists(env_path):
    with open(env_path, 'r') as f:
        for line in f:
            if '=' in line and not line.startswith('#'):
                key, value = line.strip().split('=', 1)
                os.environ[key] = value

genai.configure(api_key=os.environ.get("GEMINI_API_KEY"))

try:
    print("Listing models...")
    for m in genai.list_models():
        if 'generateContent' in m.supported_generation_methods:
            print(m.name)
except Exception as e:
    print(f"Error listing models: {e}")

```

### FILE: scripts\measure_iq.py
```py
import os
import sys
import json
import time
import logging

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from ai_worker.agent import BotAgent
from ai_worker.bot_context import BotContext
# Ensure DB is loaded for agent if it relies on it (though agent uses Redis mostly)
import server.models

logging.basicConfig(level=logging.INFO, format='%(message)s')
logger = logging.getLogger("IQ_METER")

def measure_iq():
    """
    Runs the current Bot Logic against the Golden Puzzle Set.
    Calculates an 'IQ Score' (Accuracy %).
    """
    benchmark_path = os.path.join("ai_worker", "benchmarks", "golden_puzzles.json")
    
    if not os.path.exists(benchmark_path):
        logger.error("‚ùå Benchmark file not found. Run 'python scripts/generate_benchmark.py' first.")
        return

    with open(benchmark_path, 'r', encoding='utf-8') as f:
        puzzles = json.load(f)
        
    if not puzzles:
        logger.warning("‚ö†Ô∏è No puzzles found in benchmark file.")
        return

    logger.info(f"üß† Starting IQ Test on {len(puzzles)} scenarios...")
    logger.info("-" * 50)
    
    agent = BotAgent()
    # Force Disable Redis for the Agent? 
    # Or do we WANT it to use memory?
    # User asked to measure "Progress Of Intelligence". 
    # Intelligence = Logic + Memory. So keep Redis enabled.
    
    correct_count = 0
    total = len(puzzles)
    
    for i, puzzle in enumerate(puzzles):
        state = puzzle['game_state']
        expected = puzzle['solution']
        
        # Determine player index from state (usually the one whose turn it is)
        player_index = state.get('currentTurnIndex', 0)
        
        try:
            start_ts = time.perf_counter()
            decision = agent.get_decision(state, player_index)
            duration = (time.perf_counter() - start_ts) * 1000
            
            # Compare
            # We compare Action + CardIndex (if Play) or Action + Suit (if Bid)
            is_correct = False
            
            if expected.get('action') == decision.get('action'):
                if expected['action'] == 'PLAY':
                     # Loose comparison: CardIndex or Card Rank/Suit?
                     # Puzzles usually store the logic. 
                     # If the puzzle solution has 'cardIndex', use that.
                     if 'cardIndex' in expected:
                         is_correct = (expected['cardIndex'] == decision.get('cardIndex'))
                     else:
                         # Fallback: Compare content if needed (not implemented in simple check)
                         is_correct = True
                elif expected['action'] in ['SUN', 'HOKUM']:
                     is_correct = (expected.get('suit') == decision.get('suit'))
                else:
                     is_correct = True
            
            result_icon = "‚úÖ" if is_correct else "‚ùå"
            if is_correct: correct_count += 1
            
            logger.info(f"{result_icon} Puzzle #{i+1}: {decision.get('action')} (Time: {duration:.1f}ms) | Expect: {expected.get('action')}")
            
            if not is_correct:
                 logger.info(f"   Reasoning: {decision.get('reasoning')}")
                 logger.info(f"   Expected: {expected.get('reason')} (from Gemini)")
                 
        except Exception as e:
            logger.error(f"Error executing puzzle {puzzle['id']}: {e}")

    accuracy = (correct_count / total) * 100
    
    logger.info("-" * 50)
    logger.info(f"üéì Final IQ Score: {correct_count}/{total} ({accuracy:.1f}%)")
    
    # Grade
    grade = "F"
    if accuracy >= 90: grade = "A+"
    elif accuracy >= 80: grade = "A"
    elif accuracy >= 70: grade = "B"
    elif accuracy >= 60: grade = "C"
    elif accuracy >= 50: grade = "D"
    
    logger.info(f"üèÜ Grade: {grade}")
    
    # Save Report
    report_path = os.path.join("docs", "iq_report.md")
    with open(report_path, "w", encoding='utf-8') as f:
         f.write(f"# üß† AI IQ Report\n")
         f.write(f"**Date**: {time.strftime('%Y-%m-%d %H:%M')}\n")
         f.write(f"**Score**: {accuracy:.1f}%\n")
         f.write(f"**Grade**: {grade}\n")
         f.write(f"**Sample Size**: {total} puzzles\n")

if __name__ == "__main__":
    measure_iq()

```

### FILE: scripts\ping_redis.py
```py
import redis
import sys

print("Pinging Redis at redis://localhost:6379/0...")
try:
    r = redis.from_url("redis://localhost:6379/0", socket_timeout=5)
    r.ping()
    print("‚úÖ Success! (localhost)")
except Exception as e:
    print(f"‚ùå Failed (localhost): {e}")

print("Pinging Redis at redis://127.0.0.1:6379/0...")
try:
    r = redis.from_url("redis://127.0.0.1:6379/0", socket_timeout=5)
    r.ping()
    print("‚úÖ Success! (127.0.0.1)")
except Exception as e:
    print(f"‚ùå Failed (127.0.0.1): {e}")

```

### FILE: scripts\profile_bots.py
```py
import sys
import os
import time
import cProfile
import pstats
import logging
from unittest.mock import MagicMock

# Add project root to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from game_engine.logic.game import Game
from game_engine.models.player import Player
from bot_agent import BotAgent
from server.bidding_engine import BidType

# Configure Logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("Profiler")

class HeadlessGame(Game):
    """Subclass of Game that mocks socket interactions."""
    def __init__(self, room_id):
        super().__init__(room_id)
        # Mocking generic socket/timer interactions if any
        self.timer = MagicMock()
    
    # Override emit to do nothing
    def emit(self, event, data):
        pass

def run_simulation():
    game = HeadlessGame("test_room")
    
    # Add 4 Bot Players
    bot_agent = BotAgent()
    game.add_player("p1", "Saad (Bot)")
    game.add_player("p2", "Khalid (Bot)")
    game.add_player("p3", "Noura (Bot)")
    game.add_player("p4", "Abu Fahad (Bot)")
    
    # Start Round (Manually triggering state)
    game.players[0].hand = [] # Logic populates this
    # We need to simulate the distribution.
    # Actually, Game logic has dealing.
    
    game.deck.shuffle()
    # Deal 5 cards
    for p in game.players:
        # Deal 5 cards. deal(n) returns a list of n cards.
        p.hand = game.deck.deal(5)
    
    # Force bidding phase
    game.phase = "BIDDING"
    game.current_turn = 0
    game.dealer_index = 3
    
    print("Starting Profiling Loop...")
    
    start_time = time.time()
    decisions = 0
    
    # Simulate 100 decisions
    profiler = cProfile.Profile()
    profiler.enable()
    
    for _ in range(100):
        # Fake a turn for player 0
        state = game.get_game_state()
        
        # Measure Bot Decision
        try:
            decision = bot_agent.get_decision(state, 0)
            decisions += 1
        except Exception as e:
            print(f"Error in decision: {e}")
            break
            
    profiler.disable()
    end_time = time.time()
    
    print(f"\nCompleted {decisions} decisions in {end_time - start_time:.4f}s")
    print(f"Average: {(end_time - start_time)/decisions*1000:.2f}ms per decision")
    
    # Stats
    stats = pstats.Stats(profiler).sort_stats('cumtime')
    stats.print_stats(20)

if __name__ == "__main__":
    run_simulation()

```

### FILE: scripts\quick_check.py
```py
import sys
import os
import subprocess
import argparse

def main():
    parser = argparse.ArgumentParser(description="Run quick targeted tests.")
    parser.add_argument('target', nargs='?', default='logic', help="Target module/test to run (e.g. 'logic', 'bidding', 'sawa')")
    args = parser.parse_args()

    base_cmd = ["python", "-m", "pytest"]
    
    # Map friendly names to test paths
    targets = {
        'logic': 'tests/test_game_logic.py',
        'bidding': 'tests/test_bidding_rules.py',
        'sawa': 'tests/test_scenarios.py -k sawa',
        'projects': 'tests/test_projects_logic.py',
        'all': 'tests/' 
    }
    
    # Default fallback to searching by keyword if not in map
    test_path = targets.get(args.target)
    
    if test_path:
        print(f"üöÄ Running Quick Check for: {args.target} ({test_path})")
        cmd = base_cmd + test_path.split()
    else:
        # Assume it's a keyword match
        print(f"üîé Searching tests for keyword: {args.target}")
        cmd = base_cmd + ["-k", args.target, "tests/"]

    try:
        subprocess.run(cmd, check=True)
        print("\n‚úÖ Quick Check PASSED")
    except subprocess.CalledProcessError:
        print("\n‚ùå Quick Check FAILED")
        sys.exit(1)

if __name__ == "__main__":
    main()

```

### FILE: scripts\repro_circular.py
```py
import sys
import traceback

try:
    print("Attempting to import BiddingEngine...")
    from game_engine.logic.bidding_engine import BiddingEngine
    print("Success: BiddingEngine imported.")
except ImportError:
    print("ImportError Caught!")
    traceback.print_exc()
except Exception:
    print("Other Exception Caught!")
    traceback.print_exc()

```

### FILE: scripts\restart_game.ps1
```ps1
$ErrorActionPreference = "SilentlyContinue"

Write-Host "=== üîÑ Restarting Baloot Game Environment ===" -ForegroundColor Cyan

# 1. Cleanup
& ./scripts/cleanup.ps1

# 2. Launch Backend
Write-Host "`n[2/3] Launching Backend..."
$logFile = "logs/server_debug.log"
$logFileErr = "logs/server_error.log"
# Clear log files
"" | Out-File $logFile -Encoding utf8
"" | Out-File $logFileErr -Encoding utf8

$pythonPath = (Get-Command "python" -ErrorAction SilentlyContinue).Source
if (-not $pythonPath) {
    Write-Host "‚ùå Python not found in PATH!" -ForegroundColor Red
    exit 1
}
Write-Host "   ‚ÑπÔ∏è  Using Python: $pythonPath" -ForegroundColor Gray

try {
    # Using -u for unbuffered output
    $serverProcess = Start-Process $pythonPath -ArgumentList "-u", "-m", "server.main" -RedirectStandardOutput $logFile -RedirectStandardError $logFileErr -PassThru -ErrorAction Stop
    Write-Host "   ‚úÖ Backend started (PID: $($serverProcess.Id))." -ForegroundColor Green
} catch {
    Write-Host "‚ùå Failed to launch backend process! Error: $_" -ForegroundColor Red
    exit 1
}

# 3. Launch Frontend
Write-Host "`n[3/3] Launching Frontend..."
Set-Location "frontend"
# Run hidden or minimized? User usually wants to see errors. Hidden is good for restarts if main window persists.
# But here we are restarting everything.
$frontendProcess = Start-Process powershell -ArgumentList "-Command", "npm run dev" -PassThru -WindowStyle Minim
Set-Location ..
Write-Host "   ‚úÖ Frontend started (PID: $($frontendProcess.Id))." -ForegroundColor Green

Write-Host "`nüéâ Restart Complete! Game ready at http://localhost:5173" -ForegroundColor Cyan

```

### FILE: scripts\restart_server.ps1
```ps1

Write-Host "Rebooting Game Server Stack..." -ForegroundColor Cyan

# 1. Kill Python Processes (Aggressive)
Write-Host "Killing Python processes..."
Get-Process python -ErrorAction SilentlyContinue | Where-Object { $_.MainWindowTitle -like "*server.main*" -or $_.CommandLine -like "*server.main*" -or $_.CommandLine -like "*worker.py*" } | Stop-Process -Force

# Kill explicit PIDs if any linger
$ports = @(3005, 8080)
foreach ($port in $ports) {
    $p = Get-NetTCPConnection -LocalPort $port -ErrorAction SilentlyContinue
    if ($p) {
        Write-Host "Killing process on port $port..."
        Stop-Process -Id $p.OwningProcess -Force -ErrorAction SilentlyContinue
    }
}

# 2. Start AI Worker
Write-Host "Starting AI Worker..."
Start-Process -FilePath "python" -ArgumentList "ai_worker/worker.py" -WindowStyle Minimized

# 3. Start Game Server
Write-Host "Starting Game Server..."
Start-Process -FilePath "python" -ArgumentList "-m server.main" -NoNewWindow

Write-Host "Server Stack Restarted." -ForegroundColor Green

```

### FILE: scripts\run_arena.py
```py
import time
import json
import os
import sys

# Add root to python path to allow imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Create environment variable to disable Redis in bot_agent
# os.environ["OFFLINE_MODE"] = "true" # Commented out for Production Mode check


from game_engine.arena import Arena
# from bot_agent import bot_agent # No longer needed to import just to patch



def run_batch(num_games=100):
    arena = Arena()
    results = []
    
    start_time = time.time()
    wins = {"us": 0, "them": 0}
    errors = 0
    
    print(f"Starting Batch Simulation of {num_games} games...")
    
    for i in range(num_games):
        match_id = f"sim_{int(time.time())}_{i}"
        try:
            res = arena.run_match(match_id)
            results.append(res)
            
            w = res.get('winner')
            if w: wins[w] += 1
            
            # Progress bar
            if (i+1) % 10 == 0:
                print(f"Completed {i+1}/{num_games} games. Wins: {wins}")
                
        except Exception as e:
            print(f"Match {i} Failed: {e}")
            errors += 1

    total_time = time.time() - start_time
    print(f"\n--- Batch Finished in {total_time:.2f}s ---")
    print(f"Total Games: {num_games}")
    print(f"Win Rate (US): {wins['us']/num_games:.1%}")
    print(f"Win Rate (THEM): {wins['them']/num_games:.1%}")
    print(f"Draws/Incomplete: {num_games - wins['us'] - wins['them']}")
    print(f"Errors: {errors}")
    print(f"Avg Time/Game: {total_time/num_games:.3f}s")
    
    # Save Results
    os.makedirs("candidates", exist_ok=True)
    with open("candidates/arena_results.json", "w") as f:
        json.dump(results, f, indent=2)
    print("Results saved to candidates/arena_results.json")

if __name__ == "__main__":
    count = 100
    if len(sys.argv) > 1:
        count = int(sys.argv[1])
    run_batch(count)

```

### FILE: scripts\run_nightly_scout.ps1
```ps1

Write-Host "--- Automated Scout Routine ---" -ForegroundColor Cyan

$LogFile = "logs/server_manual.log"

# 1. Archive old logs (Optional cleanup)
if (Test-Path $LogFile) {
    $Size = (Get-Item $LogFile).Length
    if ($Size -gt 5MB) {
        Write-Host "Log file too large ($Size bytes). Rotating..."
        Move-Item $LogFile "logs/server_manual_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
    }
}

# 2. Run Game Verification (Simulation) to generate logs
Write-Host "Starting Game Simulation to generate data..."
$SimProcess = Start-Process python -ArgumentList "scripts/verify_game_flow.py", "--duration", "300" -PassThru -NoNewWindow
$SimProcess | Wait-Process

Write-Host "Simulation Complete." -ForegroundColor Green

# 3. Run The Scout
Write-Host "Releasing The Scout..." -ForegroundColor Yellow
python scripts/scout.py

Write-Host "Scout Routine Finished." -ForegroundColor Cyan

```

### FILE: scripts\run_test_suite.py
```py

import subprocess
import os
import sys
import time

SCENARIOS = [
    "full_game",
    "bidding_sun",
    "bidding_hokum",
    "bidding_ashkal",
    "project_four",
    "project_sequence",
    "project_baloot",
    "sawa_test",
    "double_test",
    "stress_test",
    "edge_all_pass"
]


SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(SCRIPT_DIR)
# Ensure project root is in path for subprocess execution context if needed
# But subprocess calls python cli_test_runner.py, so we need to pass env or ensure cli_test_runner handles strict paths.

LOG_DIR = os.path.join(PROJECT_ROOT, "logs")
REPORT_FILE = os.path.join(PROJECT_ROOT, "docs", "TEST_REPORT.md")

def run_scenario(scenario_name, extra_args=None):
    print(f"Running scenario: {scenario_name}...", end="", flush=True)
    log_file = os.path.join(LOG_DIR, f"{scenario_name}.log")
    
    cmd = [
        sys.executable, 
        os.path.join(SCRIPT_DIR, "cli_test_runner.py"), 
        "--scenario", scenario_name,
        "--log-file", log_file,
        "--debug"
    ]
    
    if extra_args:
        cmd.extend(extra_args)
    
    start_time = time.time()
    try:
        # Run process
        result = subprocess.run(
            cmd, 
            capture_output=True, 
            text=True
        )
        duration = time.time() - start_time
        
        success = (result.returncode == 0)
        
        # Parse log file for quick stats (optional)
        # For now just trust return code
        
        status = "‚úÖ PASS" if success else "‚ùå FAIL"
        print(f" {status} ({duration:.2f}s)")
        
        return {
            "name": scenario_name,
            "status": status,
            "duration": duration,
            "log_file": log_file,
            "return_code": result.returncode
        }
        
    except Exception as e:
        print(f" Error: {e}")
        return {
            "name": scenario_name,
            "status": "‚ùå ERROR",
            "duration": 0,
            "log_file": log_file,
            "return_code": -1,
            "error": str(e)
        }

def generate_report(results):
    with open(REPORT_FILE, "w", encoding="utf-8") as f:
        f.write("# Baloot Game Test Report\n\n")
        f.write(f"**Date:** {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        f.write("| Scenario | Status | Duration | Log File |\n")
        f.write("|---|---|---|---|\n")
        
        passed = 0
        total = len(results)
        
        for r in results:
            if "PASS" in r["status"]:
                passed += 1
            f.write(f"| {r['name']} | {r['status']} | {r['duration']:.2f}s | [View Log]({r['log_file']}) |\n")
        
        f.write(f"\n**Summary:** {passed}/{total} Passed\n")
    
    print(f"\nReport generated: {os.path.abspath(REPORT_FILE)}")

def main():
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)
        
    results = []
    print(f"Starting execution of {len(SCENARIOS)} scenarios...\n")
    
    for scenario in SCENARIOS:
        settings = {} 
        # For stress test, maybe run fewer games for this quick suite?
        # Default is 1 game for most, stress test default in runner is ???
        # cli_test_runner.py defaults to 1 game.
        # But 'stress_test' scenario class defaults to 10 games validation logic?
        # Let's check test_scenarios.py... 
        # Yes, StressTestScenario(10). 
        # The runner loop runs N games passed via --games.
        # If we run "stress_test" with --games 1 (default), the validation might fail 
        # because it expects 10 games completed?
        # Let's check StressTestScenario code in test_scenarios.py
        
        # Valid: "if self.completed_games >= self.num_games"
        # If we run runner with --games 1, scenario.validate is called once.
        # num_games is 10. completed_games becomes 1. 1 >= 10 is False.
        # So it returns {success: True, message: "Game 1/10 completed"}?
        # Ah, validate returns success=True but just a message.
        # cli_test_runner.py checks result['success'].
        # So it might pass but just say "Game 1/10 completed".
        
        # To be "proper", for stress_test we should pass --games 10.
        
        extra_args = []
        if scenario == "stress_test":
             extra_args = ["--games", "5"]
             
        results.append(run_scenario(scenario, extra_args))
        
    generate_report(results)

if __name__ == "__main__":
    main()

```

### FILE: scripts\scout.py
```py

import json
import os
import sys
import logging
import time
from datetime import datetime

# Add project root to path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from server.logging_utils import LOG_FILE
from ai_worker.llm_client import GeminiClient
from server.common import logger # Use common logger

# Configuration
# Ensuring backend/data/training exists
DATA_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "ai_worker", "data", "training"))
MISTAKES_FILE = os.path.join(DATA_DIR, "mistakes_extracted.json")
os.makedirs(DATA_DIR, exist_ok=True)

def parse_logs(log_file_path):
    """Parses the log file and groups events by game_id."""
    games = {}
    
    if not os.path.exists(log_file_path):
        print(f"Log file not found: {log_file_path}")
        return games

    print(f"Parsing logs from: {log_file_path}")
    
    with open(log_file_path, 'r', encoding='utf-8') as f:
        for line in f:
            if "[EVENT]" in line:
                try:
                    # Extract JSON payload after [EVENT]
                    json_str = line.split("[EVENT]", 1)[1].strip()
                    event = json.loads(json_str)
                    
                    game_id = event.get("game_id")
                    if not game_id or game_id == "GLOBAL":
                        continue
                        
                    if game_id not in games:
                        games[game_id] = {
                            "events": [], 
                            "start_time": event.get("timestamp"),
                            "is_complete": False,
                            "winner": None,
                            "scores": {"us": 0, "them": 0}
                        }
                    
                    games[game_id]["events"].append(event)
                    
                    if event.get("event") == "GAME_END":
                        games[game_id]["is_complete"] = True
                        games[game_id]["winner"] = event.get("details", {}).get("winner")
                        games[game_id]["scores"] = event.get("details", {}).get("final_score", {})

                except json.JSONDecodeError:
                    continue
                except Exception as e:
                    # print(f"Error parsing line: {e}")
                    continue
    
    return games

def reconstruct_game(game_data):
    """
    Reconstructs the game state from events. 
    This is complex; for now, we just pass the raw event stream or 
    key snapshots if available.
    """
    # TODO: Implement full state reconstruction replay if needed.
    return game_data["events"]

def identify_mistakes(games):
    """
    Identifies games worth analyzing (e.g., User losses).
    """
    candidates = []
    for game_id, data in games.items():
        if data["is_complete"]:
            # Simple heuristic: Analyze lost games (Assuming User is team 'us' or 0/2)
            # Adjust heuristic as needed.
            # detailed criteria can be added here.
            candidates.append(data)
    return candidates

def main():
    print("Starting Scout...")
    print(f"Analysis Output Dir: {DATA_DIR}")
    
    # 1. Parse Logs
    games = parse_logs(LOG_FILE)
    print(f"Found {len(games)} games in logs.")
    
    # 2. Filter Candidates
    candidates = identify_mistakes(games)
    print(f"Identified {len(candidates)} completed games for analysis.")
    
    if not candidates:
        print("No candidates found. Exiting.")
        return

    # 3. Analyze with Gemini (Simulated or Real)
    gemini = GeminiClient()
    
    extracted_mistakes = []
    
    # Limit to 5 most recent for now to save tokens/time
    for game in candidates[-5:]: 
        game_id = game["events"][0]["game_id"]
        print(f"Analyzing Game: {game_id}...")
        
        # In a real implementation, we would replay the game state-by-state 
        # and ask Gemini to critique specific moves. 
        # For now, we assume we want to analyze the whole match or identifying 
        # a specific 'blunder' via LLM is the goal.
        
        # Converting event stream to a text summary for the LLM
        # This is a simplification.
        
        analysis = gemini.analyze_match_history(game["events"])
        if analysis:
            print(f"Analysis for {game_id}: Received.")
            import re
            match = re.search(r'\{.*\}', analysis, re.DOTALL)
            if match:
                json_candidate = match.group(0)
                try:
                    analysis_json = json.loads(json_candidate)
                    extracted_mistakes.append({
                        "game_id": game_id,
                        "analysis": analysis_json
                    })
                except json.JSONDecodeError:
                     print(f"Failed to parse JSON from analysis for {game_id}")
                     extracted_mistakes.append({
                        "game_id": game_id,
                        "analysis_raw": analysis
                     })
            else:
                 print(f"No JSON found in analysis for {game_id}")
                 extracted_mistakes.append({
                    "game_id": game_id,
                    "analysis_raw": analysis
                 })
        else:
            print(f"Skipping {game_id} (Analysis failed).")
            
    # 4. Save Results
    with open(MISTAKES_FILE, 'w', encoding='utf-8') as f:
        json.dump(extracted_mistakes, f, indent=2)
        
    print(f"Saved {len(extracted_mistakes)} analyses to {MISTAKES_FILE}")

if __name__ == "__main__":
    main()

```

### FILE: scripts\seed_puzzles.py
```py

import os
import sys
import json
import logging
import uuid
import time

# Setup Paths
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from server.common import db
# Ensure tables
import server.models

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("SeedPuzzles")

def seed_puzzles():
    logger.info("Seeding database with manual Golden Puzzles...")

    # Puzzle 1: Don't eat your partner's ace (Sun)
    # Scenario: Partner plays Ace Sun. You have King. Do not play King if you have a small card.
    state_1 = {
        "players": [
            {"position": "Bottom", "hand": [{"suit": "S", "rank": "K"}, {"suit": "S", "rank": "7"}, {"suit": "H", "rank": "10"}], "name": "Me"},
            {"position": "Right", "hand": [], "name": "Bot"},
            {"position": "Top", "hand": [], "name": "Partner"},
            {"position": "Left", "hand": [], "name": "Bot"}
        ],
        "bid": {"type": "SUN", "bidder": "Top"},
        "currentTurnIndex": 0,
        "playedCards": {
            "2": {"suit": "S", "rank": "A", "playedBy": "Top"}, # Partner Played Ace
            "3": {"suit": "H", "rank": "7", "playedBy": "Left"}  # Left played garbage
        },
        "floorCard": None
    }
    
    correct_1 = {"suit": "S", "rank": "7"}
    bad_1 = {"suit": "S", "rank": "K"}
    reason_1 = "Your partner has already captured the trick with the Ace of Spades. Playing your King (10 points) is a waste because the Ace is the highest. Save your King for a future trick or throw 10/K on a winning trick to add points."

    # Puzzle 2: Cut the trick (Hokum)
    # Scenario: Opponent plays big Ace. You have no suit, but have Trump.
    state_2 = {
         "players": [
            {"position": "Bottom", "hand": [{"suit": "D", "rank": "7"}, {"suit": "C", "rank": "J"}], "name": "Me"}, # Diamond is Trump
            {"position": "Right", "hand": [], "name": "Bot"},
            {"position": "Top", "hand": [], "name": "Partner"},
            {"position": "Left", "hand": [], "name": "Bot"}
        ],
        "bid": {"type": "HOKUM", "suit": "D", "bidder": "Right"},
        "currentTurnIndex": 0,
        "playedCards": {
            "1": {"suit": "S", "rank": "A", "playedBy": "Right"} # Opponent Ace
        },
        "floorCard": {"suit": "D", "rank": "7"}
    }
    correct_2 = {"suit": "D", "rank": "7"} # Cut
    bad_2 = {"suit": "C", "rank": "J"} # Throw random
    reason_2 = "The opponent is winning with an Ace. You have a Trump (Diamond). You should 'cut' the trick to win it for your team."

    # Insert
    puzzles = [
        (state_1, bad_1, correct_1, reason_1),
        (state_2, bad_2, correct_2, reason_2)
    ]
    
    count = 0
    for s, b, c, r in puzzles:
        # Check uniqueness
        chash = f"seed-{uuid.uuid4().hex[:8]}"
        
        db.bot_training_data.insert(
            context_hash=chash,
            game_state_json=json.dumps(s),
            bad_move_json=json.dumps(b),
            correct_move_json=json.dumps(c),
            reason=r,
            created_on=datetime.datetime.now() if 'datetime' in globals() else None
        )
        count += 1
        
    db.commit()
    logger.info(f"Seeded {count} puzzles.")

import datetime
if __name__ == "__main__":
    seed_puzzles()

```

### FILE: scripts\simulate_bot_vision.py
```py

import sys
import os
import logging

# Setup path
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(current_dir)
sys.path.insert(0, project_root)

# Mock Logger
logging.basicConfig(level=logging.INFO)

from ai_worker.agent import BotAgent
from game_engine.models.card import Card

def test_bot_vision():
    print("=== Testing Bot Vision (Is Illegal Flag Visible?) ===")
    
    # 1. Setup Bot
    agent = BotAgent()
    
    # 2. Construct Game State with Illegal Move
    # P2 played Ace Hearts (Illegal)
    card_illegal = Card('‚ô•', 'A')
    
    game_state = {
        'gameId': 'viz_test',
        'players': [
            {'name': 'Me', 'index': 0, 'team': 'us', 'hand': [{'rank': '7', 'suit': '‚ô†'}]},
            {'name': 'Bot', 'index': 1, 'team': 'them', 'profile': 'Sherlock', 'hand': [{'rank': '9', 'suit': '‚ô£'}]},
            {'name': 'Partner', 'index': 2, 'team': 'us', 'hand': []},
            {'name': 'Right', 'index': 3, 'team': 'them', 'hand': []}
        ],
        'tableCards': [
            {
                'playerId': 'P_RIGHT', 
                'playedBy': 'Right', 
                'card': card_illegal.to_dict(), 
                'metadata': {'is_illegal': True, 'illegal_reason': 'REVOKE'}
            }
        ],
        'fullMatchHistory': [],
        'qaydState': {'active': False}, # Not active yet, we want to TRIGGER it
        'phase': 'PLAYING',
        'currentTurnIndex': 1, # Bot's turn
        'dealer': 0,
        'bid': {'type': 'SUN', 'bidder': 0}
    }
    
    # 3. Ask Bot for Decision
    print("Asking Bot (Index 1) for decision...")
    decision = agent.get_decision(game_state, 1)
    
    print(f"Bot Decision: {decision}")
    
    # 4. Verify
    if decision.get('action') == 'QAYD_ACCUSATION':
        print("‚úÖ SUCCESS: Bot saw the illegal move and accused!")
    elif decision.get('action') == 'QAYD_TRIGGER':
        print("‚úÖ SUCCESS: Bot triggered Qayd!")
    else:
        print("‚ùå FAILURE: Bot missed it. Action: ", decision.get('action'))

if __name__ == "__main__":
    test_bot_vision()

```

### FILE: scripts\simulate_game.py
```py
import sys
import os
import random
import time
# Add parent directory to sys.path to allow importing modules from root
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from server.game_logic import Game, GamePhase, SUITS

def run_simulation():
    print("Starting Headless Game Simulation...")
    game = Game("sim_room")
    
    # Add Players
    players = []
    for i in range(4):
        p = game.add_player(f"p{i}", f"Bot {i}")
        players.append(p)
    print("Players added.")
    
    # Start Game
    if game.start_game():
        print("Game started successfully.")
    else:
        print("Failed to start game.")
        return

    round_count = 0
    while game.phase != GamePhase.FINISHED.value and round_count < 100: # Safety break
        current_p = game.players[game.current_turn]
        
        if game.phase == GamePhase.BIDDING.value:
            # Simple Bidding Logic
            # Dealer's teammate (current_turn) usually passes or bids
            # Let's just make someone bid SUN to get things moving
            # If current_turn is 0, bid SUN, else PASS
            
            # Use a simple counter to vary bids? 
            # Or just have the first player bid SUN.
            
            # To test game logic, we need a valid bid.
            print(f"Bidding Phase. Turn: {current_p.name}")
            
            # Try to bid SUN if no bid yet
            if not game.bid['type']:
                # 50% chance to bid if not yet bid
                if random.random() > 0.5:
                    res = game.handle_bid(current_p.index, "SUN")
                    print(f"{current_p.name} bids SUN: {res}")
                else:
                    res = game.handle_bid(current_p.index, "PASS")
                    print(f"{current_p.name} passes: {res}")
            else:
                 # If bid already exists, everyone passes to start game
                 res = game.handle_bid(current_p.index, "PASS")
                 print(f"{current_p.name} passes (game should start soon): {res}")
                 
        elif game.phase == GamePhase.PLAYING.value:
            # Playing Logic
            # Find valid move
            valid_indices = []
            for idx, card in enumerate(current_p.hand):
                if game.is_valid_move(card, current_p.hand):
                    valid_indices.append(idx)
            
            if valid_indices:
                card_idx = random.choice(valid_indices)
                card = current_p.hand[card_idx]
                print(f"Playing Phase. Turn: {current_p.name}. Plays {card}")
                res = game.play_card(current_p.index, card_idx)
                if not res.get('success'):
                    print(f"Error playing card: {res}")
                    break
            else:
                print(f"Error: No valid moves for {current_p.name} with hand {current_p.hand}")
                break
                
        elif game.phase == GamePhase.WAITING.value:
             print("Game validation error: Back to WAITING?")
             break
             
        round_count += 1
        # time.sleep(0.05) # Small delay to see output if needed
    
    print("Simulation Ended.")
    print(f"Phase: {game.phase}")
    print(f"Scores: Us={game.match_scores['us']}, Them={game.match_scores['them']}")
    print("-" * 20)

if __name__ == "__main__":
    run_simulation()

```

### FILE: scripts\test_academy_api.py
```py
import requests
import sys

# Testing configuration
BASE_URL = "http://localhost:3005"

def test_academy_api():
    print(f"Testing Academy API at {BASE_URL}...")
    
    # 1. Test List Puzzles
    print("\n[TEST] 1. GET /academy/puzzles")
    try:
        res = requests.get(f"{BASE_URL}/academy/puzzles")
        if res.status_code != 200:
            print(f"FAILED: Status {res.status_code}")
            return
        
        data = res.json()
        puzzles = data.get('puzzles', [])
        print(f"SUCCESS: Found {len(puzzles)} puzzles.")
        if len(puzzles) == 0:
            print("WARN: No puzzles found to test details.")
            return
            
        first_id = puzzles[0]['id']
        print(f"Targeting First Puzzle: {first_id}")
        
    except Exception as e:
        print(f"FATAL: Could not connect to server. Is it running? {e}")
        return

    # 2. Test Get Puzzle
    print(f"\n[TEST] 2. GET /academy/puzzles/{first_id}")
    try:
        res = requests.get(f"{BASE_URL}/academy/puzzles/{first_id}")
        if res.status_code != 200:
            print(f"FAILED: Status {res.status_code}")
            return
            
        puzzle_data = res.json().get('puzzle')
        if not puzzle_data:
             print("FAILED: No puzzle body returned")
             return
             
        title = puzzle_data.get('title')
        solution = puzzle_data.get('solution')
        print(f"SUCCESS: Loaded '{title}'")
        print(f"Expected Solution: {solution}")
        
    except Exception as e:
        print(f"FAILED: {e}")
        return

    # 3. Test Verify (Correct)
    print("\n[TEST] 3. POST /academy/verify (Correct Solution)")
    if solution['type'] == 'sequence':
        correct_moves = solution['data'] 
        
        try:
            payload = {"puzzleId": first_id, "moves": correct_moves}
            res = requests.post(f"{BASE_URL}/academy/verify", json=payload)
            result = res.json()
            
            if result.get('success'):
                print(f"SUCCESS: Server confirmed correct moves.")
            else:
                print(f"FAILED: Server rejected correct moves! Msg: {result.get('message')}")
        except Exception as e:
            print(f"FAILED: {e}")

    # 4. Test Verify (Incorrect)
    print("\n[TEST] 4. POST /academy/verify (Incorrect Solution)")
    try:
        bad_moves = ["2S"] # Playing a 2 of Spades (likely wrong for any puzzle)
        payload = {"puzzleId": first_id, "moves": bad_moves}
        res = requests.post(f"{BASE_URL}/academy/verify", json=payload)
        result = res.json()
        
        if not result.get('success'):
            print(f"SUCCESS: Server correctly rejected wrong moves. Msg: {result.get('message')}")
        else:
            print(f"FAILED: Server accepted wrong moves!")
    except Exception as e:
        print(f"FAILED: {e}")
        
    print("\nDone.")

if __name__ == "__main__":
    test_academy_api()

```

### FILE: scripts\test_archival.py
```py
import sys
import os
import time

# Setup Path
sys.path.append(os.getcwd())

from game_engine.logic.game import Game
# Import models to register tables!
import server.models 
from server.common import db
from server.services.archiver import archive_match

def test_archival():
    print("--- Testing Match Archival ---")
    
    # 1. Create Game
    game = Game("test_archive_" + str(int(time.time())))
    game.add_player("p1", "Player 1")
    game.add_player("p2", "Player 2")
    game.add_player("p3", "Player 3")
    game.add_player("p4", "Player 4")
    game.start_game()
    
    print(f"Game Created: {game.room_id}")
    
    # 2. Force Win Condition & Inject Fake History
    game.match_scores['us'] = 152
    game.match_scores['them'] = 100
    
    # Inject dummy history with Complex Objects (Card) to test Serializer
    from game_engine.models.card import Card
    game.full_match_history = [{
        'round': 1, 
        'scores': {'us': 20, 'them': 0},
        'tricks': [{'cards': [Card('S', '7'), Card('H', 'K')]}], # Complex Objects!
        'initialHands': {} 
    }]
    
    # 3. Trigger End Round (which should check condition and archive)
    print("Triggering End Round (Win)...")
    game.end_round(skip_scoring=True) # Skip scoring engine, just process state
    
    if game.phase != "GAMEOVER":
        print(f"‚ùå Game Phase is {game.phase}, expected GAMEOVER")
        return
        
    print("‚úÖ Game Phase is GAMEOVER")
    
    # 4. Check DB
    print("Checking Database...")
    record = db.match_archive(game_id=game.room_id)
    
    if record:
        print(f"‚úÖ Archive Found! ID: {record.id}")
        print(f"   Scores: Us={record.final_score_us}, Them={record.final_score_them}")
        print(f"   History Length: {len(str(record.history_json))} chars")
        # cleanup
        db(db.match_archive.id == record.id).delete()
        db.commit()
        print("   (Cleaned up test record)")
    else:
        print("‚ùå Archive NOT Found in DB")
        
    print("Checking Log File...")
    found_event = False
    with open("logs/server_manual.log", "r", encoding="utf-8") as f:
        for line in f:
            if "MATCH_ARCHIVED" in line and game.room_id in line:
                if "history_stats" in line:
                    found_event = True
                    print(f"‚úÖ Found Structured Log Event: {line.strip()[:100]}...")
                    break
    
    if not found_event:
        print("‚ùå MATCH_ARCHIVED Log Event NOT Found")

if __name__ == "__main__":
    test_archival()

```

### FILE: scripts\test_bot_qayd.py
```py
import sys
import os
import logging

# Setup path
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(current_dir)
sys.path.insert(0, project_root)

from ai_worker.bot_context import BotContext
from ai_worker.referee_observer import RefereeObserver

# Setup Logger
logging.basicConfig(level=logging.INFO)

def test_qayd_trigger():
    print("=== Testing Bot Qayd Trigger ===")
    
    # 1. Mock Game State with Illegal Move
    mock_state = {
        'gameId': 'test_qayd_1',
        'phase': 'PLAYING',
        'gameMode': 'SUN',
        'trumpSuit': 'H',
        'tableCards': [
            {
                'card': {'suit': 'H', 'rank': 'A'},
                'playedBy': 'Right',
                'metadata': {'is_illegal': True, 'violation': 'REVOKE'}
            }
        ],
        'players': [
            {'position': 'Bottom', 'name': 'Bot', 'hand': [], 'team': 'us'}, # Me
            {'position': 'Right', 'name': 'Opponent', 'hand': [], 'team': 'them'},
            {'position': 'Top', 'name': 'Partner', 'hand': [], 'team': 'us'},
            {'position': 'Left', 'name': 'Opponent', 'hand': [], 'team': 'them'},
        ],
        'qaydState': {'active': False}, # Not yet active
        'sawaState': {'active': False}
    }
    
    # 2. Initialize Context & Referee
    ctx = BotContext(mock_state, 0) # Bottom Player
    referee = RefereeObserver()
    
    # 3. Check for Qayd
    print(f"Checking Qayd for player {ctx.position}...")
    decision = referee.check_qayd(ctx, mock_state)
    
    if decision and decision['action'] == 'QAYD_TRIGGER':
        print("‚úÖ SUCCESS: Bot triggered Qayd correctly!")
        print(f"   Reasoning: {decision.get('reasoning')}")
        return True
    else:
        print(f"‚ùå FAILURE: Bot did NOT trigger Qayd. Got: {decision}")
        return False

if __name__ == "__main__":
    test_qayd_trigger()

```

### FILE: scripts\test_bot_qayd_full.py
```py

import sys
import os
import logging
from unittest.mock import MagicMock

# Setup path
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(current_dir)
sys.path.insert(0, project_root)

from game_engine.logic.game import Game
from game_engine.models.card import Card
from game_engine.models.constants import GamePhase
from game_engine.models.player import Player

# Setup Logger
logging.basicConfig(level=logging.INFO)

def test_qayd_flow():
    print("=== Testing Full Qayd Flow (Engine + Serialization) ===")
    
    # 1. Initialize Game
    game = Game("test_room")
    game.phase = GamePhase.PLAYING.value
    game.game_mode = 'SUN'
    game.trump_suit = None
    
    # Setup Players
    # Player(id, name, index, game)
    p1 = Player("P1", "Me", 0, game)
    p2 = Player("P2", "Right", 1, game)
    p3 = Player("P3", "Partner", 2, game)
    p4 = Player("P4", "Left", 3, game)
    game.players = [p1, p2, p3, p4]
    
    # 2. Simulate Illegal Move
    # P2 plays illegal card
    card = Card('‚ô•', 'A')
    play = {
        'card': card,
        'playedBy': 'Right',
        'playerId': 'P2',
        'metadata': {'is_illegal': True, 'illegal_reason': 'REVOKE'}
    }
    game.table_cards.append(play)
    
    # 3. Trigger Qayd (via Auto-Play)
    # We need to Mock BotAgent to return QAYD_TRIGGER or trust the real one
    # Let's trust the real one since we verified it in simulation
    print("Asking Bot (P1) to analyze and trigger...")
    
    # Inject Game State into Bot logic (Mocking context if needed)
    # Actually auto_play_card calls bot_agent.get_decision(game.get_game_state(), index)
    
    # We need to ensure the Bot sees the illegal move.
    # The illegal move is in table_cards with metadata.
    
    try:
        from ai_worker.agent import bot_agent
        # Force Bot to see the move
        decision = bot_agent.get_decision(game.get_game_state(), 0)
        print(f"Bot Decision: {decision}")
        
        if decision['action'] == 'QAYD_TRIGGER':
             print("‚úÖ Bot correctly decided to Trigger Qayd.")
        else:
             print(f"‚ùå Bot FAIL. Decided: {decision}")
             return False
             
        # Execute via Game.auto_play_card logic manually (since auto_play_card does networking/time checks usually)
        # Or just call handle_qayd_trigger directly as the 'result' of the decision
        result = game.handle_qayd_trigger(0)
             
    except Exception as e:
        print(f"‚ùå Error during Bot execution: {e}")
        import traceback
        traceback.print_exc()
        return False

    if not result.get('success'):
        print(f"‚ùå FAILURE: propose_qayd failed: {result}")
        return False
        
    print(f"Result: {result}")
    qayd_state = result['qayd_state'] # key is qayd_state as per handle_qayd_trigger
    print(f"‚úÖ Qayd Proposed. State: {qayd_state}")
    
    # Verify Verdict Field
    if qayd_state.get('verdict') is None:
         # Verdict might be None until Confirmed
         pass
         
    # 4. Verify Serialization (Game.get_game_state)
    # This checks if Game correctly picks up TrickManager's state
    game_state = game.get_game_state()
    # Game.get_game_state uses camelCase 'qaydState' for frontend
    serialized_qayd = game_state.get('qaydState')
    
    if serialized_qayd and serialized_qayd.get('active'):
        print("‚úÖ Game.get_game_state() correctly serialized QaydState!")
    else:
        print(f"‚ùå FAILURE: Game state serialization issue. Got: {serialized_qayd}")
        return False
        
    # 5. Confirm Qayd (This generates verdict)
    print("Confirming Qayd...")
    game.trick_manager.confirm_qayd()
    
    if game.trick_manager.qayd_state['status'] == 'RESOLVED':
        print("‚úÖ Qayd Resolved.")
        print(f"Verdict: {game.trick_manager.qayd_state.get('verdict')}")
    else:
        print(f"‚ùå FAILURE: Qayd status not RESOLVED. Got: {game.trick_manager.qayd_state['status']}")
        return False

    print("=== ALL TESTS PASSED ===")
    return True

def test_last_trick_qayd_serialization():
    print("\n=== Testing Last Trick Serialization (Explicit Card.from_dict check) ===")
    game = Game("test_room_2")
    game.phase = GamePhase.PLAYING.value
    p1 = Player("P1", "Me", 0, game)
    game.players = [p1, Player("P2", "Right", 1, game), Player("P3", "Partner", 2, game), Player("P4", "Left", 3, game)]
    
    # Mock Last Trick with Illegal Move
    # Note: trick_history stores cards as dicts
    game.round_history = [{
        'cards': [
            {'suit': 'H', 'rank': '7', 'id': '7H', 'value': 0},
            {'suit': 'D', 'rank': 'K', 'id': 'KD', 'value': 4}
        ],
        'playedBy': ['Top', 'Right'],
        'metadata': [{}, {'is_illegal': True}]
    }]
    game.last_trick = {
        'cards': [{'suit': 'H', 'rank': '7'}, {'suit': 'D', 'rank': 'K'}],
        'metadata': [{}, {'is_illegal': True}]
    }
    
    # Trigger Qayd
    print("Triggering Qayd on Last Trick...")
    result = game.handle_qayd_trigger(0)
    
    if result.get('success'):
        print(f"‚úÖ Last Trick Qayd Success! State: {result.get('qayd_state')}")
        return True
    else:
        print(f"‚ùå Failed to trigger Last Trick Qayd: {result}")
        return False

if __name__ == "__main__":
    if test_qayd_flow():
        test_last_trick_qayd_serialization()

```

### FILE: scripts\test_bot_qayd_multicard.py
```py
import sys
import os
import logging

# Setup path
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(current_dir)
sys.path.insert(0, project_root)

from ai_worker.bot_context import BotContext
from ai_worker.referee_observer import RefereeObserver

# Setup Logger
logging.basicConfig(level=logging.INFO)

def test_qayd_multicard():
    print("=== Testing Bot Qayd Trigger (Buried in Table) ===")
    
    # 1. Mock Game State
    # Scenario: Right played illegal. Top played Legal. Left played Legal.
    # Now it's Bottom's (Bot) turn.
    mock_state = {
        'gameId': 'test_qayd_buried',
        'phase': 'PLAYING',
        'gameMode': 'SUN',
        'trumpSuit': 'H',
        'tableCards': [
            {
                'card': {'suit': 'H', 'rank': 'A'},
                'playedBy': 'Right',
                'metadata': {'is_illegal': True, 'violation': 'REVOKE'} # BURRIED CRIME
            },
            {
                'card': {'suit': 'H', 'rank': '9'},
                'playedBy': 'Top',
                'metadata': {} # Legal
            },
            {
                'card': {'suit': 'H', 'rank': '7'},
                'playedBy': 'Left',
                'metadata': {} # Legal
            }
        ],
        'players': [
            {'position': 'Bottom', 'name': 'Bot', 'hand': [], 'team': 'us'}, # Me
            {'position': 'Right', 'name': 'Opponent', 'hand': [], 'team': 'them'},
            {'position': 'Top', 'name': 'Partner', 'hand': [], 'team': 'us'},
            {'position': 'Left', 'name': 'Opponent', 'hand': [], 'team': 'them'},
        ],
        'qaydState': {'active': False}, 
        'sawaState': {'active': False}
    }
    
    # 2. Initialize Context & Referee
    ctx = BotContext(mock_state, 0) # Bottom Player
    referee = RefereeObserver()
    
    # 3. Check for Qayd
    print(f"Checking Qayd for player {ctx.position} with Buried Illegal Move at index 0...")
    decision = referee.check_qayd(ctx, mock_state)
    
    if decision and decision['action'] == 'QAYD_TRIGGER':
        print("‚úÖ SUCCESS: Bot triggered Qayd on BURIED card!")
        print(f"   Reasoning: {decision.get('reasoning')}")
        return True
    else:
        print(f"‚ùå FAILURE: Bot missed the buried crime. Got: {decision}")
        return False

if __name__ == "__main__":
    test_qayd_multicard()

```

### FILE: scripts\test_bot_qayd_trick_end.py
```py
import sys
import os
import logging

# Setup path
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(current_dir)
sys.path.insert(0, project_root)

from ai_worker.bot_context import BotContext
from ai_worker.referee_observer import RefereeObserver

# Setup Logger
logging.basicConfig(level=logging.INFO)

def test_qayd_trick_end():
    print("=== Testing Bot Qayd Trigger (End of Trick/Empty Table) ===")
    
    # 1. Mock Game State where table is EMPTY (resolved)
    # But lastTrick contains the illegal move
    mock_state = {
        'gameId': 'test_qayd_lat_trick',
        'phase': 'PLAYING',
        'gameMode': 'SUN',
        'trumpSuit': 'H',
        'tableCards': [], # EMPTY!
        'lastTrick': {
             'cards': [
                 {'suit': 'D', 'rank': 'J'},
                 {'suit': 'D', 'rank': '9'},
                 {'suit': 'D', 'rank': 'A'},
                 {'suit': 'S', 'rank': '7'} # Illegal move?
             ],
             'metadata': [
                 None,
                 None,
                 None,
                 {'is_illegal': True, 'violation': 'REVOKE'} # The Smoking Gun
             ],
             'winner': 'Right'
        },
        'players': [
            {'position': 'Bottom', 'name': 'Bot', 'hand': [], 'team': 'us'}, # Me
            {'position': 'Right', 'name': 'Opponent', 'hand': [], 'team': 'them'},
            {'position': 'Top', 'name': 'Partner', 'hand': [], 'team': 'us'},
            {'position': 'Left', 'name': 'Opponent', 'hand': [], 'team': 'them'},
        ],
        'qaydState': {'active': False},
        'sawaState': {'active': False}
    }
    
    # 2. Initialize Context & Referee
    ctx = BotContext(mock_state, 0) # Bottom Player
    referee = RefereeObserver()
    
    # 3. Check for Qayd
    print(f"Checking Qayd for player {ctx.position} with EMPTY table but suspicious Last Trick...")
    decision = referee.check_qayd(ctx, mock_state)
    
    if decision and decision['action'] == 'QAYD_TRIGGER':
        print("‚úÖ SUCCESS: Bot triggered Qayd from LAST TRICK history!")
        print(f"   Reasoning: {decision.get('reasoning')}")
        return True
    else:
        print(f"‚ùå FAILURE: Bot missed the crime in the past trick. Got: {decision}")
        return False

if __name__ == "__main__":
    test_qayd_trick_end()

```

### FILE: scripts\test_db_persist.py
```py
import sys
import os
import json
import datetime

# Add project root to path
sys.path.append(os.getcwd())

# Setup DB
try:
    from server.common import db
    import server.models # Ensure tables are defined
    
    print("DB Connected.")
    print(f"Tables: {db.tables}")
    
    if 'match_archive' not in db.tables:
        print("ERROR: match_archive table NOT found!")
        sys.exit(1)
        
    print("Found match_archive. Attempting insert...")
    
    dummy_id = f"test_{int(datetime.datetime.now().timestamp())}"
    dummy_history = [{"test": "data"}]
    
    ret = db.match_archive.insert(
        game_id=dummy_id,
        user_email='test_script',
        history_json=json.dumps(dummy_history),
        final_score_us=100,
        final_score_them=50
    )
    db.commit()
    print(f"Insert Successful. ID: {ret}")
    
    # Verify Read
    row = db(db.match_archive.game_id == dummy_id).select().first()
    if row:
        print("Read Verification Successful.")
        print(row.as_dict())
    else:
        print("ERROR: Read Verification Failed!")

except Exception as e:
    print(f"CRITICAL ERROR: {e}")
    import traceback
    traceback.print_exc()

```

### FILE: scripts\test_hand_sync.py
```py

import sys
import os
import logging

# Add project root to path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from game_engine.logic.game import Game, GamePhase
from game_engine.models.card import Card
from game_engine.models.player import Player

# Setup Logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("HandSyncTest")

def test_hand_sync():
    logger.info("=== STARTING HAND SYNC TEST ===")
    
    # 1. Initialize Game
    game = Game("test_room")
    p1 = game.add_player("p1", "Player 1")
    game.add_player("p2", "Player 2")
    game.add_player("p3", "Player 3")
    game.add_player("p4", "Player 4")
    
    # Mock Phase
    game.phase = GamePhase.PLAYING.value
    game.current_turn = 0 # Player 1's turn
    
    # 2. Mock Hand for Player 1
    # Server Hand: [7H, AS, KD]
    c1 = Card('‚ô•', '7', '7‚ô•')
    c2 = Card('‚ô†', 'A', 'A‚ô†')
    c3 = Card('‚ô¶', 'K', 'K‚ô¶')
    p1.hand = [c1, c2, c3]
    
    logger.info(f"Initial Server Hand: {[c.id for c in p1.hand]}")
    
    # --- TEST 1: Normal Play (Aligned) ---
    logger.info("\n--- Test 1: Normal Play (7H at Index 0) ---")
    # Client plays 7H at index 0
    res = game.play_card(0, 0, metadata={'cardId': '7‚ô•'})
    
    if res.get('success'):
        logger.info("PASS: Normal play successful.")
    else:
        logger.error(f"FAIL: Normal play failed: {res}")
        return

    # Verify Hand: [AS, KD]
    current_ids = [c.id for c in p1.hand]
    logger.info(f"Hand after T1: {current_ids}")
    if current_ids == ['A‚ô†', 'K‚ô¶']:
        logger.info("PASS: Hand state correct.")
    else:
         logger.error("FAIL: Hand state incorrect.")

    # --- TEST 2: Index Drift / Desync ---
    logger.info("\n--- Test 2: Index Drift (Play K‚ô¶) ---")
    # Scenario: Client thinks K‚ô¶ is at index 0 (maybe it sorted differently), but Server has it at index 1.
    # Server Hand: [A‚ô† (0), K‚ô¶ (1)]
    # Client sends: index=0 (pointing to A‚ô†), but cardId='K‚ô¶'
    
    # Note: reset turn logic for test
    game.current_turn = 0 
    
    res = game.play_card(0, 0, metadata={'cardId': 'K‚ô¶'})
    
    if res.get('success'):
        # Verify that K‚ô¶ was played, NOT A‚ô†
        played_card = game.table_cards[-1]['card']
        logger.info(f"Played Card: {played_card.id}")
        
        if played_card.id == 'K‚ô¶':
            logger.info("PASS: Server corrected index and played K‚ô¶.")
        else:
            logger.error(f"FAIL: Server played wrong card {played_card.id} (Expected K‚ô¶).")
    else:
        logger.error(f"FAIL: Desync play failed: {res}")

    # Verify Hand: [A‚ô†]
    current_ids = [c.id for c in p1.hand]
    logger.info(f"Hand after T2: {current_ids}")
    if current_ids == ['A‚ô†']:
        logger.info("PASS: Hand state correct.")

    # --- TEST 3: Ghost Card ---
    logger.info("\n--- Test 3: Ghost Card (Card Not In Hand) ---")
    game.current_turn = 0
    # Try to play Q‚ô£ (ID: Q‚ô£)
    res = game.play_card(0, 0, metadata={'cardId': 'Q‚ô£'})
    
    if res.get('error') == "Card Not Found in Hand (ID Mismatch)":
        logger.info("PASS: Server rejected ghost card.")
    else:
        logger.error(f"FAIL: Server did not reject ghost card correctly. Result: {res}")

if __name__ == "__main__":
    test_hand_sync()

```

### FILE: scripts\test_rate_limiter.py
```py
import time
import sys
import os

# Add project root to path
sys.path.append(os.getcwd())

from ai_worker.rate_limiter import TokenBucketRateLimiter

def test_rate_limiter():
    print("=== Testing TokenBucketRateLimiter ===")
    
    # Configure: 5 burst, 60 RPM (1 per sec) for faster testing
    # Actually let's use the production settings to be sure: 10 burst, 10 RPM
    limiter = TokenBucketRateLimiter(capacity=10, refill_rate_per_minute=10)
    
    print(f"Initial Tokens: {limiter.get_status()['tokens']}")
    
    # 1. Burst Test
    print("\n--- Burst Test (Expect 10 successes) ---")
    successes = 0
    start = time.time()
    for i in range(15):
        if limiter.acquire(blocking=False):
            print(f"Request {i+1}: Allowed")
            successes += 1
        else:
            print(f"Request {i+1}: Throttled")
            
    print(f"Total Successes: {successes}")
    if successes == 10:
        print("‚úÖ Burst capacity verified (10).")
    else:
        print(f"‚ùå Burst failed. Expected 10, got {successes}.")
        
    # 2. Refill Test
    print("\n--- Refill Test (Wait 6s for 1 token) ---")
    time.sleep(6.1)
    
    if limiter.acquire(blocking=False):
        print("‚úÖ Refill verified (Acquired 1 token after wait).")
    else:
        print("‚ùå Refill failed. Still throttled.")
        
    status = limiter.get_status()
    print(f"\nFinal Status: {status}")

if __name__ == "__main__":
    test_rate_limiter()

```

### FILE: scripts\test_screenshot.py
```py
import requests
import os

# Path to the user's uploaded image (absolute path from metadata)
IMAGE_PATH = r"C:/Users/MiEXCITE/.gemini/antigravity/brain/4ddca2fa-5f9f-4928-8efb-e5f9e2e7ef89/uploaded_image_1768685881050.png"
URL = "http://127.0.0.1:3005/react-py4web/analyze_screenshot"

def test_analyze():
    print(f"Testing {URL} with {IMAGE_PATH}")
    if not os.path.exists(IMAGE_PATH):
        print("Image file not found!")
        return

    try:
        with open(IMAGE_PATH, 'rb') as f:
            files = {'screenshot': ('test.png', f, 'image/png')}
            response = requests.post(URL, files=files)
        
        print(f"Status: {response.status_code}")
        print(f"Response: {response.text}")
    except Exception as e:
        print(f"Request failed: {e}")

if __name__ == "__main__":
    test_analyze()

```

### FILE: scripts\test_sherlock_trigger.py
```py

import sys
import os
import logging
import unittest
from unittest.mock import MagicMock

# Add project root
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from ai_worker.agent import bot_agent

class TestSherlockTrigger(unittest.TestCase):
    def test_sherlock_triggers_on_illegal_move(self):
        # 1. Mock Game State
        game_state = {
            'gameId': 'test_sherlock',
            'phase': 'PLAYING',
            'tableCards': [
                 # Normal Card
                 {'card': {'suit': 'H', 'rank': '7'}, 'playedBy': 'Top', 'metadata': {}},
                 # Illegal Card!
                 {'card': {'suit': 'D', 'rank': 'K'}, 'playedBy': 'Right', 'metadata': {'is_illegal': True}}
            ],
            'players': [
                {'name': 'Me', 'index': 0, 'hand': []},
                {'name': 'Right', 'index': 1, 'hand': []},
                {'name': 'Partner', 'index': 2, 'hand': []},
                {'name': 'Left', 'index': 3, 'hand': []},
            ],
            'qaydState': {'active': False}
        }
        
        # 2. Call Agent
        decision = bot_agent.get_decision(game_state, 0)
        
        # 3. Verify
        print(f"Decision: {decision}")
        self.assertEqual(decision.get('action'), 'QAYD_TRIGGER')
        
    def test_sherlock_ignores_legal_moves(self):
        # 1. Mock Game State (Clean)
        game_state = {
            'gameId': 'test_item',
            'phase': 'PLAYING',
            'tableCards': [
                 {'card': {'suit': 'H', 'rank': '7'}, 'playedBy': 'Top', 'metadata': {}}
            ],
            'players': [{'name': 'Me', 'index': 0, 'hand': []}],
            'qaydState': {'active': False}
        }
        
        # 2. Call Agent
        decision = bot_agent.get_decision(game_state, 0)
        
        # 3. Verify (Should be just a move or pass, NOT QAYD_TRIGGER)
        print(f"Decision: {decision}")
        self.assertNotEqual(decision.get('action'), 'QAYD_TRIGGER')

    def test_sherlock_triggers_on_last_trick_illegal(self):
        # 1. Mock Game State (Table Empty, Last Trick has Illegal Move)
        game_state = {
            'gameId': 'test_sherlock_last_trick',
            'phase': 'PLAYING',
            'tableCards': [], # Empty!
            'lastTrick': {
                'metadata': [
                    {},
                    {},
                    {},
                    {'is_illegal': True} # The 4th card was BAD
                ]
            },
            'players': [
                {'name': 'Me', 'index': 0, 'hand': []},
                {'name': 'Right', 'index': 1, 'hand': []},
                {'name': 'Partner', 'index': 2, 'hand': []},
                {'name': 'Left', 'index': 3, 'hand': []},
            ],
            'qaydState': {'active': False}
        }
        
        # 2. Call Agent
        decision = bot_agent.get_decision(game_state, 0)
        
        # 3. Verify
        print(f"Decision (Last Trick): {decision}")
        self.assertEqual(decision.get('action'), 'QAYD_TRIGGER')

if __name__ == "__main__":
    unittest.main()

```

### FILE: scripts\test_validation_logic.py
```py

import sys
import os
import logging

# Setup path
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(current_dir)
sys.path.insert(0, project_root)

# Mock Logger
logging.basicConfig(level=logging.INFO)

from game_engine.models.card import Card
from game_engine.logic.validation import is_move_legal

def test_validation():
    print("=== Testing Validation Logic ===")
    
    # Scenario: Revoke (Lead Clubs, Have Clubs, Play Hearts)
    
    # Lead Card: 7 of Clubs
    lead_play = {'card': Card('‚ô£', '7'), 'playedBy': 'Top'}
    table_cards = [lead_play]
    
    # Hand: [9 Clubs, Ace Hearts]
    c_clubs = Card('‚ô£', '9')
    c_hearts = Card('‚ô•', 'A')
    hand = [c_clubs, c_hearts]
    
    # Test 1: Play Clubs (Follow Suit) -> Should be True
    print("\nTest 1: Play Clubs (Follow Suit)")
    res1 = is_move_legal(
        card=c_clubs,
        hand=hand,
        table_cards=table_cards,
        game_mode='SUN',
        trump_suit=None,
        my_team='us',
        players_team_map={'Top': 'them', 'Bottom': 'us'}
    )
    print(f"Result: {res1} (Expected: True)")
    
    # Test 2: Play Hearts (Revoke) -> Should be False
    print("\nTest 2: Play Hearts (Revoke - Have Suit)")
    res2 = is_move_legal(
        card=c_hearts,
        hand=hand,
        table_cards=table_cards,
        game_mode='SUN',
        trump_suit=None,
        my_team='us',
        players_team_map={'Top': 'them', 'Bottom': 'us'}
    )
    print(f"Result: {res2} (Expected: False)")
    
    if res2 is False:
        print("‚úÖ SUCCESS: Validation correctly identified Revoke.")
    else:
        print("‚ùå FAILURE: Validation incorrectly allowed Revoke.")

if __name__ == "__main__":
    test_validation()

```

### FILE: scripts\test_visionary.py
```py

import os
import sys

# Ensure project root is in path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from game_engine.visionary.visionary import VisionaryProcessor, Profile
import cv2

def test_roi_calibration(image_path=None):
    # 1. Define Paths
    if image_path:
        artifact_path = image_path
    else:
        # We will look for an artifact image in the project root or use a placeholder
        artifact_path = "C:/Users/MiEXCITE/.gemini/antigravity/brain/f3623068-56ea-430b-ae0d-82cba6a7c96d/uploaded_media_0_1769783663643.png"
    
    output_path = "roi_calibration_result.png"

    # 2. Initialize Processor
    print("Initializing Visionary Processor...")
    processor = VisionaryProcessor(profile_name=Profile.EXTERNAL_APP_WEB)

    # 3. Load Image
    print(f"Loading image from {artifact_path}...")
    image = processor.load_image(artifact_path)

    if image is None:
        print("Failed to load image. Please verify the path.")
        # Create a dummy image for testing logic
        print("Creating dummy black image for test...")
        image = cv2.imread("uploaded_media_0.png") # Try local relative
        if image is None:
             import numpy as np
             image = np.zeros((1080, 1920, 3), dtype=np.uint8)

    # 4. Extract and Draw
    print("Extracting ROIs and creating debug visual...")
    processor.debug_show_rois(image, save_path=output_path)
    
    # 5. Test Recognition
    from game_engine.visionary.visionary import CardRecognizer
    print("Testing Card Recognition...")
    recognizer = CardRecognizer(model_path="models/yolo_v8n_baloot.pt")
    
    # Test on a specific ROI if available, or just the whole image for now to see what it finds
    # In reality, we should pass the 'floor' or 'hand' ROI.
    rois = processor.extract_rois(image)
    
    if "floor" in rois:
        print("Predicting on Floor ROI...")
        cards = recognizer.predict(rois["floor"])
        print(f"Floor Cards: {cards}")
        
    if "hand_card_1" in rois:
         print("Predicting on Hand ROI...")
         cards = recognizer.predict(rois["hand_card_1"])
         print(f"Hand Cards: {cards}")

    print("Test Complete.")

if __name__ == "__main__":
    # Use a real image from the dataset we just created
    import glob
    images = glob.glob("dataset/images/train/*.jpg")
    if images:
        test_img = images[0]
        print(f"Using test image: {test_img}")
        
        processor = VisionaryProcessor(profile_name=Profile.EXTERNAL_APP_WEB)
        img = processor.load_image(test_img)
        processor.debug_show_rois(img)
        
        # Run recognition test
        test_roi_calibration(test_img) 
    else:
        test_roi_calibration()

```

### FILE: scripts\train_brain.py
```py
import json
import os
import redis
import hashlib
import time

# Settings
import sys
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
try:
    from server.settings import REDIS_URL
except ImportError:
    print("Warning: Could not import settings. Using default 127.0.0.1")
    REDIS_URL = "redis://127.0.0.1:6379/0"

def train_brain(mistakes_file):
    """
    Reads mistakes JSON and populates Redis with Correct Moves.
    """
    if not os.path.exists(mistakes_file):
        print(f"Error: File {mistakes_file} not found.")
        return

    print(f"Connecting to Redis at {REDIS_URL}...")
    try:
        r = redis.from_url(REDIS_URL, decode_responses=True)
    except Exception as e:
        print(f"Redis Connection Failed: {e}")
        return

    print(f"Loading mistakes from {mistakes_file}...")
    with open(mistakes_file, 'r', encoding='utf-8') as f:
        data = json.load(f)

    count = 0
    for match in data:
        analysis = match.get('analysis', {})
        moments = analysis.get('moments', [])
        
        for m in moments:
            correct_move = m.get('correct_move')
            context_hash = m.get('context_hash') # In real flow, we'd need to re-compute this from state
            
            if correct_move and context_hash:
                # Store in Redis
                key = f"brain:correct:{context_hash}"
                value = json.dumps(correct_move)
                
                r.set(key, value)
                print(f"Learned: {key} -> {value}")
                count += 1
            else:
                # If hash missing, we normally re-compute it if state data existed. 
                # For manual test, we skip.
                pass

    print(f"Training Complete. Learned {count} new moves.")

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--file", default="candidates/mistakes_manual.json", help="Path to mistakes JSON")
    args = parser.parse_args()
    
    train_brain(args.file)

```

### FILE: scripts\train_mind.py
```py

# Train Theory of Mind

import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
import sys
from pathlib import Path

# Add path
sys.path.append(str(Path(__file__).parent.parent))
from ai_worker.learning.mind_reader import MindReaderNet

class MindDataset(Dataset):
    def __init__(self, path):
        self.data = torch.load(path)
        
    def __len__(self):
        return len(self.data)
        
    def __getitem__(self, idx):
        # x: [Seq], y: [4, 32]
        x, y = self.data[idx]
        return x, y

def collate_fn(batch):
    # Pad sequences to max length in batch
    xs, ys = zip(*batch)
    max_len = max([len(x) for x in xs])
    
    padded_xs = []
    masks = []
    
    for x in xs:
        # 0 is padding token
        pad_len = max_len - len(x)
        padded = torch.cat([x, torch.zeros(pad_len, dtype=torch.long)])
        padded_xs.append(padded)
        
        # Mask: True for Padding position? PyTorch Transformer src_key_padding_mask
        # shape (N, S), True where padding
        mask = torch.zeros(max_len, dtype=torch.bool)
        if pad_len > 0:
            mask[-pad_len:] = True
        masks.append(mask)
        
    return torch.stack(padded_xs), torch.stack(masks), torch.stack(ys)

def train():
    print("Initializing Training...")
    dataset = MindDataset("ai_worker/data/mind_data.pt")
    loader = DataLoader(dataset, batch_size=16, shuffle=True, collate_fn=collate_fn)
    
    model = MindReaderNet()
    optimizer = optim.Adam(model.parameters(), lr=0.001)
    criterion = nn.BCEWithLogitsLoss()
    
    epochs = 20
    model.train()
    
    for epoch in range(epochs):
        total_loss = 0
        correct_cards = 0
        total_predictions = 0
        
        for x, mask, y in loader:
            optimizer.zero_grad()
            
            # Forward
            # Viewpoint Assumption: Model is always 'Bottom' (Player 0) viewpoint in this basic setup
            # But the dataset contains perspectives for everyone. 
            # In input sequence, we need to know WHO the generic "Left/Right" refers to.
            # Limitation: The simplified generator didn't rotate the perspective.
            # Assuming we are predicting absolute hands for P1(Right), P2(Top), P3(Left) from P0 frame.
            
            pred_l, pred_p, pred_r = model(x, mask)
            
            # Y shape: [Batch, 4, 32] (0=Self, 1=Right, 2=Partner, 3=Left)
            # Targets
            target_r = y[:, 1, :]
            target_p = y[:, 2, :]
            target_l = y[:, 3, :]
            
            loss_r = criterion(pred_r, target_r)
            loss_p = criterion(pred_p, target_p)
            loss_l = criterion(pred_l, target_l)
            
            loss = loss_r + loss_p + loss_l
            loss.backward()
            optimizer.step()
            
            total_loss += loss.item()
            
            # Accuracy metric (Threshold 0.5)
            with torch.no_grad():
                preds = torch.cat([pred_r, pred_p, pred_l])
                targs = torch.cat([target_r, target_p, target_l])
                
                guess = (torch.sigmoid(preds) > 0.5).float()
                correct_cards += (guess == targs).sum().item()
                total_predictions += targs.numel()
                
        avg_loss = total_loss / len(loader)
        acc = (correct_cards / total_predictions) * 100
        print(f"Epoch {epoch+1}/{epochs} | Loss: {avg_loss:.4f} | Card Acc: {acc:.2f}%")
        
    # Save
    torch.save(model.state_dict(), "ai_worker/models/mind_reader_v1.pth")
    print("Model saved to ai_worker/models/mind_reader_v1.pth")

if __name__ == "__main__":
    train()

```

### FILE: scripts\train_visionary_yolo.py
```py
import os
import yaml
from ultralytics import YOLO
import argparse

def setup_dataset_structure(base_dir="dataset"):
    """
    Creates the necessary directory structure for YOLO training.
    dataset/
      images/
        train/
        val/
      labels/
        train/
        val/
      data.yaml
    """
    dirs = [
        "images/train", "images/val",
        "labels/train", "labels/val"
    ]
    
    for d in dirs:
        path = os.path.join(base_dir, d)
        os.makedirs(path, exist_ok=True)
        print(f"Verified directory: {path}")

def create_data_yaml(base_dir="dataset"):
    """
    Generates the data.yaml file defining the 53 classes for Baloot cards.
    """
    # 52 Cards + Back
    ranks = ['A', 'K', 'Q', 'J', '10', '9', '8', '7', '6', '5', '4', '3', '2']
    suits = ['S', 'H', 'D', 'C'] # Spades, Hearts, Diamonds, Clubs
    
    classes = {}
    idx = 0
    
    # Generate standard deck
    for s in suits:
        for r in ranks:
            classes[idx] = f"{r}{s}"
            idx += 1
            
    # Add back of card
    classes[idx] = "CARD_BACK"
    
    data = {
        'path': os.path.abspath(base_dir),
        'train': 'images/train',
        'val': 'images/val',
        'names': classes
    }
    
    yaml_path = os.path.join(base_dir, "data.yaml")
    with open(yaml_path, 'w') as f:
        yaml.dump(data, f, sort_keys=False)
        
    print(f"Created data configuration: {yaml_path}")
    return yaml_path

def train_model(data_yaml, epochs=50, imgsz=640):
    print(f"Starting Training with {data_yaml}...")
    # Load a model
    model = YOLO("yolov8n.pt")  # load a pretrained model (nano version for speed)

    # Train the model
    results = model.train(
        data=data_yaml, 
        epochs=epochs, 
        imgsz=imgsz,
        plots=True,
        batch=16,
        name='baloot_clash'
    )
    print("Training Complete!")
    print(f"Best model saved at: {results.save_dir}/weights/best.pt")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Visionary Studio YOLO Trainer")
    parser.add_argument("--setup-only", action="store_true", help="Only create folder structure and yaml")
    parser.add_argument("--epochs", type=int, default=50, help="Number of training epochs")
    
    args = parser.parse_args()
    
    setup_dataset_structure()
    yaml_path = os.path.join("dataset", "data.yaml")
    if not os.path.exists(yaml_path) or args.setup_only:
        yaml_path = create_data_yaml()
    else:
        print(f"Using existing config: {yaml_path}")
    
    if not args.setup_only:
        train_model(yaml_path, epochs=args.epochs)

```

### FILE: scripts\verify_hybrid_performance.py
```py
import logging
import sys
import os
import random
import time

# Add project root to path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from game_engine.logic.game import Game
from game_engine.models.constants import GamePhase
from game_engine.models.card import Card
from ai_worker.agent import bot_agent
from ai_worker.bot_context import BotContext

# Configure Logging
# Force reset of logging handlers
for handler in logging.root.handlers[:]:
    logging.root.removeHandler(handler)

logging.basicConfig(
    filename='hybrid_verification.log',
    filemode='w',
    level=logging.INFO,
    format='%(asctime)s - %(message)s'
)

# Console handler
console = logging.StreamHandler()
console.setLevel(logging.INFO)
logging.getLogger('').addHandler(console)

def run_tournament(num_games=20):
    print(f"üèÜ STARTING HYBRID MCTS vs HEURISTIC TOURNAMENT ({num_games} Games) üèÜ")
    print("Format: Team US (P0, P2) = Hybrid MCTS | Team THEM (P1, P3) = Heuristic")
    
    wins = {'hybrid': 0, 'heuristic': 0}
    start_time = time.time()
    
    for i in range(num_games):
        game_id = f"hybrid_tourney_{int(time.time())}_{i}"
        game = Game(game_id)
        
        # Setup Players
        game.add_player("p0", "Hybrid_Bot_1")
        game.add_player("p1", "Heuristic_Bot_1")
        game.add_player("p2", "Hybrid_Bot_2")
        game.add_player("p3", "Heuristic_Bot_2")
        
        if not game.start_game():
            continue
            
        print(f"Game {i+1}/{num_games} Starting... Floor: {game.floor_card}")
        
        consecutive_passes = 0
        moves_count = 0
        
        while game.phase != GamePhase.FINISHED.value:
            current_idx = game.current_turn
            current_p = game.players[current_idx]
            
            # Construct State with Strategy Config
            game_state = {
                "gameId": game_id,
                "gameMode": game.game_mode,
                "trumpSuit": game.trump_suit,
                "doublingLevel": game.doubling_level,
                "dealerIndex": game.dealer_index,
                "currentTurn": current_idx,
                "phase": game.phase,
                "players": [
                    {
                        "name": p.name,
                        "hand": [c.to_dict() for c in p.hand] if p.index == current_idx else [], 
                        "team": p.team,
                        "position": p.position,
                        "projectedScore": 0,
                        # META-CONFIG: Strategy Injection
                        "strategy": "hybrid" if p.index in [0, 2] else "heuristic"
                    }
                    for p in game.players
                ],
                "tableCards": [],
                "roundHistory": game.round_history,
                "matchScores": game.match_scores,
                "bid": game.bid if game.bid else None
            }
            
            # Serialize Table
            serialized_table = []
            for tc in game.table_cards:
                 serialized_table.append({
                      'card': tc['card'].to_dict(),
                      'playedBy': tc['playedBy'],
                      'metadata': tc.get('metadata', {})
                 })
            game_state['tableCards'] = serialized_table
            
            # Get Decision
            try:
                decision = bot_agent.get_decision(game_state, current_idx)
            except Exception as e:
                logging.error(f"Agent Error: {e}")
                decision = {}

            # Execute
            action = decision.get('action')
            res = None
            
            if action == "PASS":
                if game.phase == "BIDDING":
                    consecutive_passes += 1
                    if consecutive_passes >= 4:
                         res = game.handle_bid(current_idx, "SUN")
                         consecutive_passes = 0
                    else:
                         res = game.handle_bid(current_idx, "PASS")
                elif game.phase == "DOUBLING":
                     res = game.handle_bid(current_idx, "PASS")
                else: 
                     # Force Play Fallback
                     valid = [ix for ix, c in enumerate(current_p.hand) if game.is_valid_move(c, current_p.hand)]
                     if valid: res = game.play_card(current_idx, valid[0])

            elif action in ["BID", "SUN", "HOKUM"]:
                 consecutive_passes = 0
                 b_type = action if action != "BID" else decision.get('type', 'SUN')
                 res = game.handle_bid(current_idx, b_type, decision.get('suit'))
                 if not res or not res.get('success'):
                      # Fallback if illegal bid
                      res = game.handle_bid(current_idx, "PASS")

            elif action == "PLAY":
                 c_idx = decision.get('cardIndex')
                 if c_idx is not None and 0 <= c_idx < len(current_p.hand):
                      res = game.play_card(current_idx, c_idx)
                      if not res or not res.get('success'):
                           valid = [ix for ix, c in enumerate(current_p.hand) if game.is_valid_move(c, current_p.hand)]
                           if valid: res = game.play_card(current_idx, valid[0])
            
            moves_count += 1
            if moves_count > 600: 
                 print("Game Stuck! Breaking.")
                 break
            
        # Determine Winner
        us_score = game.match_scores['us']
        them_score = game.match_scores['them']
        
        winner = 'AMBIGUOUS'
        if us_score > them_score:
             wins['hybrid'] += 1
             winner = 'HYBRID'
        elif them_score > us_score:
             wins['heuristic'] += 1
             winner = 'HEURISTIC'
             
        res_msg = f"Game {i+1}: {winner} (Hybrid: {us_score}, Heuristic: {them_score})"
        print(f"{res_msg}")
        logging.info(res_msg)
        
    print(f"\n\nüèÅ TOURNAMENT COMPLETE üèÅ")
    print(f"Total Games: {num_games}")
    print(f"Hybrid Wins: {wins['hybrid']} ({wins['hybrid']/num_games*100:.1f}%)")
    print(f"Heuristic Wins: {wins['heuristic']} ({wins['heuristic']/num_games*100:.1f}%)")
    
    with open('hybrid_results.txt', 'w') as f:
         f.write(f"Hybrid: {wins['hybrid']}\nHeuristic: {wins['heuristic']}")

if __name__ == "__main__":
    count = int(sys.argv[1]) if len(sys.argv) > 1 else 20
    run_tournament(count)

```

### FILE: scripts\verify_neural_performance.py
```py
import sys
import os
import random
import time
import json
import logging

# Add parent directory to sys.path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from server.game_logic import Game, GamePhase
from ai_worker.agent import bot_agent

# Configure Logging
# Force reset of logging handlers (agent.py might have set them)
for handler in logging.root.handlers[:]:
    logging.root.removeHandler(handler)

logging.basicConfig(
    filename='verification_tournament.log',
    filemode='w',
    level=logging.INFO,
    format='%(asctime)s - %(message)s'
)

# Add console handler to see logs in stdout too
console = logging.StreamHandler()
console.setLevel(logging.INFO)
logging.getLogger('').addHandler(console)

def run_tournament(num_games=100):
    print(f"üèÜ STARTING NEURAL vs HEURISTIC TOURNAMENT ({num_games} Games) üèÜ")
    print("Format: Team US (P0, P2) = Neural Net | Team THEM (P1, P3) = Heuristic")
    
    wins = {'neural': 0, 'heuristic': 0}
    start_time = time.time()
    
    for i in range(num_games):
        game_id = f"tournament_{int(time.time())}_{i}"
        game = Game(game_id)
        
        # Setup Players
        # P0, P2: Neural
        # P1, P3: Heuristic
        game.add_player("p0", "Neural_Bot_1")
        game.add_player("p1", "Heuristic_Bot_1")
        game.add_player("p2", "Neural_Bot_2")
        game.add_player("p3", "Heuristic_Bot_2")
        
        if not game.start_game():
            continue
            
        print(f"Game {i+1}/{num_games} (Floor: {game.floor_card})...", end='\r')
        
        consecutive_passes = 0
        moves_count = 0
        
        while game.phase != GamePhase.FINISHED.value:
            current_idx = game.current_turn
            current_p = game.players[current_idx]
            
            # Construct State with Strategy Config
            game_state = {
                "gameId": game_id,
                "gameMode": game.game_mode,
                "trumpSuit": game.trump_suit,
                "doublingLevel": game.doubling_level,
                "dealerIndex": game.dealer_index,
                "currentTurn": current_idx,
                "phase": game.phase,
                "players": [
                    {
                        "name": p.name,
                        "hand": [c.to_dict() for c in p.hand] if p.index == current_idx else [], 
                        "team": p.team,
                        "position": p.position,
                        "projectedScore": 0,
                        # META-CONFIG: Inject Strategy Here
                        "strategy": "neural" if p.index in [0, 2] else "heuristic"
                    }
                    for p in game.players
                ],
                "tableCards": [],
                "roundHistory": game.round_history,
                "matchScores": game.match_scores,
                "bid": game.bid if game.bid else None
            }
            
            # Serialize Table
            serialized_table = []
            for tc in game.table_cards:
                 serialized_table.append({
                      'card': tc['card'].to_dict(),
                      'playedBy': tc['playedBy'],
                      'metadata': tc.get('metadata', {})
                 })
            game_state['tableCards'] = serialized_table
            
            # Get Decision
            try:
                decision = bot_agent.get_decision(game_state, current_idx)
            except Exception:
                decision = {}

            # Execute
            action = decision.get('action')
            res = None
            
            if action == "PASS":
                if game.phase == "BIDDING":
                    consecutive_passes += 1
                    if consecutive_passes >= 4:
                         # Force bid to unstick
                         res = game.handle_bid(current_idx, "SUN")
                         consecutive_passes = 0
                    else:
                         res = game.handle_bid(current_idx, "PASS")
                elif game.phase == "DOUBLING":
                     res = game.handle_bid(current_idx, "PASS")
                else: 
                     # Force Play
                     valid = [ix for ix, c in enumerate(current_p.hand) if game.is_valid_move(c, current_p.hand)]
                     if valid: res = game.play_card(current_idx, valid[0])

            elif action in ["BID", "SUN", "HOKUM"]:
                 consecutive_passes = 0
                 b_type = action if action != "BID" else decision.get('type', 'SUN')
                 res = game.handle_bid(current_idx, b_type, decision.get('suit'))
                 
                 if res and res.get('error'):
                      print(f"‚ùå BID ERROR: {res.get('error')} (Action: {b_type}, Suit: {decision.get('suit')})")
                      logging.error(f"BID ERROR: {res.get('error')}")
                      # Fallback to PASS to unstick
                      game.handle_bid(current_idx, "PASS")

                 
            elif action == "PLAY":
                 c_idx = decision.get('cardIndex')
                 if c_idx is not None and 0 <= c_idx < len(current_p.hand):
                      res = game.play_card(current_idx, c_idx)
                      if not res.get('success'):
                           # Fallback
                           valid = [ix for ix, c in enumerate(current_p.hand) if game.is_valid_move(c, current_p.hand)]
                           if valid: res = game.play_card(current_idx, valid[0])
            
            moves_count += 1
            if moves_count > 1000: break # Stuck
            
        # Determine Winner
        us_score = game.match_scores['us']
        them_score = game.match_scores['them']
        
        winner = 'AMBIGUOUS'
        if us_score > them_score:
             wins['neural'] += 1
             winner = 'NEURAL'
        elif them_score > us_score:
             wins['heuristic'] += 1
             winner = 'HEURISTIC'
             
        res_msg = f"Game {i+1}: {winner} (Neural: {us_score}, Heuristic: {them_score})"
        print(f"\n{res_msg}")
        logging.info(res_msg)
        
    print(f"\n\nüèÅ TOURNAMENT COMPLETE üèÅ")
    print(f"Total Games: {num_games}")
    print(f"Neural Wins: {wins['neural']} ({wins['neural']/num_games*100:.1f}%)")
    print(f"Heuristic Wins: {wins['heuristic']} ({wins['heuristic']/num_games*100:.1f}%)")
    
    with open('tournament_results.txt', 'w') as f:
         f.write(f"Neural: {wins['neural']}\nHeuristic: {wins['heuristic']}")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        run_tournament(int(sys.argv[1]))
    else:
        run_tournament(100)

```

### FILE: scripts\verify_ports_temp.py
```py
import socket
for port in [6379, 3005, 3000]:
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.settimeout(1)
        result = s.connect_ex(('localhost', port))
        print(f"Port {port}: {'Open' if result == 0 else 'Closed'}")

```

### FILE: scripts\verify_puzzles.py
```py
import os
import json
import glob
import sys

def verify_puzzles():
    # Adjust path to find server directory
    # Script is in scripts/, so up one level
    base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    puzzle_dir = os.path.join(base_dir, 'server', 'content', 'puzzles')
    
    print(f"Scanning {puzzle_dir}...")
    
    files = glob.glob(os.path.join(puzzle_dir, "*.json"))
    if not files:
        print("No puzzles found!")
        sys.exit(1)
        
    print(f"Found {len(files)} puzzles.")
    
    errors = 0
    for fpath in files:
        fname = os.path.basename(fpath)
        try:
            with open(fpath, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Check required fields
            required = ['id', 'title', 'description', 'difficulty', 'initial_state', 'solution']
            missing = [k for k in required if k not in data]
            
            if missing:
                print(f"[FAIL] {fname}: Missing fields {missing}")
                errors += 1
                continue
                
            # Check ID matches filename
            expected_id = fname.replace('.json', '')
            if data['id'] != expected_id:
                print(f"[WARN] {fname}: ID '{data['id']}' does not match filename '{expected_id}'")
            
            # Check Initial State
            state = data['initial_state']
            if 'players' not in state or 'currentTurn' not in state:
                print(f"[FAIL] {fname}: initial_state missing players/currentTurn")
                errors += 1
                continue
                
            print(f"[PASS] {fname} - {data['title']}")
            
        except json.JSONDecodeError:
            print(f"[FAIL] {fname}: Invalid JSON")
            errors += 1
        except Exception as e:
            print(f"[FAIL] {fname}: {e}")
            errors += 1
            
    if errors > 0:
        print(f"\nVerification Failed with {errors} errors.")
        sys.exit(1)
    else:
        print("\nAll puzzles verified successfully!")

if __name__ == "__main__":
    verify_puzzles()

```

### FILE: scripts\verify_schema_fix.py
```py
from game_engine.logic.game import Game
from server.schemas.game import GameStateModel
import logging

try:
    game = Game("test_room")
    # Simulate problematic state matched from logs
    game.dealing_phase = 0
    game.win_probability_history = [{'trick': 7, 'us': 0.115}, {'trick': 8, 'us': 0.230}]
    game.blunders = {'Bottom': 2}
    
    print("Generating Game State...")
    state_dict = game.get_game_state()
    
    print("Validating against Pydantic Model...")
    model = GameStateModel(**state_dict)
    
    print("‚úÖ Schema Validation Passed!")
    print(f"Serialized dealingPhase: {model.dealingPhase} (Type: {type(model.dealingPhase)})")
    print(f"Serialized blunders: {model.analytics.blunders} (Type: {type(model.analytics.blunders)})")
    
except Exception as e:
    print(f"‚ùå Schema Validation Failed: {e}")
    exit(1)

```

### FILE: scripts\verify_with_gemini.py
```py

import os
import glob
import random
import google.generativeai as genai
from dotenv import load_dotenv

# Load API Key
load_dotenv()
API_KEY = os.getenv("GEMINI_API_KEY")
if not API_KEY:
    print("Error: GEMINI_API_KEY not found in .env")
    exit(1)

genai.configure(api_key=API_KEY)

def verify_dataset(sample_size=5):
    print(f"Starting Smart Verification with Gemini Flash (Sample: {sample_size})...")
    
    # Get all images
    images = glob.glob("dataset/images/train/*.jpg")
    if not images:
        print("No images found in dataset/images/train")
        return

    # Sample random images
    sample = random.sample(images, min(len(images), sample_size))
    
    model = genai.GenerativeModel('gemini-2.0-flash')
    
    passed = 0
    total = 0
    
    for img_path in sample:
        filename = os.path.basename(img_path)
        print(f"\nAnalyzing {filename}...")
        
        try:
            # Load bytes
            with open(img_path, "rb") as f:
                img_data = f.read()
                
            prompt = """
            Look at this image. It is a crop from a Baloot card game.
            1. Is there a clearly visible playing card? (Yes/No)
            2. If yes, what is the rank and suit? (e.g., '7 of Spades', 'King of Hearts', 'Ace of Diamonds').
            3. Is it a 'back of card'? (Yes/No)
            
            Output strictly in this format:
            Visible: [Yes/No]
            Card: [Card Name / Back / None]
            """
            
            response = model.generate_content([
                {'mime_type': 'image/jpeg', 'data': img_data},
                prompt
            ])
            
            print(f"Gemini: {response.text.strip()}")
            passed += 1 # Just counting successful API calls for now, logic to parse 'Passed' can be added.
            total += 1
            
            import time
            print("Sleeping for 10s to respect rate limits...")
            time.sleep(10)
            
        except Exception as e:
            print(f"Error calling Gemini: {e}")
            
    print(f"\nVerification Complete. Checked {total} images.")

if __name__ == "__main__":
    verify_dataset()

```

### FILE: scripts\visualize_state.py
```py
import json
import sys
import argparse

def print_tree(data, indent=0, key="Root"):
    space = "  " * indent
    if isinstance(data, dict):
        print(f"{space}üìÇ {key}")
        for k, v in data.items():
            print_tree(v, indent + 1, k)
    elif isinstance(data, list):
        print(f"{space}üìÇ {key} (List[{len(data)}])")
        for i, item in enumerate(data):
            print_tree(item, indent + 1, f"Item {i}")
    else:
        # Leaf
        print(f"{space}üîπ {key}: {data}")

def visualize_game_state(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            state = json.load(f)
            
        print(f"üé® Visualizing Game State from: {file_path}")
        print("="*40)
        
        # Custom "Baloot" View for easier reading
        if "players" in state:
            print(f"üè† Room: {state.get('roomId')} | Phase: {state.get('phase')}")
            print(f"üèÜ Scores - Us: {state.get('teamScores', {}).get('us')} | Them: {state.get('teamScores', {}).get('them')}")
            print(f"üÉè Trump: {state.get('trumpSuit')} | Mode: {state.get('gameMode')}")
            print("-" * 20)
            
            for p in state['players']:
                idx = p.get('index')
                pos = p.get('position')
                tm = p.get('team')
                hand_len = len(p.get('hand', []))
                print(f"üë§ [{idx}] {pos} ({tm}) - Hand: {hand_len} cards")
                # Print Hand compact
                cards = [f"{c['rank']}{c['suit']}" for c in p.get('hand', [])]
                print(f"    Cards: {', '.join(cards)}")
                
        else:
            # Fallback to generic tree
            print_tree(state)
            
    except Exception as e:
        print(f"‚ùå Error reading/parsing file: {e}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('file', help="Path to JSON state dump")
    args = parser.parse_args()
    
    visualize_game_state(args.file)

```

### FILE: scripts\verification\measure_bot_iq.py
```py

import sys
import os
import json
import logging

# Setup Path
sys.path.append(os.getcwd())

from game_engine.models.card import Card
from ai_worker.bot_context import BotContext
from ai_worker.strategies.playing import PlayingStrategy
from ai_worker.strategies.bidding import BiddingStrategy
from game_engine.models.constants import BiddingPhase

# Configure separate logger to avoid noise
logging.basicConfig(level=logging.ERROR)

def parse_card_str(c_str):
    # Format: "J‚ô†" or map rank/suit dict
    rank = c_str[:-1]
    suit = c_str[-1]
    return Card(suit, rank)

def create_context_from_case(case):
    setup = case['setup']
    mode = setup['mode'] # Can be None for bidding
    trump = setup['trump']
    my_hand_strs = setup['my_hand']
    my_hand = [parse_card_str(s) for s in my_hand_strs]
    
    table_strs = setup['table']
    table_cards = []
    for tc in table_strs:
         # format expected: {"rank": "A", "suit": "S", "playedBy": "Right"}
         c = Card(tc['suit'], tc['rank'])
         table_cards.append({'card': c.to_dict(), 'playedBy': tc['playedBy']})
         
    # History for memory
    history = setup.get('history', [])
    
    # Bidding Specifics
    phase_str = setup.get('phase', 'PLAYING')
    bidding_round = setup.get('bidding_round', 1)
    floor_dict = setup.get('floor_card')
    floor_card = None
    if floor_dict:
         floor_card = {'rank': floor_dict['rank'], 'suit': floor_dict['suit']}
    
    bidder = setup.get('bidder')
    bid_info = {}
    if mode: bid_info['type'] = mode
    if trump: bid_info['suit'] = trump
    if bidder: bid_info['bidder'] = bidder
    
    raw_state = {
        'players': [
            {'position': 'Bottom', 'team': 'us', 'hand': [c.to_dict() for c in my_hand], 'name': 'Bot'},
            {'position': 'Right', 'team': 'them', 'hand': [], 'name': 'Right'},
            {'position': 'Top', 'team': 'us', 'hand': [], 'name': 'Top'},
            {'position': 'Left', 'team': 'them', 'hand': [], 'name': 'Left'}
        ],
        'phase': phase_str,
        'biddingPhase': phase_str if phase_str == 'BIDDING' else None, # Simplified
        'gameMode': mode,
        'trumpSuit': trump,
        'tableCards': table_cards,
        'dealerIndex': 1,
        'bid': bid_info,
        'currentRoundTricks': history,
        'biddingRound': bidding_round,
        'floorCard': floor_card
    }
    
    return BotContext(raw_state, 0)

def run_benchmark():
    file_path = "tests/ai_iq/iq_test_cases.json"
    with open(file_path, 'r', encoding='utf-8') as f:
        cases = json.load(f)
        
    playing_strategy = PlayingStrategy()
    # Disable MCTS for IQ Benchmark (Heuristic Verification)
    if hasattr(playing_strategy, 'cognitive'):
        playing_strategy.cognitive.enabled = False
        
    bidding_strategy = BiddingStrategy()
    
    total = 0
    passed = 0
    results = []
    
    print(f"\n--- üß† BALOOT AI IQ TEST ---")
    print(f"Loaded {len(cases)} strategic scenarios.\n")
    
    for case in cases:
        total += 1
        ctx = create_context_from_case(case)
        category = case.get('category', 'PLAYING')
        
        # Decision
        try:
             decision = None
             if category == 'PLAYING':
                  decision = playing_strategy.get_decision(ctx)
             elif category == 'BIDDING':
                  decision = bidding_strategy.get_decision(ctx)
             
             # Evaluate
             expected_action = case.get('expected_action', 'PLAY')
             is_correct = False
             
             details = ""
             
             if category == 'PLAYING':
                  expected_card_str = case['expected_card']
                  expected_rank = expected_card_str[:-1]
                  expected_suit = expected_card_str[-1]
                  
                  chosen_idx = decision['cardIndex']
                  chosen_card = ctx.hand[chosen_idx]
                  
                  is_correct = (chosen_card.rank == expected_rank and chosen_card.suit == expected_suit)
                  details = f"Got: {chosen_card}"
                  if not is_correct: details += f" | Expected: {expected_card_str}"
                  
             elif category == 'BIDDING':
                  action = decision['action']
                  is_correct = (action == expected_action)
                  
                  if is_correct and action == 'HOKUM':
                       # Check suit
                       exp_suit = case.get('expected_suit')
                       got_suit = decision.get('suit')
                       if exp_suit and got_suit != exp_suit:
                            is_correct = False
                            details = f"Action Correct but Suit Wrong. Got: {got_suit} | Expected: {exp_suit}"
                  
                  if not details:
                       details = f"Action: {action}"
                       if not is_correct: details += f" | Expected: {expected_action}"

             # Keywords
             reason = decision.get('reasoning', '')
             keyword_match = True
             if 'reasoning_keyword' in case:
                  kw = case['reasoning_keyword']
                  if kw.lower() not in reason.lower():
                       keyword_match = False
                       
             status = "PASS" if is_correct else "FAIL"
             if is_correct and not keyword_match:
                  status = "WEAK PASS" # Right move, wrong reason?
             
             if is_correct: passed += 1
             
             print(f"[{status}] {case['id']}: {case['description']}")
             if status != "PASS":
                  print(f"   {details} ({reason})")
             else:
                  print(f"   Reasoning: {reason}")
                  
             results.append({'id': case['id'], 'status': status})
             
        except Exception as e:
             print(f"[ERROR] {case['id']}: {e}")
             import traceback
             traceback.print_exc()
             
    score = (passed / total) * 100
    print(f"\n--- RESULTS ---")
    print(f"Accuracy: {score:.1f}% ({passed}/{total})")
    
    iq_score = 100 + (passed * 10) # Arbitrary IQ mapping
    print(f"Estimated Bot IQ: {iq_score}")
    
    if score == 100:
         print("üåü GENIUS LEVEL STRATEGY")
    elif score >= 75:
         print("‚úÖ COMPETENT PLAYER")
    else:
         print("‚ùå NEEDS IMPROVEMENT")

if __name__ == "__main__":
    run_benchmark()

```

### FILE: scripts\verification\test_redis.py
```py
import redis
import sys

print("Testing Redis...")
try:
    r = redis.from_url("redis://localhost:6379/0", decode_responses=True, socket_timeout=2.0)
    print("Connected object created.")
    val = r.ping()
    print(f"PING: {val}")
    
    val = r.get("brain:move:FORCE_OVERRIDE_TEST")
    print(f"Key Value: {val}")
    
except Exception as e:
    print(f"Redis Error: {e}")

```

### FILE: scripts\verification\verify_ai_client.py
```py

import sys
import os

# Add project root to path
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

# from server.settings import GEMINI_API_KEY
from ai_worker.llm_client import GeminiClient

print(f"API Key Present in Env: {bool(os.environ.get('GEMINI_API_KEY'))}")

try:
    client = GeminiClient()
    print("‚úÖ GeminiClient instantiated successfully.")
except Exception as e:
    print(f"‚ùå GeminiClient failed: {e}")

```

### FILE: scripts\verification\verify_bots_e2e.py
```py
import socketio
import time
import sys
import logging
import random

# Configure Logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - [E2E] - %(message)s')
logger = logging.getLogger("E2E_Verifier")

SERVER_URL = "http://localhost:3005"
sio = socketio.Client()
game_state = {}
my_index = None

@sio.event
def connect():
    logger.info("Connected to server.")

@sio.event
def disconnect():
    logger.info("Disconnected from server.")

@sio.event
def game_start(data):
    global game_state, my_index
    logger.info("Game Started!")
    game_state = data['gameState']
    
@sio.event
def game_update(data):
    global game_state
    game_state = data['gameState']
    logger.info(f"Phase: {game_state['phase']} | Turn: {game_state['currentTurnIndex']}")

@sio.event
def bot_speak(data):
    logger.info(f"Bot Speech: {data.get('message')} (Mood: {data.get('mood')})")

def get_action(state, player_idx):
    phase = state.get('phase')
    if phase == 'BIDDING':
        return {'action': 'BID', 'payload': {'action': 'PASS'}}
    elif phase == 'PLAYING':
        hand = state['players'][player_idx]['hand']
        # Simple Logic: Follow Suit or Random
        table = state.get('tableCards', [])
        if table:
             lead_suit = table[0]['card']['suit']
             followers = [i for i, c in enumerate(hand) if c['suit'] == lead_suit]
             if followers:
                  return {'action': 'PLAY', 'payload': {'cardIndex': followers[0]}}
        
        # Fallback
        return {'action': 'PLAY', 'payload': {'cardIndex': 0}}
    return None

def run_test():
    global my_index, game_state
    
    try:
        sio.connect(SERVER_URL)
        
        # 1. Create Room
        room = sio.call('create_room', {})
        room_id = room['roomId']
        logger.info(f"Created Room: {room_id}")
        
        # 2. Join (Server should auto-spawn 3 bots)
        join_res = sio.call('join_room', {'roomId': room_id, 'playerName': 'HumanTester'})
        if not join_res['success']:
             logger.error("Failed to join!")
             return
             
        my_index = join_res['yourIndex']
        logger.info(f"Joined as Player {my_index}. Waiting for bots...")
        
        # 3. Game Loop
        start_time = time.time()
        moves_made = 0
        
        while time.time() - start_time < 30: # Run for 30s
             if not game_state: 
                  time.sleep(1)
                  continue
                  
             if game_state.get('phase') == 'FINISHED':
                  logger.info("Game Finished!")
                  break
                  
             current_turn = game_state.get('currentTurnIndex')
             
             if current_turn == my_index:
                  action = get_action(game_state, my_index)
                  if action:
                       logger.info(f"My Turn. Action: {action['action']}")
                       sio.emit('game_action', {
                           'roomId': room_id,
                           'action': action['action'],
                           'payload': action['payload']
                       })
                       moves_made += 1
                       time.sleep(1) # simulate thinking
             else:
                  # Bot turn - wait
                  pass
             
             time.sleep(0.5)
             
        logger.info(f"Test Complete. Moves made by me: {moves_made}")
        
    except Exception as e:
        logger.error(f"Error: {e}")
    finally:
        sio.disconnect()

if __name__ == "__main__":
    run_test()

```

### FILE: scripts\verification\verify_brain.py
```py
import sys
import os
import json
import logging

# Setup path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Set Offline Mode to prevent Real Redis connection attempt
# os.environ["OFFLINE_MODE"] = "true" # Commented out for Production Mode check


from bot_agent import bot_agent
from game_engine.models.card import Card
from ai_worker.mock_redis import MockRedis

from settings import OFFLINE_MODE

def verify_brain():
    
    if OFFLINE_MODE:
        print("Verifying Brain Override (OFFLINE MOCK MODE)...")
        # Inject Mock
        mock_redis = MockRedis()
        bot_agent.redis_client = mock_redis
        
        # Set the test Key
        test_key = "brain:move:FORCE_OVERRIDE_TEST"
        test_val = json.dumps({"action": "PLAY", "suit": "‚ô†", "rank": "A", "reason": "Test Override"})
        mock_redis.set(test_key, test_val)
        
        val = bot_agent.redis_client.get(test_key)
        print(f"Mock Redis Check for '{test_key}': {val}")
        
    else:
        print("Verifying Brain Override (LIVE REDIS MODE)...")
        if not bot_agent.redis_client:
             print("ERROR: BotAgent failed to connect to Redis.")
             return

        # Prepare Real Redis with Test Key
        test_key = "brain:move:FORCE_OVERRIDE_TEST"
        test_val = json.dumps({"action": "PLAY", "suit": "‚ô†", "rank": "A", "reason": "Test Override"})
        bot_agent.redis_client.set(test_key, test_val)
        print(f"Seeded Redis Key: {test_key}")

    
    # Mock Game State
    # We need a state that triggers PLAYING phase
    mock_state = {
        "roomId": "test_room",
        "phase": "PLAYING",
        "gameMode": "SUN",
        "trumpSuit": None,
        "players": [
            {"id": "p0", "name": "Bot", "hand": [], "captured": []},
            {"id": "p1", "name": "R", "hand": [], "captured": []},
            {"id": "p2", "name": "T", "hand": [], "captured": []},
            {"id": "p3", "name": "L", "hand": [], "captured": []}
        ],
        "tableCards": [],
        "currentTurnIndex": 0,
        "dealerIndex": 0,
        "matchScores": {"us": 0, "them": 0},
        "bid": {"type": "SUN", "suit": None}
    }
    
    # We need to ensure the bot has the card we want it to play (Ace of Spades)
    # And maybe a 7-S to check if it would normally play that?
    # Actually, the Brain logic maps Brain Move (Rank/Suit) to an index in hand.
    # So we MUST have the Ace of Spades in hand.
    
    # Let's give it [7-S, A-S]
    # Index 0: 7-S
    # Index 1: A-S
    
    # If Heuristic (Random/Weak) plays 7-S (Index 0).
    # If Brain plays A-S (Index 1).
    
    # Note: bot_agent.py re-constructs BotContext from state.
    # We need to ensure BotContext parses this correctly.
    # BotContext uses `state['players'][idx]['hand']`.
    
    hand = [
        {"rank": "7", "suit": "‚ô†"},
        {"rank": "A", "suit": "‚ô†"}
    ]
    mock_state['players'][0]['hand'] = hand
    
    print(f"Test Hand: {hand}")
    
    # Call Decision
    decision = bot_agent.get_decision(mock_state, 0)
    
    print(f"Decision: {decision}")
    
    if decision.get('cardIndex') == 1:
        print("SUCCESS! Bot chose Index 1 (Ace of Spades) - The Brain Works.")
        if "Brain Override" in decision.get('reasoning', ''):
             print(f"Reasoning confirmed: {decision.get('reasoning')}")
    else:
        print(f"FAILURE. Bot chose Index {decision.get('cardIndex')}. Brain ignored.")

if __name__ == "__main__":
    verify_brain()

```

### FILE: scripts\verification\verify_brain_pipeline.py
```py

import json
import os
import sys
import hashlib
import time

# Ensure we can import from project root
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Import from ai_worker.agent not bot_agent root if it was moved, 
# but bot_agent.py is in ai_worker based on previous `view_file`.
# Wait, `bot_agent.py` was viewed in `ai_worker/agent.py` but the file listing showed `agent.py`.
# Let's check where `bot_agent` instance is defined. `ai_worker/agent.py` defines class `BotAgent` and instance `bot_agent`.

from ai_worker.agent import bot_agent
from ai_worker.bot_context import BotContext
# from scripts.train_brain import train_brain # We'll call it via subprocess or import if modular
import redis

# Settings
MISTAKES_FILE = "candidates/mistakes_temp.json"
REDIS_URL = "redis://127.0.0.1:6379/0"

def verify_pipeline():
    print("üß† Verifying The Brain Pipeline...")
    
    # 1. Setup Redis
    try:
        r = redis.from_url(REDIS_URL, decode_responses=True)
        r.ping()
        print("‚úÖ Connected to Real Redis")
    except Exception as e:
        print(f"‚ö†Ô∏è  Redis Connection Failed: {e}")
        print("‚ö†Ô∏è  Switching to MockRedis for Logic Verification...")
        from ai_worker.mock_redis import MockRedis
        r = MockRedis()
        
        # Monkey patch redis for train_brain import if needed, 
        # but train_brain imports `redis`. We might need to inject it.
        # Actually easier: we can't easily patch `train_brain.py`'s internal redis import without sys.modules hack.
        # Let's verify the *Key Generation Logic* and *Bot Retrieval* mainly.
        # For `train_brain`, we might need to modify it to accept a client or Mock it.
        
        # Inject MockRedis into sys.modules to trick train_brain
        import types
        mock_redis_module = types.ModuleType("redis")
        mock_redis_module.from_url = lambda url, **kwargs: r
        sys.modules["redis"] = mock_redis_module
        
        print("‚úÖ MockRedis Injected for verification")

    # 2. Construct a Fake "Match Moment"
    # Scenario: Bot holds [Ace Spades, 7 Spades]. 
    # Valid Play: Ace Spades (Index 1).
    # Bad Play: 7 Spades (Index 0).
    
    hand = [{"rank": "7", "suit": "S"}, {"rank": "A", "suit": "S"}]
    table = []
    
    # Calculate Hash manually to match bot_agent logic
    state_for_hash = {
        'hand': ["7S", "AS"],
        'table': [],
        'phase': "PLAYING",
        'bid': {"type": "SUN", "suit": None},
        'dealer': 0
    }
    state_str = json.dumps(state_for_hash, sort_keys=True)
    context_hash = hashlib.md5(state_str.encode()).hexdigest()
    
    print(f"üîπ Generated Hash: {context_hash}")
    
    # 3. Create Training Data
    training_data = [
        {
            "match_id": "test_match",
            "analysis": {
                "moments": [
                    {
                        "context_hash": context_hash,
                        "correct_move": {"action": "PLAY", "suit": "S", "rank": "A", "reason": "Pipeline Verification"},
                        "bad_move": {"action": "PLAY", "suit": "S", "rank": "7"}
                    }
                ]
            }
        }
    ]
    
    os.makedirs("candidates", exist_ok=True)
    with open(MISTAKES_FILE, 'w') as f:
        json.dump(training_data, f)
        
    print(f"üîπ Created {MISTAKES_FILE}")
    
    # 4. Run Training (Import dynamically to ensure we use the fixed version)
    from scripts.train_brain import train_brain
    print("üîπ Running Training...")
    train_brain(MISTAKES_FILE)
    
    # 5. Verify Redis Key
    key = f"brain:correct:{context_hash}"
    val = r.get(key)
    if not val:
        print(f"‚ùå Training Failed. Redis key {key} not found.")
        return
    print(f"‚úÖ Redis Key Found: {val}")
    
    # 6. Verify Bot Override
    print("üîπ Verifying Bot Agent Override...")
    
    # Mock Game State for BotAgent
    # Must match the hash components exactly!
    # Card string conversion in bot_agent uses str(Card) -> "RankSuit" (e.g. "AS")
    # We need to ensure the Input to bot_agent results in the same hash.
    
    mock_state = {
        "roomId": "test_room",
        "phase": "PLAYING",
        "gameMode": "SUN",
        "trumpSuit": None,
        "players": [
            {"id": "p0", "name": "Bot", "hand": hand, "captured": []},
            {"id": "p1", "name": "R", "hand": [], "captured": []},
            {"id": "p2", "name": "T", "hand": [], "captured": []},
            {"id": "p3", "name": "L", "hand": [], "captured": []}
        ],
        "tableCards": [], # Empty list of dicts normally
        "currentTurnIndex": 0,
        "dealerIndex": 0,
        "matchScores": {"us": 0, "them": 0},
        "bid": {"type": "SUN", "suit": None}
    }
    
    # Instantiate Bot (connects to Redis)
    bot_agent.redis_client = r 
    
    # Force decision
    # We expect decision to be Index 1 (Ace) because of the learned move "Rank A, Suit S"
    
    decision = bot_agent.get_decision(mock_state, 0)
    print(f"üîπ Bot Decision: {decision}")
    
    if decision.get('action') == 'PLAY' and "Brain" in decision.get('reasoning', ''):
        target_card_idx = decision.get('cardIndex')
        # We know Ace is at index 1
        if target_card_idx == 1:
             print("‚úÖ VERIFICATION PASSED! Bot used the learned move.")
        else:
             print(f"‚ùå Implementation Error: Bot claimed Brain usage but picked index {target_card_idx} (Expected 1)")
    else:
        print("‚ùå Verification Failed. Bot did not use Brain override.")

if __name__ == "__main__":
    verify_pipeline()

```

### FILE: scripts\verification\verify_compliance.py
```py
import subprocess
import sys
import os

def run_command(command, description):
    print(f"\n>>> Running: {description}...")
    try:
        result = subprocess.run(command, shell=True, capture_output=True, text=True)
        if result.returncode == 0:
            print(f"PASSED: {description}")
            return True, result.stdout
        else:
            print(f"FAILED: {description}")
            print(result.stderr or result.stdout)
            return False, result.stdout
    except Exception as e:
        print(f"ERROR: Could not run {description}: {str(e)}")
        return False, str(e)

def main():
    print("="*60)
    print("      BALOOT CORE RULE COMPLIANCE REPORT      ")
    print("="*60)

    checks = [
        {
            "cmd": "pytest tests/test_bidding_rules.py tests/test_projects_logic.py tests/test_scoring_comprehensive.py",
            "desc": "Unit Tests: Bidding & Scoring Rules"
        },
        {
            "cmd": "python run_test_suite.py",
            "desc": "Scenario Simulations: Full Game Flow"
        }
    ]

    results = []
    if all_passed:
        print("COMPLIANCE VERIFIED: All core rules match standard Baloot rules.")
    else:
        print("COMPLIANCE WARNING: Some rules may deviate from standards. See logs above.")
    print("="*60)

if __name__ == "__main__":
    main()

```

### FILE: scripts\verification\verify_director.py
```py
import requests
import json
import time

SERVER_URL = "http://127.0.0.1:3005/react-py4web"

def verify_director():
    print("--- Verifying Commissioner's Desk ---")
    
    # 1. Fetch Game List to get an active game
    try:
        res = requests.get(f"{SERVER_URL}/replay/list")
        if res.status_code != 200:
             print("FAIL: Could not fetch list")
             return
        
        matches = res.json().get('matches', [])
        if not matches:
             print("WARN: No active games found. Please start a game.")
             # We can try to create one or just use verify_game_flow if needed
             # But let's assume user has a game running or we just need one valid ID.
             # Actually, let's verify on a specific ID or the first one.
             return
             
        target_game_id = matches[0]['gameId']
        # target_game_id = "2fd97f57" # Hardcoded active game from logs
        print(f"Targeting Game: {target_game_id}")
        
        # 2. Update Config
        payload = {
            "gameId": target_game_id,
            "settings": {
                "strictMode": True,
                "turnDuration": 99
            },
            "botConfigs": {
                "1": {"strategy": "neural", "profile": "Aggressive"},
                "2": {"strategy": "mcts", "profile": "Conservative"}
            }
        }
        
        print(f"Sending Update Payload: {json.dumps(payload, indent=2)}")
        res = requests.post(f"{SERVER_URL}/game/director/update", json=payload)
        
        if res.status_code == 200:
            print("SUCCESS: Director Update API returned 200")
        else:
            print(f"FAIL: API Error {res.status_code} - {res.text}")
            return
            
        # 3. Verify State Update
        # We need a way to check current state. Usually /ask_strategy gets state? 
        # Or just checking logs/internal state via a cheat endpoint?
        # Maybe use /match_history if it updates live? No, that's history.
        # Let's trust the API for now, or use a debug endpoint if available.
        # Ideally, we should fetch game state. The replay/list might have summary? No.
        # We can use the /debug/game/<id> if we had one.
        # Let's just rely on the API success and logs.
        
        print("Verification Complete (Backend Accepted Config)")
        
    except Exception as e:
        print(f"FAIL: {e}")

if __name__ == "__main__":
    verify_director()

```

### FILE: scripts\verification\verify_forensic_engine.py
```py

import sys
import os

# Add project root to path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../')))

from game_engine.logic.forensic import ForensicReferee
from game_engine.models.constants import ORDER_HOKUM, ORDER_SUN

def test_revoke_scenario():
    print("\n=== Testing REVOKE Scenario ===")
    
    # Mock Game State
    game_state = {
        'roomId': 'TEST_ROOM',
        'gameMode': 'SUN',
        'trumpSuit': None,
        'roundHistory': [] 
    }
    
    # Pre-populate history
    # Trick 1: Bottom leads ‚ô•7. Right plays ‚ô£7 (Revoke!). Top plays ‚ô•8. Left plays ‚ô•9.
    
    trick1 = {
        'cards': [
            {'card': {'suit': '‚ô•', 'rank': '7'}, 'playedBy': 'Bottom'},
            {'card': {'suit': '‚ô£', 'rank': '7'}, 'playedBy': 'Right'}, # THE CRIME
            {'card': {'suit': '‚ô•', 'rank': '8'}, 'playedBy': 'Top'},
            {'card': {'suit': '‚ô•', 'rank': '9'}, 'playedBy': 'Left'}
        ],
        'winner': 'Left',
        'points': 0
    }
    
    # Trick 2: Right plays ‚ô•K (The Proof! He had hearts all along)
    trick2 = {
        'cards': [
             {'card': {'suit': '‚ô•', 'rank': 'K'}, 'playedBy': 'Right'} # THE PROOF
        ]
    }
    
    game_state['roundHistory'] = [trick1, trick2]
    
    # Accusation
    crime_card = {'suit': '‚ô£', 'rank': '7', 'playedBy': 'Right'}
    proof_card = {'suit': '‚ô•', 'rank': 'K', 'playedBy': 'Right'}
    
    verdict = ForensicReferee.validate_accusation(
        game_snapshot=game_state,
        crime_card=crime_card,
        proof_card=proof_card,
        violation_type='REVOKE'
    )
    
    print(f"Verdict: {verdict}")
    if verdict['is_guilty']:
        print("‚úÖ SUCCESS: Revoke correctly identified.")
    else:
        print("‚ùå FAILURE: Revoke missed.")

def test_eat_scenario():
    print("\n=== Testing EAT Scenario (Hokum) ===")
    # Scenario: 
    # Mode: HOKUM (Spades Trump)
    # Trick 1: 
    # - Bottom leads ‚ô¶A (Strong). 
    # - Right (Void in Diamonds) plays ‚ô£7 (Weak Non-Trump). FAILURE TO EAT.
    # - Top plays ‚ô¶7.
    # - Left plays ‚ô¶8.
    
    # Proof: Right plays ‚ô†7 later.
    
    game_state = {
        'roomId': 'TEST_ROOM',
        'gameMode': 'HOKUM',
        'trumpSuit': '‚ô†',
        'roundHistory': []
    }
    
    trick1 = {
        'cards': [
            {'card': {'suit': '‚ô¶', 'rank': 'A'}, 'playedBy': 'Bottom'},
            {'card': {'suit': '‚ô£', 'rank': '7'}, 'playedBy': 'Right'}, # CRIME: Should have eaten with Spade
            {'card': {'suit': '‚ô¶', 'rank': '7'}, 'playedBy': 'Top'},
            {'card': {'suit': '‚ô¶', 'rank': '8'}, 'playedBy': 'Left'}
        ]
    }
    
    trick2 = {
         'cards': [
              {'card': {'suit': '‚ô†', 'rank': '7'}, 'playedBy': 'Right'} # PROOF
         ]
    }
    
    game_state['roundHistory'] = [trick1, trick2]
    
    crime_card = {'suit': '‚ô£', 'rank': '7', 'playedBy': 'Right'}
    proof_card = {'suit': '‚ô†', 'rank': '7', 'playedBy': 'Right'}
    
    verdict = ForensicReferee.validate_accusation(
        game_snapshot=game_state,
        crime_card=crime_card,
        proof_card=proof_card,
        violation_type='EAT'
    )
    
    print(f"Verdict: {verdict}")
    if verdict['is_guilty']:
        print("‚úÖ SUCCESS: Eat violation correctly identified.")
    else:
        print("‚ùå FAILURE: Eat violation missed.")

if __name__ == "__main__":
    test_revoke_scenario()
    test_eat_scenario()

```

### FILE: scripts\verification\verify_game_flow.py
```py
import socketio
import time
import sys
import json
import logging
import random

# Configure Logging for the Verifier itself
logging.basicConfig(level=logging.INFO, format='%(asctime)s - [VERIFIER] - %(message)s')
logger = logging.getLogger("Verifier")

SERVER_URL = "http://localhost:3005"

clients = []
client_states = {} # map client_index -> last_state
game_id = None
is_running = True

def create_client(index, name):
    sio = socketio.Client()
    
    @sio.event
    def connect():
        logger.info(f"Client {index} ({name}) connected")
        
    @sio.event
    def disconnect():
        logger.info(f"Client {index} disconnected")

    @sio.event
    def game_update(data):
        # Update local state tracking
        client_states[index] = data['gameState']
        
    return sio

def get_valid_action(state, player_index):
    """
    Very dumb random AI.
    """
    phase = state.get('phase')
    turn_idx = state.get('currentTurnIndex')
    
    if turn_idx != player_index:
        return None
        
    if phase == 'BIDDING':
        # Randomly bid to ensure game starts
        if random.random() < 0.3: # 30% chance to bid
             valid_bids = ['SUN', 'HOKUM']
             action = random.choice(valid_bids)
             return {'action': 'BID', 'payload': {'action': action, 'suit': 'S'}} # Suit irrelevant for SUN/HOKUM usually, but passing S just in case
             
        return {'action': 'BID', 'payload': {'action': 'PASS'}}
        
    elif phase == 'PLAYING':
        my_hand = []
        players = state.get('players', [])
        if len(players) > player_index:
             my_hand = players[player_index].get('hand', [])
             
        if not my_hand:
            return None

        # --- Follow Suit Logic ---
        table_cards = state.get('tableCards', [])
        valid_cards = []
        
        if not table_cards:
            # First to play: Any card is valid
            valid_cards = my_hand
        else:
            # Must follow suit of the first card
            lead_suit = table_cards[0]['card']['suit']
            # Check if we have that suit
            formatted_hand = []
            same_suit_cards = []
            
            for c in my_hand:
                if c['suit'] == lead_suit:
                    same_suit_cards.append(c)
            
            if same_suit_cards:
                valid_cards = same_suit_cards
            else:
                # Can play anything (usually)
                valid_cards = my_hand
                
        if not valid_cards:
             valid_cards = my_hand # Fallback
            
        card = random.choice(valid_cards)
        return {'action': 'PLAY_CARD', 'payload': card}
        
    return None

def run_simulation():
    global game_id
    logger.info("--- Starting Full Game Simulation ---")
    
    # 1. Setup Clients
    names = ["Sim_Bot_1", "Sim_Bot_2", "Sim_Bot_3", "Sim_Bot_4"]
    main_sio = create_client(0, names[0])
    main_sio.connect(SERVER_URL)
    clients.append(main_sio)
    
    # 2. Create Room
    logger.info("Creating Room...")
    room_data = main_sio.call('create_room', {})
    game_id = room_data['roomId']
    logger.info(f"Room Created: {game_id}")
    
    # Join P1 (Main)
    main_sio.emit('join_room', {'roomId': game_id, 'playerName': names[0]})
    
    # Join others
    for i in range(1, 4):
        c = create_client(i, names[i])
        c.connect(SERVER_URL)
        c.emit('join_room', {'roomId': game_id, 'playerName': names[i]})
        clients.append(c)
        time.sleep(0.2) # clear registration
        
    logger.info("All players joined.")
    
    # 3. Game Loop
    sim_start = time.time()
    turns_played = 0
    
    while is_running and (time.time() - sim_start < 60): # 60s max timeout
        # Check states
        active_state = None
        for i, s in client_states.items():
            if s: active_state = s; break
            
        if not active_state:
            time.sleep(0.5)
            continue
            
        # Check Game Over
        if active_state.get('phase') == 'FINISHED':
            logger.info(f"Game Finished! Winner: {active_state.get('winner')}")
            break
            
        # Check whose turn it is
        current_turn = active_state.get('currentTurnIndex')
        phase = active_state.get('phase')
        
        if current_turn is not None and 0 <= current_turn < 4:
            client = clients[current_turn]
            action = get_valid_action(active_state, current_turn)
            
            if action:
                logger.info(f"Player {current_turn} doing {action['action']} in {phase}")
                client.emit('game_action', {
                    'roomId': game_id, 
                    'action': action['action'], 
                    'payload': action['payload']
                })
                turns_played += 1
                time.sleep(0.1) # Debounce
            else:
                # Maybe waiting or animating
                pass
        
        time.sleep(0.2)
        
    logger.info(f"Simulation ended. Turns played: {turns_played}")
    
    for c in clients:
        c.disconnect()

if __name__ == "__main__":
    try:
        run_simulation()
    except KeyboardInterrupt:
        pass
    except Exception as e:
        logger.error(f"Sim Failed: {e}")

```

### FILE: scripts\verification\verify_identity.py
```py

import socketio
import time
import sys

def verify_identity():
    """
    Connects to the server, creates a room, and verifies that:
    1. Bots join automatically.
    2. Bots have correct Names (Saad, Khalid, Abu Fahad).
    3. Bots have correct Avatar IDs.
    """
    print("Verifying Unified Bot Identity...")
    
    sio = socketio.Client()
    results = {'players': []}
    
    @sio.event
    def connect():
        print("Connected to server.")

    @sio.event
    def player_joined(data):
        p = data['player']
        print(f"Player Joined: {p['name']} (Bot: {p.get('isBot')}) Avatar: {p.get('avatar')}")
        results['players'].append(p)
        
        # Once we have 4 players, check identities
        if len(results['players']) == 4:
            sio.disconnect()

    try:
        sio.connect('http://localhost:3005')
        
        # 1. Create Room
        room_id_container = {}
        def on_create(data):
            room_id_container['id'] = data['roomId']
            
        sio.emit('create_room', {}, callback=on_create)
        
        # Wait for callback
        start_wait = time.time()
        while 'id' not in room_id_container and time.time() - start_wait < 2:
            time.sleep(0.1)
            
        room_id = room_id_container.get('id')
        if not room_id:
            print("FAILED: Could not create room.")
            sys.exit(1)
            
        print(f"Room Created: {room_id}")

        # 2. Join Room as Human
        sio.emit('join_room', {'roomId': room_id, 'playerName': 'Verifier'})
        
        # Wait for players to join
        start_wait = time.time()
        while len(results['players']) < 4 and time.time() - start_wait < 5:
            time.sleep(0.1)
            
        if len(results['players']) < 4:
            print(f"FAILED: Timeout waiting for bots. Only found: {len(results['players'])}")
            sys.exit(1)
            
        # 3. Verify Identities
        bots = [p for p in results['players'] if p['isBot']]
        
        expected_names = ["Saad (Bot)", "Khalid (Bot)", "Abu Fahad (Bot)"]
        expected_avatars = ["avatar_saad", "avatar_khalid", "avatar_abu_fahad"]
        
        found_names = [b['name'] for b in bots]
        found_avatars = [b['avatar'] for b in bots]
        
        print("\n--- Verification Results ---")
        
        # Check Names
        for name in expected_names:
            if name in found_names:
                print(f"‚úÖ Found Bot: {name}")
            else:
                print(f"‚ùå MISSING Bot: {name}")
                
        # Check Avatars
        for av in expected_avatars:
            if av in found_avatars:
                print(f"‚úÖ Found Avatar: {av}")
            else:
                print(f"‚ùå MISSING Avatar: {av}")
                
        if all(n in found_names for n in expected_names) and all(a in found_avatars for a in expected_avatars):
            print("\nSUCCESS: All identities verified!")
        else:
            print("\nFAILURE: Identity mismatch.")
            sys.exit(1)

    except Exception as e:
        print(f"Verification Error: {e}")
        sys.exit(1)
    finally:
        if sio.connected:
            sio.disconnect()

if __name__ == "__main__":
    verify_identity()

```

### FILE: scripts\verification\verify_mind_integration.py
```py

import sys
import os
from pathlib import Path
import json

# Add project root
sys.path.append(str(Path(__file__).parent.parent.parent))

from ai_worker.bot_context import BotContext
from game_engine.models.card import Card

def create_mock_state():
    return {
        'players': [
            {'hand': [{'suit': 'H', 'rank': 'A'}, {'suit': 'D', 'rank': '10'}], 'position': 'Bottom', 'team': 'Us'},
            {'hand': [], 'position': 'Right', 'team': 'Them'},
            {'hand': [], 'position': 'Top', 'team': 'Us'}, 
            {'hand': [], 'position': 'Left', 'team': 'Them'}
        ],
        'phase': 'PLAY_PHASE',
        'gameMode': 'SUN',
        'trumpSuit': None,
        'bid': {'type': 'SUN', 'bidder': 'Bottom'},
        'tricks': [
             # One completed trick
             {
                 'cards': [
                     {'suit': 'H', 'rank': '7'}, # Played by Bottom
                     {'suit': 'H', 'rank': '8'}, # Right
                     {'suit': 'H', 'rank': '9'}, # Top
                     {'suit': 'H', 'rank': '10'} # Left
                 ],
                 'winner': 'Left'
             }
        ],
        'tableCards': [
            # Current trick partial
            {'card': {'suit': 'D', 'rank': '7'}, 'playedBy': 'Bottom'}
        ]
    }

def test_mind_integration():
    print("Testing MindReader Integration...")
    
    state = create_mock_state()
    # P0 context
    context = BotContext(state, 0)
    
    try:
        guesses = context.guess_hands()
        if guesses is None:
            print("FAIL: guess_hands() returned None. Is model loaded?")
            return
            
        print("PASS: guess_hands() returned predictions.")
        print(f"Keys: {list(guesses.keys())} (Expected [1, 2, 3])")
        
        # Check specific output
        # Player 1 (Right) predictions
        p1_probs = guesses[1]
        print(f"Player 1 Probabilities Sample: {p1_probs[:5]}")
        
        if len(p1_probs) == 32:
             print("PASS: Valid probability vector size (32).")
        else:
             print(f"FAIL: Invalid vector size {len(p1_probs)}")
             
    except Exception as e:
        print(f"FAIL: Exception raised: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    test_mind_integration()

```

### FILE: scripts\verification\verify_multiverse_flow.py
```py
import requests
import json
import sys
import time

BASE_URL = "http://localhost:3000"

def log(msg, color="white"):
    print(f"[{color.upper()}] {msg}")

def run_test():
    print("--- Verifying Multiverse Backend Logic ---")
    
    # 1. Get List
    try:
        resp = requests.get(f"{BASE_URL}/react-py4web/replay/list")
        if resp.status_code != 200:
            print(f"FAIL: List endpoint returned {resp.status_code}")
            return
        
        data = resp.json()
        matches = data.get('matches', [])
        if not matches:
            print("FAIL: No matches found to fork. Please play a game first.")
            return
            
        source_game = matches[0]
        source_id = source_game['gameId']
        print(f"PASS: Found source game {source_id}")
        
    except Exception as e:
        print(f"FAIL: Network error on list: {e}")
        return

    # 2. Fork Game
    print(f"Attempting to fork {source_id}...")
    try:
        payload = {
            "gameId": source_id,
            "roundNum": 1,
            "trickIndex": 3,
            "movesInTrick": 0
        }
        resp = requests.post(f"{BASE_URL}/react-py4web/replay/fork", json=payload)
        data = resp.json()
        
        if not data.get('success'):
            print(f"FAIL: Fork failed: {data}")
            return
            
        new_game_id = data.get('newGameId')
        print(f"PASS: Fork successful! New ID: {new_game_id}")
        
    except Exception as e:
        print(f"FAIL: Network error on fork: {e}")
        return

    # 3. Verify Tree (Multiverse)
    print("Checking Multiverse Tree for new node...")
    time.sleep(1) # Slight propagated delay
    try:
        resp = requests.get(f"{BASE_URL}/react-py4web/replay/multiverse")
        data = resp.json()
        nodes = data.get('nodes', [])
        
        # Check for new node
        found_node = next((n for n in nodes if n['id'] == new_game_id), None)
        
        if not found_node:
            print(f"FAIL: New game {new_game_id} NOT found in tree nodes.")
            print(f"Total nodes: {len(nodes)}")
            return
            
        print(f"PASS: Node found in tree.")
        print(f"Node Data: {json.dumps(found_node, indent=2)}")
        
        if found_node.get('parentId') or found_node.get('isFork'):
             print("PASS: Node correctly marked as Fork/Child.")
        else:
             print("WARNING: Node found but parentId might be missing (check logic).")
             
    except Exception as e:
        print(f"FAIL: Network error on multiverse: {e}")

if __name__ == "__main__":
    run_test()

```

### FILE: scripts\verification\verify_personality.py
```py
import sys
import os
import json

# Setup path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from game_engine.models.card import Card
from ai_worker.bot_context import BotContext
from ai_worker.strategies.bidding import BiddingStrategy
from ai_worker.personality import PROFILES

def test_personality():
    print("Testing Bot Personality...")
    
    # 1. Setup a Borderline Hand (Score ~16)
    # A (10) + Q (2) + some small cards
    # Sun Score Estimate:
    # A=10, Q=2 -> 12.
    # Length bonus? A, K, Q, J, 9 (Suit 1) -> Len 5. (5-3)*2 = 4. Total 16.
    # Aggressive (Bias +3): Threshold 18-3 = 15. 16 >= 15 -> BID.
    # Conservative (Bias -3): Threshold 18+3 = 21. 16 < 21 -> PASS.
    
    hand_cards = [
        {'rank': 'A', 'suit': 'H'}, # 10
        {'rank': 'Q', 'suit': 'H'}, # 2
        {'rank': '9', 'suit': 'H'},
        {'rank': '8', 'suit': 'H'},
        {'rank': '7', 'suit': 'H'}  # Length 5 -> +4
    ]
    # Total Score: 16
    
    # Mock State
    mock_state = {
        "players": [
            {"name": "Tester", "hand": hand_cards, "position": "Bottom"}
        ],
        "dealerIndex": 1, # Not dealer
        "phase": "BIDDING",
        "biddingRound": 1,
        "floorCard": None
    }
    
    strategy = BiddingStrategy()
    
    # 2. Test Conservative
    print("\n--- Testing CONSERVATIVE ---")
    ctx_safe = BotContext(mock_state, 0, personality=PROFILES['Conservative'])
    decision_safe = strategy.get_decision(ctx_safe)
    print(f"Decision: {decision_safe['action']} ({decision_safe.get('reasoning')})")
    
    # 3. Test Aggressive
    print("\n--- Testing AGGRESSIVE ---")
    ctx_risky = BotContext(mock_state, 0, personality=PROFILES['Aggressive'])
    decision_risky = strategy.get_decision(ctx_risky)
    print(f"Decision: {decision_risky['action']} ({decision_risky.get('reasoning')})")
    
    # 4. Assertions
    if decision_safe['action'] == 'PASS' and decision_risky['action'] in ['SUN', 'ASHKAL']:
        print("\n‚úÖ SUCCESS: Personality Influenced Decision Correctly.")
    else:
        print("\n‚ùå FAILURE: Personalities did not behave as expected.")
        print(f"Expected Conservative=PASS, Aggressive=SUN or ASHKAL. Got Safe={decision_safe['action']}, Risky={decision_risky['action']}")


if __name__ == "__main__":
    test_personality()

```

### FILE: scripts\verification\verify_puzzle_gen.py
```py

import sys
import os
import shutil
import json
import logging

# Fix Path
sys.path.append(os.getcwd())

from ai_worker.learning.puzzle_generator import PuzzleGenerator
from game_engine.models.card import Card

# Configure Logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("VerifyPuzzle")

def verify_puzzle_gen():
    print("--- Verifying Puzzle Generator ---")
    
    # 1. Setup Test Dir
    test_dir = "server/content/puzzles_test"
    if os.path.exists(test_dir):
        shutil.rmtree(test_dir)
    
    pgen = PuzzleGenerator(puzzle_dir=test_dir)
    print(f"Generator initialized in {test_dir}")
    
    # 2. Mock Context
    class MockContext:
        def __init__(self):
            self.mode = "SUN"
            self.player_index = 0
            self.raw_state = {
                "gameId": "test_game_XYZ",
                "roundHistory": [],
                "players": [
                    {"name": "Me", "index": 0, "hand": ["S7", "HA"]}, # Should effectively remain
                    {"name": "Right", "index": 1, "hand": ["D10"]}, # Should be cleared
                    {"name": "Partner", "index": 2, "hand": ["CK"]}, # Should be cleared
                    {"name": "Left", "index": 3, "hand": ["SQ"]} # Should be cleared
                ]
            }
            
    ctx = MockContext()
    human_card = Card("S", "7")
    best_card = Card("H", "A")
    analysis = {"best_move": 1, "move_values": {}}
    
    # 3. Generate
    print("Generating Puzzle...")
    success = pgen.create_from_blunder(ctx, human_card, best_card, analysis)
    
    if not success:
        print("FAIL: create_from_blunder returned False")
        exit(1)
        
    # 4. Verify File
    files = os.listdir(test_dir)
    if not files:
        print("FAIL: No puzzle file created")
        exit(1)
        
    fpath = os.path.join(test_dir, files[0])
    print(f"Puzzle file found: {fpath}")
    
    with open(fpath, 'r', encoding='utf-8') as f:
        data = json.load(f)
        
    # 5. Validate Content
    print("Validating content...")
    
    # Check ID
    if not data['id'].startswith('exam_'):
        print(f"FAIL: ID format wrong: {data['id']}")
        exit(1)

    # Check Solution
    sol_data = data['solution']['data']
    if sol_data != ["AH"]: # Card("H", "A") -> "AH"
        print(f"FAIL: Solution mismatch. Expected ['AH'], got {sol_data}")
        exit(1)
        
    # Check Hand Sanitization
    initial_players = data['initial_state']['players']
    me = initial_players[0]
    right = initial_players[1]
    
    if not me['hand']:
        print("FAIL: 'Me' hand shouldn't be empty")
        exit(1)
        
    if right['hand']:
        print(f"FAIL: 'Right' hand should be empty (Sanitized). Got: {right['hand']}")
        exit(1)
        
    print("--- VERIFICATION PASSED ‚úÖ ---")

if __name__ == "__main__":
    verify_puzzle_gen()

```

### FILE: scripts\verification\verify_redis_brain.py
```py
import sys
import os
import time
import json
import logging

# Add parent dir to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    import redis
except ImportError:
    print("Error: 'redis' package not installed. Run 'pip install redis'")
    sys.exit(1)

from settings import REDIS_URL

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("VERIFY")

def test_redis():
    logger.info(f"Connecting to Redis at {REDIS_URL}...")
    try:
        r = redis.from_url(REDIS_URL, decode_responses=True)
        r.ping()
        logger.info("‚úÖ Redis Connected Successfully!")
        
        # Test Queue Write
        test_payload = {"context_hash": "TEST_HASH", "game_context": {"data": "test"}, "heuristic_decision": {"action": "PASS"}}
        r.lpush("bot:analyze_queue", json.dumps(test_payload))
        logger.info("‚úÖ Pushed test task to 'bot:analyze_queue'")
        
        # Test Cache Write/Read
        r.set("bot:move:TEST_HASH", json.dumps({"rank": "A", "suit": "‚ô†", "reason": "Test Move"}))
        val = r.get("bot:move:TEST_HASH")
        if val:
             logger.info(f"‚úÖ Cache Read Verified: {val}")
        else:
             logger.error("‚ùå Cache Read Failed!")
             
        # Cleanup
        r.delete("bot:move:TEST_HASH")
        # Pop the test task (might be picked up by worker if running)
        # r.rpop("bot:analyze_queue") 
        
        print("\nSUMMARY: Redis is ready for the Brain.")
        
    except redis.exceptions.ConnectionError:
        logger.error("‚ùå Could not connect to Redis. Is it running?")
        print("Tip: Run 'docker run --name baloot-redis -p 6379:6379 -d redis'")
    except Exception as e:
        logger.error(f"‚ùå Unexpected Error: {e}")

if __name__ == "__main__":
    test_redis()

```

### FILE: scripts\verification\verify_rounding.py
```py
import sys
import os
# Add parent directory to sys.path to allow importing modules from root
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from server.game_logic import Game
import unittest

class TestScoring(unittest.TestCase):
    def test_hokum_rounding(self):
        # Mock class to access round_score method
        game = Game("test_room")
        game.game_mode = 'HOKUM'
        
        # Test 1.5 -> 1 (Round Down on 5)
        rounded, _ = game.round_score(15)
        self.assertEqual(rounded, 10, "Hokum 15 should round to 10")
        
        # Test 1.6 -> 2 (Round Up on 6)
        rounded, _ = game.round_score(16)
        self.assertEqual(rounded, 20, "Hokum 16 should round to 20")

        # Test 1.4 -> 1 (Round Down)
        rounded, _ = game.round_score(14)
        self.assertEqual(rounded, 10, "Hokum 14 should round to 10")

    def test_sun_rounding(self):
        game = Game("test_room")
        game.game_mode = 'SUN'
        
        # Test 1.5 -> 2 (Round Up on 5)
        rounded, _ = game.round_score(15)
        self.assertEqual(rounded, 20, "Sun 15 should round to 20")
        
        # Test 1.4 -> 1 (Round Down)
        rounded, _ = game.round_score(14)
        self.assertEqual(rounded, 10, "Sun 14 should round to 10")

if __name__ == '__main__':
    unittest.main()

```

### FILE: scripts\verification\verify_sawa.py
```py
import socketio
import time
import sys

# Configuration
SERVER_URL = "http://localhost:3000"
SIO = socketio.Client()

def verify_sawa():
    print("--- Starting Sawa Verification ---")
    
    try:
        SIO.connect(SERVER_URL)
        print("Connected to server.")
        
        # 1. Create Room
        room_data = SIO.call('create_room', {})
        room_id = room_data['roomId']
        print(f"Room Created: {room_id}")
        
        # 2. Join as Main Player (Bottom)
        SIO.emit('join_room', {'roomId': room_id, 'playerName': 'Tester'})
        time.sleep(1) # Wait for bots to join
        
        # 3. Start Game Logic
        # We need to simulate the game flow until it's our turn to play.
        # But wait! Sawa can only be called on YOUR turn.
        
        # Helper to track state
        game_state = {'phase': None, 'turn': None}
        
        @SIO.event
        def player_joined(data):
            print(f"Player Joined: {data['player']['name']}")

        @SIO.event
        def game_start(data):
            print("Game Started!")
            game_state['phase'] = data['gameState']['phase']
            game_state['turn'] = data['gameState']['currentTurnIndex']
            
        @SIO.event
        def game_update(data):
            gs = data['gameState']
            game_state['phase'] = gs['phase']
            game_state['turn'] = gs['currentTurnIndex']
            
            # Print Sawa State
            if gs.get('sawaState'):
                print(f"SAWA STATE: {gs['sawaState']['status']} (Active: {gs['sawaState']['active']})")
            
        # Wait for bots to join and game to start
        print("Waiting for players and game start...")
        for i in range(10):
            if game_state['phase']: break
            time.sleep(1)
            print(".", end="")
        print("")
        
        if not game_state['phase']:
             print("Timeout: Game did not start.")
             return
        
        # Phase 1: Bidding
        # Just PASS until Play phase
        idx = 0
        while game_state['phase'] == 'BIDDING':
             if game_state['phase'] != 'BIDDING': break   
             
             if game_state['turn'] == 0:
                 print(f"My Turn (Bidding). Action: PASS. Phase: {game_state['phase']}")
                 SIO.emit('game_action', {'roomId': room_id, 'action': 'BID', 'payload': {'action': 'PASS'}})
                 time.sleep(1) # Wait longer after action
             time.sleep(0.5)
             
        # Phase 2: Playing
        print(f"Entered Phase: {game_state['phase']}. Waiting for my turn...")
        while True:
            # Check turn, phase, and Table Cards (must be empty to claim Sawa)
            # We need to access table cards. Game update gives us this.
            # But game_state dict only had phase/turn.
            pass
            if game_state['phase'] != 'PLAYING': break
            
            if game_state['turn'] == 0:
                 # Check if table is empty (we need to track this separately)
                 # Hack: Just try to call it. If it fails, wait for next turn? 
                 # But if I don't play, the game stalls.
                 # So I should play a card if Sawa fails.
                 
                 print("Attempting to CLAIM SAWA...")
                 res = SIO.call('game_action', {'roomId': room_id, 'action': 'SAWA'})
                 print(f"Sawa Result: {res}")
                 
                 if res and res.get('success'):
                     print("Sawa Claimed Successfully!")
                     break # Exit loop and wait for results
                 else:
                     print(f"Sawa Failed: {res}. Playing card to pass turn.")
                     # Play index 0
                     SIO.emit('game_action', {'roomId': room_id, 'action': 'PLAY', 'payload': {'cardIndex': 0}})
                     time.sleep(2) # Wait for others to play
            
            time.sleep(0.5)
        
        # Check if Sawa is active
        # We need to listen to the update. 
        # But to be robust, let's just assume we need to refuse/accept as bots.
        # Bots SHOULD auto-respond if logic is implemented.
        # Let's see if the server responds with a failure or update.
        
        print("Checking if Bots responded...")
        
        # Wait up to 10 seconds for resolution
        for i in range(20):
             state = game_state.get('sawaState', {})
             status = state.get('status')
             print(f"Wait {i}: Sawa Status: {status}")
             
             if status in ['ACCEPTED', 'REFUSED']:
                  print(f"Sawa Resolved! Status: {status}")
                  if status == 'REFUSED':
                       if state.get('challenge_active'):
                            print("Challenge Mode Activated (Expected).")
                       else:
                            print("Refused but no challenge? (Unexpected)")
                  break
             
             time.sleep(0.5)
             
        time.sleep(1)
        print("Test Complete. Check server logs for SAWA state.")
        
    except Exception as e:
        print(f"Error: {e}")
    finally:
        SIO.disconnect()

if __name__ == "__main__":
    verify_sawa()

```

### FILE: scripts\verification\verify_smart_bot.py
```py

import sys
import os
import logging

# Setup Path
sys.path.append(os.getcwd())

from ai_worker.agent import BotAgent
from game_engine.models.card import Card
from ai_worker.bot_context import BotContext

def test_smart_sahn():
    print("\n--- TEST: SMART SAHN (HOKUM) ---")
    agent = BotAgent()
    
    # Scene: I am Player 0 (Bottom), Bidder = Bottom. Mode = HOKUM.
    # Hand: High Trumps (J, 9, A) and some others.
    # Opponents: Have Trumps?
    
    # Case 1: Opponents have trumps -> SHOULD Sahn (Lead Trump)
    game_state_1 = {
        'players': [
            {'name': 'Bot', 'position': 'Bottom', 'team': 'us', 'hand': [{'rank': 'J', 'suit': '‚ô†'}, {'rank': '9', 'suit': '‚ô†'}, {'rank': 'A', 'suit': '‚ô•'}]},
            {'name': 'Right', 'position': 'Right', 'team': 'them', 'hand': []},
            {'name': 'Top', 'position': 'Top', 'team': 'us', 'hand': []},
            {'name': 'Left', 'position': 'Left', 'team': 'them', 'hand': []}
        ],
        'phase': 'PLAYING',
        'gameMode': 'HOKUM',
        'trumpSuit': '‚ô†',
        'dealerIndex': 1,
        'currentRoundTricks': [], # No tricks played yet
        'bid': {'type': 'HOKUM', 'suit': '‚ô†', 'bidder': 'Bottom'},
        'tableCards': []
    }
    
    decision = agent.get_decision(game_state_1, 0)
    print(f"Case 1 (Fresh Game): {decision}")
    
    if decision['action'] == 'PLAY' and decision['cardIndex'] in [0, 1]: # J or 9
         print("SUCCESS: Bot leads Trump (Sahn).")
    else:
         print(f"FAILURE: Bot did not lead trump. {decision}")

    # Case 2: Enemies are VOID in Trumps -> Should NOT Sahn (waste trumps)
    # How to simulate? Add past tricks where enemies did not follow trump lead.
    
    print("\n--- TEST: SMART SAHN (AVOID BLEEDING) ---")
    # Trick 1: Bottom Led 7‚ô† (Trump), Right Played ‚ô†, Top Played ‚ô†, Left Played ‚ô• (VOID!)
    # Trick 2: Bottom Led 8‚ô† (Trump), Right Played ‚ô¶ (VOID!), Top Played ‚ô†, Left Played ‚ô¶ (Still Void)
    # So Right and Left are Void in ‚ô†.
    
    trick_1 = {
        'winner': 'Bottom', 
        'cards': [
            {'rank': '7', 'suit': '‚ô†', 'playedBy': 'Bottom'},
            {'rank': 'K', 'suit': '‚ô•', 'playedBy': 'Right'}, # VOID IN SPADES
            {'rank': '8', 'suit': '‚ô†', 'playedBy': 'Top'},
            {'rank': 'Q', 'suit': '‚ô¶', 'playedBy': 'Left'} # VOID IN SPADES
        ]
    }
    
    game_state_2 = game_state_1.copy()
    game_state_2['currentRoundTricks'] = [trick_1]
    
    # Now Bot has J, 9. 
    # Should it lead J‚ô†? No, enemies are void. Playing J‚ô† just wastes it (unless to draw partner... but assume simple logic first).
    # Logic typically says: "Did I buy it? Yes. Should I open? Only if enemies have trumps."
    # Enemies (Left, Right) both showed void in trick 1.
    
    decision_2 = agent.get_decision(game_state_2, 0)
    print(f"Case 2 (Enemies Void): {decision_2}")
    
    # It should probably lead the Ace of Hearts (Index 2) or something else.
    if decision_2['action'] == 'PLAY' and decision_2['cardIndex'] == 2: # Ace Hearts
         print("SUCCESS: Bot switched to Non-Trump lead.")
    else:
         print(f"FAILURE: Bot persisted in leading trump? {decision_2}")


def test_void_avoidance():
    print("\n--- TEST: VOID AVOIDANCE ---")
    agent = BotAgent()
    
    # Scene: I have K‚ô•. Left is Void in ‚ô•. Mode = Hokum.
    # Leading K‚ô• is suicide (Left will cut).
    
    game_state = {
        'players': [
            {'name': 'Bot', 'position': 'Bottom', 'team': 'us', 'hand': [{'rank': 'K', 'suit': '‚ô•'}, {'rank': '7', 'suit': '‚ô£'}]},
            {'name': 'Right', 'position': 'Right', 'team': 'them', 'hand': []},
            {'name': 'Top', 'position': 'Top', 'team': 'us', 'hand': []},
            {'name': 'Left', 'position': 'Left', 'team': 'them', 'hand': []}
        ],
        'phase': 'PLAYING',
        'gameMode': 'HOKUM',
        'trumpSuit': '‚ô†',
        'currentRoundTricks': [
             {
                  'winner': 'Top',
                  'cards': [
                       {'rank': 'A', 'suit': '‚ô•', 'playedBy': 'Top'},
                       {'rank': '9', 'suit': '‚ô£', 'playedBy': 'Left'}, # Left Void in ‚ô•!
                       {'rank': '7', 'suit': '‚ô•', 'playedBy': 'Bottom'},
                       {'rank': '8', 'suit': '‚ô•', 'playedBy': 'Right'}
                  ]
             }
        ],
        'bid': {'type': 'HOKUM', 'suit': '‚ô†', 'bidder': 'Right'}, # Enemy bid
        'tableCards': [],
        'dealerIndex': 1 # Ensure dealer index is set
    }
    
    decision = agent.get_decision(game_state, 0)
    print(f"Void Case: {decision}")
    
    if decision['action'] == 'PLAY':
         # Index 0 is K‚ô• (Dangerous). Index 1 is 7‚ô£ (Safe).
         if decision['cardIndex'] == 1:
              print("SUCCESS: Bot avoided leading into Void (Void Avoidance).")
         elif decision['cardIndex'] == 0:
              print("FAILURE: Bot led K‚ô• despite Left being void!")

if __name__ == "__main__":
    test_smart_sahn()
    test_void_avoidance()

```

### FILE: scripts\verification\verify_strict_legality.py
```py

import sys
import os
import unittest

# Setup Path
sys.path.append(os.getcwd())

from ai_worker.bot_context import BotContext
from game_engine.models.card import Card

def create_mock_context(hand, table_cards, mode='HOKUM', trump='‚ô†', my_team='us'):
    # Mock Raw State
    raw_state = {
        'players': [
            {'position': 'Bottom', 'team': 'us', 'hand': [c.to_dict() for c in hand], 'name': 'Bot'},
            {'position': 'Right', 'team': 'them', 'hand': [], 'name': 'Right'},
            {'position': 'Top', 'team': 'us', 'hand': [], 'name': 'Top'},
            {'position': 'Left', 'team': 'them', 'hand': [], 'name': 'Left'}
        ],
        'phase': 'PLAYING',
        'gameMode': mode,
        'trumpSuit': trump,
        'tableCards': table_cards,
        'dealerIndex': 1,
        'bid': {'type': mode, 'suit': trump, 'bidder': 'Right'}
    }
    
    return BotContext(raw_state, 0)

class TestStrictLegality(unittest.TestCase):
    
    def test_must_follow_suit_hokum(self):
        print("\n--- TEST: Must Follow Suit (Hokum) ---")
        # I have [7‚ô† (Trump), K‚ô•].
        # Lead is 8‚ô† (Trump).
        # Must play 7‚ô†. K‚ô• is illegal.
        
        hand = [Card('‚ô†', '7'), Card('‚ô•', 'K')]
        # Lead: 8‚ô† (Enemy)
        table = [{'card': {'suit': '‚ô†', 'rank': '8'}, 'playedBy': 'Right'}]
        
        ctx = create_mock_context(hand, table, mode='HOKUM', trump='‚ô†')
        legal_indices = ctx.get_legal_moves()
        
        print(f"Hand: {hand}")
        print(f"Legal Indices: {legal_indices}")
        
        self.assertIn(0, legal_indices) # 7‚ô† is legal
        self.assertNotIn(1, legal_indices) # K‚ô• is illegal (Revoke)
        print("SUCCESS: Forced to follow Trump.")

    def test_must_trump_if_void(self):
        print("\n--- TEST: Must Trump if Void (Hokum) ---")
        # Lead: 7‚ô¶.
        # Hand: [K‚ô•, 7‚ô† (Trump)]. Void in Diamonds.
        # Enemy Winning? Yes (7‚ô¶ by Right).
        # Must Trump.
        
        hand = [Card('‚ô•', 'K'), Card('‚ô†', '7')]
        table = [{'card': {'suit': '‚ô¶', 'rank': '7'}, 'playedBy': 'Right'}]
        
        ctx = create_mock_context(hand, table, mode='HOKUM', trump='‚ô†')
        legal_indices = ctx.get_legal_moves()
        
        print(f"Hand: {hand}")
        print(f"Legal Indices: {legal_indices}")
        
        self.assertIn(1, legal_indices) # 7‚ô† (Trump) is legal
        self.assertNotIn(0, legal_indices) # K‚ô• is illegal (Refusing to trump)
        print("SUCCESS: Forced to Trump.")

    def test_partner_winning_exception(self):
        print("\n--- TEST: Partner Winning Exception (Hokum) ---")
        # Lead: 7‚ô¶. Winner: Top (Partner) with A‚ô¶.
        # Hand: [K‚ô•, 7‚ô† (Trump)]. Void in Diamonds.
        # Partner winning -> No need to trump. Can play K‚ô• (Trash).
        
        hand = [Card('‚ô•', 'K'), Card('‚ô†', '7')]
        table = [
             {'card': {'suit': '‚ô¶', 'rank': '7'}, 'playedBy': 'Right'}, 
             {'card': {'suit': '‚ô¶', 'rank': 'A'}, 'playedBy': 'Top'}
        ] 
        
        ctx = create_mock_context(hand, table, mode='HOKUM', trump='‚ô†')
        legal_indices = ctx.get_legal_moves()
        
        print(f"Hand: {hand}")
        print(f"Legal Indices: {legal_indices}")
        
        self.assertIn(0, legal_indices) # K‚ô• is legal
        self.assertIn(1, legal_indices) # 7‚ô† is legal (Can trump if I want, but not forced)
        print("SUCCESS: Partner winning allows played non-trump.")

    def test_must_overtrump(self):
        print("\n--- TEST: Must Over-Trump (Hokum) ---")
        # Lead: 7‚ô¶.
        # Right Trumps with 7‚ô†.
        # I have [8‚ô† (Higher Trump), 9‚ô¶ (Match Suit?? No void), K‚ô•].
        # Wait, if I have 9‚ô¶, I MUST follow suit.
        # Scenario: Void in Diamonds.
        # Hand: [8‚ô† (Trump), 7‚ô£].
        # Right (Enemy) played 7‚ô† (Trump).
        # I Must Overtrump with 8‚ô†? Or can I play 7‚ô£?
        # Rule: If enemy trumps, you must overtrump if possible. If not possible, play any card?
        # Usually: Must overtrump. If cannot overtrump, play any card (even small trump allowed? Or any suit?)
        # Let's check logic: (is_move_legal lines 114-121)
        
        hand = [Card('‚ô†', '8'), Card('‚ô£', '7')]
        table = [
             {'card': {'suit': '‚ô¶', 'rank': '7'}, 'playedBy': 'Left'}, # Lead
             {'card': {'suit': '‚ô†', 'rank': '7'}, 'playedBy': 'Right'} # Enemy Trumped
        ]
        
        ctx = create_mock_context(hand, table, mode='HOKUM', trump='‚ô†')
        legal_indices = ctx.get_legal_moves()
        
        print(f"Hand: {hand}")
        print(f"Legal Indices: {legal_indices}")
        
        self.assertIn(0, legal_indices) # 8‚ô† (Overtrump) is legal
        self.assertNotIn(1, legal_indices) # 7‚ô£ (undertrumping/escaping when overtrump valid) -> Illegal?
        # Logic line 110: if card.suit != trump: return False.
        # So I MUST play trump if I have it.
        # So 7‚ô£ is illegal.
        print("SUCCESS: Forced to Over-Trump.")

if __name__ == "__main__":
    unittest.main()

```

### FILE: scripts\verification\verify_timers.py
```py

import time
import sys
import os

# Add root to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import logging
logging.basicConfig(level=logging.INFO)

from server.game_logic import Game, GamePhase, Card

def test_timers():
    print("Testing Timers...")
    
    # 1. Bidding Timeout
    print("[1] Testing Bidding Timeout...")
    g = Game("test_timer_room")
    for i in range(4):
        g.add_player(f"p{i}", f"Player {i}")
    g.start_game()
    g.turn_duration = 2
    
    # Start -> Phase=BIDDING, Turn=1 (Random dealer logic may vary but start_game sets turn)
    # Start -> Phase=BIDDING, Turn=1 (Random dealer logic may vary but start_game sets turn)
    current = g.current_turn
    g.reset_timer(2)
    # Manually expire
    g.timer.start_time = time.time() - 5 
    
    res = g.check_timeout()
    if res and res.get('success'):
        if g.players[current].action_text == "PASS":
            print("  PASS Success: Player passed automatically.")
        else:
            print(f"  FAIL: Action text is {g.players[current].action_text}")
    else:
        print(f"  FAIL: No result from check_timeout. Active={g.timer.active}")

    # 2. Playing Timeout
    print("[2] Testing Playing Timeout (Auto-Play Weakest)...")
    g.phase = GamePhase.PLAYING.value
    g.current_turn = 0
    p0 = g.players[0]
    # Hand: Ace (11) and 7 (0)
    p0.hand = [Card('‚ô†', 'A'), Card('‚ô•', '7')]
    # Mock table to make 7 valid (Empty table = any card valid)
    g.table_cards = []
    
    g.reset_timer()
    g.timer.start_time = time.time() - 50 # Expire
    
    res = g.check_timeout()
    
    if res and res.get('success'):
        if len(g.table_cards) == 1:
            card = g.table_cards[0]['card']
            print(f"  Played Card: {card.rank}{card.suit}")
            if card.rank == '7':
                print("  PASS Success: Weakest card (7) played.")
            else:
                print(f"  FAIL: Wrong card played ({card.rank})")
        else:
            print("  FAIL: No card on table")
    else:
        print("  FAIL: No result from check_timeout")

    # 3. Robustness Test (Bot Crash)
    print("[3] Testing Bot Crash Resilience...")
    g.phase = GamePhase.PLAYING.value
    g.current_turn = 0
    p0 = g.players[0]
    p0.hand = [Card('‚ô†', 'A'), Card('‚ô•', '7')]
    g.table_cards = [] 
    
    # Mock bot agent to fail
    from server import bot_agent
    original_decision = bot_agent.bot_agent.get_decision
    def crash_decision(*args):
        raise Exception("Simulated Bot Crash")
    bot_agent.bot_agent.get_decision = crash_decision
    
    g.reset_timer()
    g.timer.start_time = time.time() - 50
    
    res = g.check_timeout()
    if res and res.get('success'):
        print("  PASS Success: Fallback logic handled crash.")
    else:
        print(f"  FAIL: Crash caused failure: {res}")
        
    # Restore
    bot_agent.bot_agent.get_decision = original_decision

if __name__ == "__main__":
    try:
        test_timers()
        print("Done.")
    except Exception as e:
        print(f"CRITICAL ERROR: {e}")
        import traceback
        traceback.print_exc()

```

### FILE: scripts\verification\verify_time_lord.py
```py

import sys
import os
import requests
import json
import time

# Verify Time Lord (Partial Forking)

SERVER_URL = "http://localhost:3005"

def verify_time_lord():
    print("--- Verifying Time Lord (Partial Forking) ---")
    
    # 1. Start a Game to Generate History OR Use Existing?
    # Hard to guarantee history with just API. 
    # Let's import server code? No, let's look for a game in DB.
    
    print("1. Fetching recent games...")
    print("1. Fetching recent games...")
    try:
        res = requests.get(f"{SERVER_URL}/react-py4web/replay/list")
        if res.status_code != 200:
            print("FAIL: Could not fetch replay list")
            print(res.text)
            exit(1)
            
        data = res.json()
        matches = data.get('matches', [])
        
        if not matches:
            print("WARN: No matches found in archive. Cannot verify without game history.")
            # TODO: We should probably simulate a game first if none exist.
            print("Please play a game first or use verify_game_flow.py")
            return
            
        target_game_id = matches[0]['gameId']
        print(f"Targeting Game: {target_game_id}")
        
    except Exception as e:
        print(f"FAIL: Network error: {e}")
        exit(1)

    # 2. Replay Fork Request (Mocking Partial Trick)
    # Let's assume Round 1, Trick 0, Move 2 (2 cards played)
    print("2. Forking at Round 1, Trick 0, Move 2...")
    
    payload = {
        "gameId": target_game_id,
        "roundNum": 1,
        "trickIndex": 0,
        "movesInTrick": 2 
    }
    
    try:
        res = requests.post(f"{SERVER_URL}/react-py4web/replay/fork", json=payload)
        data = res.json()
        
        if not data.get('success'):
            print(f"FAIL: Fork rejected: {data.get('error')}")
            # If error is about invalid IDs/rounds, it might be expected if game was empty.
            # But we want to fail loudly if logic is broken.
            exit(1)
            
        new_game_id = data['newGameId']
        print(f"Success! New Game ID: {new_game_id}")
        
        # 3. Verify State of New Game
        # We need to peek into the game state. 
        # Using /game_state/{id} ? No such public endpoint usually? 
        # Wait, frontend uses socket or polling. 
        # Let's assume we can fetch it via room_manager logic or if there is a debug endpoint.
        # Ideally, we should add a tiny debug endpoint or use python import.
        
    except Exception as e:
        print(f"FAIL: Fork Request Failed: {e}")
        exit(1)
        
    print("--- VERIFICATION PASSED ‚úÖ ---")

if __name__ == "__main__":
    verify_time_lord()

```

### FILE: scripts\verification\verify_yolo_logger.py
```py

import os
import shutil
import logging
import sys

# Fix Path
sys.path.append(os.getcwd())

from ai_worker.learning.dataset_logger import DatasetLogger
from ai_worker.bot_context import BotContext

def verify_yolo():
    print("--- Verifying YOLO Logger ---")
    data_dir = "ai_worker/data/test_yolo"
    
    # Clean up previous run
    if os.path.exists(data_dir):
        shutil.rmtree(data_dir)
    
    # 1. Init Logger (Low buffer for testing)
    logger = DatasetLogger(data_dir=data_dir, min_confidence=0.80, buffer_size=2)
    print(f"Logger initialized in {data_dir}")
    
    # 2. Mock Context (Minimal)
    class MockCard:
        def __init__(self, suit, rank):
            self.suit = suit
            self.rank = rank
        def __str__(self): return f"{self.suit}{self.rank}"
        
    class MockContext:
        def __init__(self):
            self.mode = "SUN"
            # Use 'S' for Spades etc? FeatureExtractor usually handles standard constants.
            # Let's assume constants match.
            self.hand = [MockCard("‚ô†", "7"), MockCard("‚ô•", "A"), MockCard("‚ô¶", "10")]
            self.raw_state = {"gameId": "test_game_123"}
            self.trump = None
            self.lead_suit = None
            self.table_cards = []
            
            # Mock Memory for extractor dependency?
            self.memory = type('obj', (object,), {'discards': {}, 'played_cards': []})
            
    ctx = MockContext()
    
    # 3. Test: Low Confidence (Should NOT log)
    print("Test 1: Low Confidence Move (0.50)")
    details_low = {0: {'win_rate': 0.50, 'visits': 100}}
    logger.log_sample(ctx, 0, details_low)
    
    # Check buffer (Should be empty)
    if len(logger.buffer) != 0:
        print(f"FAIL: Buffer should be empty, has {len(logger.buffer)}")
        return
        
    # 4. Test: High Confidence (Should log)
    print("Test 2: High Confidence Move (0.90)")
    details_high = {1: {'win_rate': 0.90, 'visits': 1000}}
    logger.log_sample(ctx, 1, details_high)
    
    if len(logger.buffer) != 1:
        print(f"FAIL: Buffer should have 1 item, has {len(logger.buffer)}")
        return
        
    # 5. Test: Flush
    print("Test 3: Buffer Flush (adding 2nd item)")
    # Must use index 2 in details, or reuse index 1 in call?
    # Let's add key 2 to details dict or separate details
    details_flush = {2: {'win_rate': 0.95, 'visits': 1200}}
    logger.log_sample(ctx, 2, details_flush) # Buffer size is 2, should flush now
    
    if len(logger.buffer) != 0:
        print(f"FAIL: Buffer should be empty after flush, has {len(logger.buffer)}")
        return
        
    # 6. Verify File
    file_path = os.path.join(data_dir, "yolo_dataset.jsonl")
    if not os.path.exists(file_path):
        print("FAIL: Output file not created")
        return
        
    with open(file_path, 'r') as f:
        lines = f.readlines()
        print(f"Success! File created with {len(lines)} records.")
        print("Sample Record:", lines[0].strip())
        
    print("--- VERIFICATION PASSED ‚úÖ ---")

if __name__ == "__main__":
    verify_yolo()

```

### FILE: server\academy_controllers.py
```py
import os
import json
import glob
from py4web import action, request, response, abort
from server.puzzle_schema import Puzzle
from server.logging_utils import logger

# Base directory for puzzles
# Assuming this file is in server/academy_controllers.py
# Puzzles are in server/content/puzzles
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
PUZZLE_DIR = os.path.join(BASE_DIR, 'content', 'puzzles')

@action('academy/puzzles', method=['GET', 'OPTIONS'])
def list_puzzles():
    response.headers['Access-Control-Allow-Origin'] = '*'
    response.headers['Access-Control-Allow-Methods'] = 'GET, OPTIONS'
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'

    if request.method == 'OPTIONS':
        return ""

    logger.debug("[Academy] Listing puzzles...")
    puzzles = []
    # Find all .json files in PUZZLE_DIR
    search_path = os.path.join(PUZZLE_DIR, '*.json')
    files = glob.glob(search_path)

    for fpath in files:
        try:
            with open(fpath, 'r', encoding='utf-8') as f:
                data = json.load(f)
                # Lite validation/parsing
                # We return a summary
                puzzles.append({
                    "id": data.get('id'),
                    "title": data.get('title'),
                    "difficulty": data.get('difficulty'),
                    "tags": data.get('tags', [])
                })
        except Exception as e:
            logger.error(f"[Academy] Error loading puzzle {fpath}: {e}")

    logger.debug(f"[Academy] Found {len(puzzles)} puzzles.")
    return {"puzzles": puzzles}


@action('academy/puzzles/<puzzle_id>', method=['GET', 'OPTIONS'])
def get_puzzle(puzzle_id):
    response.headers['Access-Control-Allow-Origin'] = '*'
    response.headers['Access-Control-Allow-Methods'] = 'GET, OPTIONS'
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'

    if request.method == 'OPTIONS':
        return ""

    logger.info(f"[Academy] Fetching puzzle: {puzzle_id}")
    # Sanitize puzzle_id to prevent directory traversal
    safe_id = "".join([c for c in puzzle_id if c.isalnum() or c in ('_', '-')])
    fpath = os.path.join(PUZZLE_DIR, f"{safe_id}.json")

    if not os.path.exists(fpath):
        logger.warning(f"[Academy] Puzzle not found: {fpath}")
        response.status = 404
        return {"error": "Puzzle not found"}

    try:
        with open(fpath, 'r', encoding='utf-8') as f:
            data = json.load(f)
            # Ensure strictly follows schema (optional)
            puzzle = Puzzle.from_dict(data)
            # Return raw data for now as dataclass json serialization might need helper
            return {"puzzle": data} 
    except Exception as e:
        logger.error(f"[Academy] Failed to load puzzle {puzzle_id}: {str(e)}")
        response.status = 500
        return {"error": f"Failed to load puzzle: {str(e)}"}

@action('academy/verify', method=['POST', 'OPTIONS'])
def verify_solution():
    response.headers['Access-Control-Allow-Origin'] = '*'
    response.headers['Access-Control-Allow-Methods'] = 'POST, OPTIONS'
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'

    if request.method == 'OPTIONS':
        return ""

    data = request.json
    puzzle_id = data.get('puzzleId')
    user_moves = data.get('moves', []) # List of card strings e.g. ["KH"]
    logger.info(f"[Academy] Verifying solution for {puzzle_id}. Moves: {user_moves}")

    if not puzzle_id or not user_moves:
        return {"error": "Invalid payload"}

    # Load Puzzle
    safe_id = "".join([c for c in puzzle_id if c.isalnum() or c in ('_', '-')])
    fpath = os.path.join(PUZZLE_DIR, f"{safe_id}.json")
    
    if not os.path.exists(fpath):
        return {"error": "Puzzle not found"}

    with open(fpath, 'r', encoding='utf-8') as f:
        pdata = json.load(f)
    
    solution = pdata.get('solution', {})
    
    success = False
    message = "Incorrect sequence."

    if solution.get('type') == 'sequence':
        expected = solution.get('data', [])
        # Simple strict equality check for sequence
        # We might want prefix checking (if user is mid-sequence) but usually verification is at end?
        # Or per-move?
        # Let's assume this is "Check Full Solution"
        if user_moves == expected:
            success = True
            message = "Correct!"
        else:
            # Check partial
            if len(user_moves) <= len(expected):
                if user_moves == expected[:len(user_moves)]:
                     success = True
                     message = "Good move, keep going..."
                else:
                     message = f"Wrong move. Expected {expected[len(user_moves)-1]} but got {user_moves[-1]}."
    
    logger.info(f"[Academy] Verification result: {success} ({message})")
    return {"success": success, "message": message}

```

### FILE: server\application.py
```py

import os
import sys
import socketio
from py4web.core import bottle
from server.socket_handler import sio, timer_background_task
from server.room_manager import room_manager
from server.core_patch import apply_py4web_patches

def create_app():
    """
    Factory function to create and configure the WSGI application.
    """
    # 1. Path Safety
    if os.getcwd() not in sys.path:
        sys.path.append(os.getcwd())

    # 2. Apply Patches
    apply_py4web_patches()

    # 2.5 Clear Stale Games (Dev Mode)
    try:
        room_manager.clear_all_games()
    except Exception as e:
        print(f"Warning: Failed to clear games: {e}")

    # 3. Import Controllers (Register Routes)
    # Patches must be applied BEFORE imports
    try:
        import server.models # Ensure tables are defined
        import server.controllers 
        import server.academy_controllers
        import server.controllers_replay
        
    except Exception as e:
        with open("logs/routes_dump.txt", "a") as f:
            f.write(f"CRITICAL: Failed to import controllers: {e}\n")
            import traceback
            f.write(traceback.format_exc())
        raise

    # 4. Create WSGI App
    wsgi_app = bottle.default_app()
    
    # 5. Explicit Binding (Idempotent)
    server.controllers_replay.bind(wsgi_app)
    server.controllers.bind(wsgi_app)
    
    # 6. SocketIO Setup
    def prefix_middleware(environ, start_response):
        path = environ.get('PATH_INFO', '')
        if path.startswith('/react-py4web'):
            environ['PATH_INFO'] = path[len('/react-py4web'):] or '/'
        return wsgi_app(environ, start_response)

    ws_app = socketio.WSGIApp(sio, prefix_middleware)
    
    # 7. Start Background Tasks
    sio.start_background_task(timer_background_task, room_manager)
    
    return ws_app

```

### FILE: server\auth_utils.py
```py
import jwt
import time
import os
import server.settings as settings

# Use settings.SESSION_SECRET_KEY if available, otherwise fallback or env
SECRET_KEY = settings.SESSION_SECRET_KEY or os.environ.get('JWT_SECRET', 'dev-secret-key-change-in-prod')

def generate_token(user_id, email, first_name, last_name):
    """
    Generate a new JWT token for the user.
    """
    payload = {
        "user_id": user_id,
        "email": email,
        "first_name": first_name,
        "last_name": last_name,
        "exp": time.time() + (24 * 3600)  # 24 Hour Expiry
    }
    return jwt.encode(payload, SECRET_KEY, algorithm="HS256")

def verify_token(token):
    """
    Verify the JWT token and return the payload if valid.
    Returns None if invalid or expired.
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        return payload
    except jwt.ExpiredSignatureError:
        return None  # Handle expiry
    except jwt.InvalidTokenError:
        return None

```

### FILE: server\bot_orchestrator.py (SKIPPED - >10KB)
### FILE: server\common.py
```py
"""
This file defines cache, session, and translator T object for the app
These are fixtures that every app needs so probably you will not be editing this file
"""
import os
import sys
import logging
from py4web import Session, Cache, Translator, Flash, DAL, Field, action
from py4web.utils.mailer import Mailer
from py4web.utils.auth import Auth
from py4web.utils.downloader import downloader
from pydal.tools.tags import Tags
from py4web.utils.factories import ActionFactory
import server.settings as settings

# #######################################################
# implement custom loggers form settings.LOGGERS
# #######################################################
logger = logging.getLogger("py4web:" + settings.APP_NAME)
formatter = logging.Formatter(
    "%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s"
)
for item in settings.LOGGERS:
    level, filename = item.split(":", 1)
    if filename in ("stdout", "stderr"):
        handler = logging.StreamHandler(getattr(sys, filename))
    else:
        handler = logging.FileHandler(filename)
    handler.setFormatter(formatter)
    logger.setLevel(getattr(logging, level.upper(), "DEBUG"))
    logger.addHandler(handler)

# #######################################################
# connect to db
# #######################################################
db = DAL(
    settings.DB_URI,
    folder=settings.DB_FOLDER,
    pool_size=settings.DB_POOL_SIZE,
    migrate=settings.DB_MIGRATE,
    fake_migrate=settings.DB_FAKE_MIGRATE,
)

# #######################################################
# connect to redis (shared client)
# #######################################################
redis_client = None
try:
    import redis
    redis_client = redis.from_url(settings.REDIS_URL, decode_responses=True)
    redis_store = redis.from_url(settings.REDIS_URL, decode_responses=False)
except Exception as e:
    logger.error(f"Failed to initialize shared Redis client: {e}")
    redis_store = None


# #######################################################
# define global objects that may or may not be used by the actions
# #######################################################
cache = Cache(size=1000)
T = Translator(settings.T_FOLDER)

# #######################################################
# pick the session type that suits you best
# #######################################################
if settings.SESSION_TYPE == "cookies":
    session = Session(secret=settings.SESSION_SECRET_KEY)
elif settings.SESSION_TYPE == "redis":
    import redis

    host, port = settings.REDIS_SERVER.split(":")
    # for more options: https://github.com/andymccurdy/redis-py/blob/master/redis/client.py
    conn = redis.Redis(host=host, port=int(port))
    conn.set = (
        lambda k, v, e, cs=conn.set, ct=conn.ttl: cs(k, v, ct(k))
        if ct(k) >= 0
        else cs(k, v, e)
    )
    session = Session(secret=settings.SESSION_SECRET_KEY, storage=conn)
elif settings.SESSION_TYPE == "memcache":
    import memcache, time

    conn = memcache.Client(settings.MEMCACHE_CLIENTS, debug=0)
    session = Session(secret=settings.SESSION_SECRET_KEY, storage=conn)
elif settings.SESSION_TYPE == "database":
    from py4web.utils.dbstore import DBStore

    session = Session(secret=settings.SESSION_SECRET_KEY, storage=DBStore(db))

# #######################################################
# Instantiate the object and actions that handle auth
# #######################################################
# auth = Auth(session, db, define_tables=False)
# auth.use_username = True
# auth.param.registration_requires_confirmation = settings.VERIFY_EMAIL
# auth.param.registration_requires_approval = settings.REQUIRES_APPROVAL
# auth.param.login_after_registration = settings.LOGIN_AFTER_REGISTRATION
# auth.param.allowed_actions = settings.ALLOWED_ACTIONS
# auth.param.login_expiration_time = 3600
# auth.param.password_complexity = {"entropy": 50}
# auth.param.block_previous_password_num = 3
# auth.param.default_login_enabled = settings.DEFAULT_LOGIN_ENABLED
# auth.define_tables()
# auth.fix_actions()

# flash = auth.flash

# #######################################################
# Configure email sender for auth
# #######################################################
# if settings.SMTP_SERVER:
#     auth.sender = Mailer(
#         server=settings.SMTP_SERVER,
#         sender=settings.SMTP_SENDER,
#         login=settings.SMTP_LOGIN,
#         tls=settings.SMTP_TLS,
#         ssl=settings.SMTP_SSL,
#     )

# #######################################################
# Create a table to tag users as group members
# #######################################################
# if auth.db:
#     groups = Tags(db.auth_user, "groups")

# #######################################################
# Enable optional auth plugin
# #######################################################
# if settings.USE_PAM:
#     from py4web.utils.auth_plugins.pam_plugin import PamPlugin

#     auth.register_plugin(PamPlugin())

# if settings.USE_LDAP:
#     from py4web.utils.auth_plugins.ldap_plugin import LDAPPlugin

#     auth.register_plugin(LDAPPlugin(db=db, groups=groups, **settings.LDAP_SETTINGS))

# if settings.OAUTH2GOOGLE_CLIENT_ID:
#     from py4web.utils.auth_plugins.oauth2google import OAuth2Google  # TESTED

#     auth.register_plugin(
#         OAuth2Google(
#             client_id=settings.OAUTH2GOOGLE_CLIENT_ID,
#             client_secret=settings.OAUTH2GOOGLE_CLIENT_SECRET,
#             callback_url="auth/plugin/oauth2google/callback",
#         )
#     )

# if settings.OAUTH2GOOGLE_SCOPED_CREDENTIALS_FILE:
#     from py4web.utils.auth_plugins.oauth2google_scoped import OAuth2GoogleScoped # TESTED

#     auth.register_plugin(
#         OAuth2GoogleScoped(
#             secrets_file=settings.OAUTH2GOOGLE_SCOPED_CREDENTIALS_FILE,
#             scopes=[], # Put here any scopes you want in addition to login
#             db=db, # Needed to store credentials in auth_credentials
#         )
#     )

# if settings.OAUTH2GITHUB_CLIENT_ID:
#     from py4web.utils.auth_plugins.oauth2github import OAuth2Github  # TESTED

#     auth.register_plugin(
#         OAuth2Github(
#             client_id=settings.OAUTH2GITHUB_CLIENT_ID,
#             client_secret=settings.OAUTH2GITHUB_CLIENT_SECRET,
#             callback_url="auth/plugin/oauth2github/callback",
#         )
#     )

# if settings.OAUTH2FACEBOOK_CLIENT_ID:
#     from py4web.utils.auth_plugins.oauth2facebook import OAuth2Facebook  # UNTESTED

#     auth.register_plugin(
#         OAuth2Facebook(
#             client_id=settings.OAUTH2FACEBOOK_CLIENT_ID,
#             client_secret=settings.OAUTH2FACEBOOK_CLIENT_SECRET,
#             callback_url="auth/plugin/oauth2facebook/callback",
#         )
#     )

# if settings.OAUTH2OKTA_CLIENT_ID:
#     from py4web.utils.auth_plugins.oauth2okta import OAuth2Okta  # TESTED

#     auth.register_plugin(
#         OAuth2Okta(
#             client_id=settings.OAUTH2OKTA_CLIENT_ID,
#             client_secret=settings.OAUTH2OKTA_CLIENT_SECRET,
#             callback_url="auth/plugin/oauth2okta/callback",
#         )
#     )

# #######################################################
# Define a convenience action to allow users to download
# files uploaded and reference by Field(type='upload')
# #######################################################
if settings.UPLOAD_FOLDER:
    try:
        @action('download/<filename>')
        @action.uses(db)
        def download(filename):
            return downloader(db, settings.UPLOAD_FOLDER, filename)
    except TypeError:
        # Fails if imported as top-level module (e.g. CLI scripts) due to py4web module2filename bug
        pass
    # To take advantage of this in Form(s)
    # for every field of type upload you MUST specify:
    #
    # field.upload_path = settings.UPLOAD_FOLDER
    # field.download_url = lambda filename: URL('download/%s' % filename)

# #######################################################
# Optionally configure celery
# #######################################################
if settings.USE_CELERY:
    from celery import Celery

    # to use "from .common import scheduler" and then use it according
    # to celery docs, examples in tasks.py
    scheduler = Celery(
        "apps.%s.tasks" % settings.APP_NAME, broker=settings.CELERY_BROKER
    )


# #######################################################
# Enable authentication
# #######################################################
# auth.enable(uses=(session, T, db), env=dict(T=T))

# #######################################################
# Define convenience decorators
# #######################################################
# unauthenticated = ActionFactory(db, session, T, flash, auth)
# authenticated = ActionFactory(db, session, T, flash, auth.user)

```

### FILE: server\controllers.py (SKIPPED - >10KB)
### FILE: server\controllers_replay.py (SKIPPED - >10KB)
### FILE: server\core_patch.py
```py

import os
from py4web import core

def apply_py4web_patches():
    """
    Applies necessary monkey-patches to py4web to support
    top-level execution and custom environment paths.
    """
    def safe_module2filename(module):
        try:
            # If it's a top-level module (no dots), just return the name
            if '.' not in module:
                return module + ".py"
            # Otherwise use original logic: os.path.join(*module.split(".")[1:])
            parts = module.split(".")[1:]
            if not parts:
                return module + ".py"
            return os.path.join(*parts)
        except:
            return module
            
    # Apply Patch
    core.module2filename = safe_module2filename

```

### FILE: server\game_logger.py (SKIPPED - >10KB)
### FILE: server\game_logic.py
```py
# Facade for backward compatibility
from game_engine.models.constants import *
from game_engine.models.card import Card
from game_engine.models.player import Player
from game_engine.models.deck import Deck
from game_engine.logic.utils import sort_hand, scan_hand_for_projects, validate_project, compare_projects, add_sequence_project
from game_engine.logic.game import Game

```

### FILE: server\logging_utils.py
```py
import logging
import json
import time
import os

# Ensure logs directory exists
LOG_DIR = "logs"
os.makedirs(LOG_DIR, exist_ok=True)
LOG_FILE = os.path.join(LOG_DIR, "server_manual.log")

# Configure standard logger
# We use a FileHandler to ensure logs persist even if stdout is captured/redirected elsewhere
file_handler = logging.FileHandler(LOG_FILE, encoding='utf-8')
file_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))

console_handler = logging.StreamHandler()
console_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))

logger = logging.getLogger("GameServer")
logger.setLevel(logging.INFO)
logger.addHandler(file_handler)
logger.addHandler(console_handler)

def log_event(event_type: str, game_id: str = "GLOBAL", player_index: int = -1, details: dict = None):
    """
    Log a structured event for game analysis.
    Output: JSON string tagged with [EVENT].
    """
    if details is None: details = {}
    
    payload = {
        "event": event_type,
        "game_id": game_id,
        "timestamp": time.time(),
        "details": details
    }
    
    if player_index >= 0:
        payload["player_index"] = player_index

    # Use a specific marker for easy parsing
    logger.info(f"[EVENT] {json.dumps(payload)}")

def log_error(game_id: str, error_msg: str, context: dict = None):
    logger.error(f"[ERROR] Game: {game_id} | Msg: {error_msg} | Context: {context}")

```

### FILE: server\main.py
```py
import os
import sys

# Ensure project root is in sys.path
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(current_dir)
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from gevent import monkey; monkey.patch_all()
from gevent import pywsgi
from geventwebsocket.handler import WebSocketHandler
from server.application import create_app

def run():
    print("Starting Python Game Server on port 3005 (Gevent)...")
    
    try:
        app = create_app()
        server = pywsgi.WSGIServer(('0.0.0.0', 3005), app, handler_class=WebSocketHandler)
        server.serve_forever()
        
    except Exception as e:
        import traceback
        with open("logs/crash.log", "a") as f:
             f.write(f"CRITICAL CRASH in serve_forever: {e}\n")
             f.write(traceback.format_exc())
        print(f"CRITICAL CRASH: {e}")
        raise

if __name__ == '__main__':
    run()

```

### FILE: server\models.py
```py
"""
This file defines the database models
"""

from server.common import db, Field
from pydal.validators import *
import datetime

### Define your table below
#
# db.define_table('thing', Field('name'))
#
## always commit your models to avoid problems later
#
# db.commit()
#
# Define the user table (using default auth or matching legacy foo for now)
db.define_table('app_user',
                Field('first_name', required=True),
                Field('last_name', required=True),
                Field('email', unique=True, required=True),
                Field('password', 'password', readable=False, required=True),
                Field('league_points', 'integer', default=1000),
                )

# Define game results table
db.define_table('game_result',
                Field('user_email'), # Simple linkage for now
                Field('score_us', 'integer'),
                Field('score_them', 'integer'),
                Field('is_win', 'boolean'),
                Field('timestamp', 'datetime', default=lambda: datetime.datetime.now())
                )

# Define bot training data table
db.define_table('bot_training_data',
                Field('context_hash', required=True), # Unique hash of the game state
                Field('game_state_json', 'text'),     # Full snapshot for replay
                Field('bad_move_json', 'text'),       # The move the bot wanted to make
                Field('correct_move_json', 'text'),   # The move the user corrected it to
                Field('reason', 'text'),              # User's explanation
                Field('image_filename', 'string'),    # Link to source screenshot (Data Flywheel)
                Field('created_on', 'datetime', default=lambda: datetime.datetime.now())
                )

# Define match archive for Replay Studio
db.define_table('match_archive',
                Field('game_id', unique=True, required=True),
                Field('user_email'), # Optional linkage
                Field('history_json', 'text'), # Full JSON blob
                Field('final_score_us', 'integer'),
                Field('final_score_them', 'integer'),
                Field('timestamp', 'datetime', default=lambda: datetime.datetime.now())
                )

db.commit()
```

### FILE: server\puzzle_schema.py
```py
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional

@dataclass
class PuzzleSolution:
    type: str  # "sequence", "goal_score", "win_trick"
    data: Any  # List of move strings, or target score, etc.

@dataclass
class Puzzle:
    id: str
    title: str
    description: str
    difficulty: str  # "Beginner", "Intermediate", "Advanced"
    initial_state_json: Dict[str, Any]
    solution: PuzzleSolution
    tags: List[str] = field(default_factory=list)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Puzzle':
        return cls(
            id=data.get('id', ''),
            title=data.get('title', 'Untitled'),
            description=data.get('description', ''),
            difficulty=data.get('difficulty', 'Beginner'),
            initial_state_json=data.get('initial_state', {}),
            solution=PuzzleSolution(
                type=data.get('solution', {}).get('type', 'sequence'),
                data=data.get('solution', {}).get('data', [])
            ),
            tags=data.get('tags', [])
        )

```

### FILE: server\rate_limiter.py
```py
import time
import logging
from server.common import redis_client

logger = logging.getLogger(__name__)

class RateLimiter:
    """
    Simple Redis-based Rate Limiter using Fixed Window Counter.
    Fails OPEN (allows request) if Redis is unavailable.
    """
    def __init__(self, key_prefix="rl"):
        self.redis = redis_client
        self.prefix = key_prefix

    def check_limit(self, key: str, limit: int, window: int) -> bool:
        """
        Check if an action is allowed.
        :param key: Unique identifier (e.g., user_id or remote_addr)
        :param limit: Max requests allowed in the window
        :param window: Time window in seconds
        :return: True if allowed, False if limit exceeded
        """
        if not self.redis: 
            return True 
        
        # Key specific to the current time window
        # e.g. rl:create_room:127.0.0.1:17000000
        current_window = int(time.time() // window)
        full_key = f"{self.prefix}:{key}:{current_window}"
        
        try:
            # Atomic INCR
            count = self.redis.incr(full_key)
            
            # Set expiry on first access
            if count == 1:
                self.redis.expire(full_key, window + 5) # +5 buffer
            
            if count > limit:
                logger.warning(f"Rate Limit Exceeded: {key} ({count}/{limit})")
                return False
                
            return True
            
        except Exception as e:
            logger.error(f"RateLimiter Error: {e}")
            return True # Fail open to ensure availability

# Global Instances for convenience
limiter = RateLimiter()

```

### FILE: server\README.md
```md
# Server Package üñ•Ô∏è

This directory contains the Python backend code for the Baloot game server.

## Key Components

- **`socket_handler.py`**: The core event listener for Socket.IO. Handles all real-time game events (`join_game`, `make_bid`, `play_card`).
- **`room_manager.py`**: Manages active game instances.
- **`controllers.py`**: py4web HTTP controllers for REST API endpoints (e.g., specific game data queries).
- **`models.py`**: Database definitions (py4web DAL).
- **`game_logic.py`**: A facade that re-exports `game_engine` components for legacy compatibility.
- **`logging_utils.py`**: Centralized logging configuration.

## Circular Dependency Warning ‚ö†Ô∏è

**Do NOT import `room_manager` in `__init__.py`!**
The `room_manager` imports `game_logic`, which imports `game_engine`, which imports `trick_manager`, which imports `logging_utils` (which is in `server` package). If `__init__.py` imports `room_manager`, this cycle crashes the server.

Explicitly import `room_manager` only where needed (e.g., inside functions or in `run_game_server.py`).

```

### FILE: server\room_manager.py
```py
from game_engine.logic.game import Game
import uuid
import pickle
import logging
import os
from server.common import redis_client, redis_store

logger = logging.getLogger(__name__)

class RoomManager:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(RoomManager, cls).__new__(cls)
            # Memory cache for very hot access (optional, but good for performance)
            # key: room_id, value: { 'game': Game, 'timestamp': time }
            cls._instance._local_cache = {} 
        return cls._instance

    def create_room(self):
        room_id = str(uuid.uuid4())[:8]
        game = Game(room_id)
        self.save_game(game)
        logger.info(f"Created room {room_id} (Persisted to Redis)")
        return room_id

    def get_game(self, room_id):
        # PID used for process isolation tracking
        pid = os.getpid()
        if not room_id: return None
        
        # 1. Try Redis (Primary Truth)
        try:
            if redis_store:
                data = redis_store.get(f"game:{room_id}")
                if data:
                    g = pickle.loads(data)
                    # Sync local cache just in case, but Redis is truth
                    if self._instance: 
                        self._instance._local_cache[room_id] = g
                    return g
        except Exception as e:
            logger.error(f"[PID:{pid}] Redis GET Error {room_id}: {e}")
        
        # 2. Fallback to Local Memory (Only if Redis fails or is missing)
        # In a generic/stateless fleet, this will likely be a MISS, which is correct.
        local = self._local_cache.get(room_id)
        if local:
             logger.warning(f"[PID:{pid}] Serving Local Stale Game {room_id} (Redis Miss)")
        return local

    def save_game(self, game):
        pid = os.getpid()
        if not game: return
        try:
            # Update Local Cache (ALWAYS)
            self._local_cache[game.room_id] = game
            logger.info(f"[PID:{pid}] Local SAVE {game.room_id}")
            
            if redis_store:
                # 1 Hour Expiry for active games
                redis_store.setex(f"game:{game.room_id}", 3600, pickle.dumps(game))
                logger.info(f"[PID:{pid}] Redis SAVE {game.room_id} -> OK")
            else:
                logger.info(f"[PID:{pid}] Redis SAVE {game.room_id} -> SKIPPED (No RedisStore)")
        except Exception as e:
            logger.error(f"[PID:{pid}] Error saving game {game.room_id} to Redis: {e}")
            pass

    def remove_room(self, room_id):
        if room_id in self._local_cache:
            del self._local_cache[room_id]
            
        if redis_store:
            redis_store.delete(f"game:{room_id}")
            return True
        return False

    def clear_all_games(self):
        """Dev utility to clear all persisted games from Redis on startup."""
        if not redis_store: return
        try:
            keys = redis_store.keys("game:*")
            if keys:
                redis_store.delete(*keys)
                logger.warning(f"üßπ CLEARED {len(keys)} Zombie Games from Redis.")
        except Exception as e:
            logger.error(f"Failed to clear Redis games: {e}")
        
    @property
    def games(self):
        # Compatibility property for code iterating directly over .games
        # Warning: This iterates ALL keys in Redis, which is slow.
        # Should be avoided in high-performance paths.
        all_games = {}
        if not redis_store: return self._local_cache
        
        try:
            keys = redis_store.keys("game:*")
            for k in keys:
                rid = k.decode('utf-8').split(":")[-1] # Decode key manually since client is binary
                game = self.get_game(rid)
                if game: all_games[rid] = game
            return all_games
        except:
             return self._local_cache

# Global instance
room_manager = RoomManager()

```

### FILE: server\serializers.py
```py

import json
import datetime
from enum import Enum
from typing import Any, Dict, List, Union
from pydantic import BaseModel

def serialize(obj: Any) -> Any:
    """
    Recursively attempts to serialize an object into a JSON-compatible format.
    
    Priority:
    1. None -> None
    2. Dict -> Dict (recursive)
    3. List/Tuple -> List (recursive)
    4. Has .to_dict() method -> call it (recursive)
    5. Enum -> .value
    6. datetime/date -> .isoformat()
    7. JSON primitives (str, int, float, bool) -> self
    8. Fallback -> str(obj)
    """
    if obj is None:
        return None
        
    # primitive types that are natively JSON serializable
    if isinstance(obj, (str, int, float, bool)):
        return obj

    # Pydantic Model handling
    if isinstance(obj, BaseModel):
        return obj.model_dump(mode='json', by_alias=True)

    # datetime handling
    if isinstance(obj, (datetime.date, datetime.datetime)):
        return obj.isoformat()

    # Enum handling
    if isinstance(obj, Enum):
        return obj.value

    # Dictionary handling
    if isinstance(obj, dict):
        return {str(k): serialize(v) for k, v in obj.items()}

    # List/Tuple handling
    if isinstance(obj, (list, tuple)):
        return [serialize(v) for v in obj]

    # Custom Object with explicit serialization method
    if hasattr(obj, 'to_dict') and callable(getattr(obj, 'to_dict')):
        try:
            return serialize(obj.to_dict())
        except Exception as e:
            # Fallback if to_dict crashes
            return f"<Serialization Error: {str(e)}>"
            
    # Try __dict__ if it exists and is not a protected type
    # (Be careful not to expose too much internal state)
    # For now, safe fallback is string representation
    
    return str(obj)

```

### FILE: server\settings.py
```py
"""
This is an optional file that defined app level settings such as:
- database settings
- session settings
- i18n settings
This file is provided as an example:
"""
import os
from py4web.core import required_folder
from dotenv import load_dotenv

# Load environment variables
load_dotenv(os.path.join(os.path.dirname(os.path.dirname(__file__)), '.env.local'))

# db settings
APP_FOLDER = os.path.dirname(__file__)
APP_NAME = os.path.split(APP_FOLDER)[-1]
# DB_FOLDER:    Sets the place where migration files will be created
#               and is the store location for SQLite databases
DB_FOLDER = required_folder(APP_FOLDER, "databases")
DB_URI = "sqlite://storage.db"
DB_POOL_SIZE = 1
DB_MIGRATE = True
DB_FAKE_MIGRATE = False  # maybe?

# location where static files are stored:
STATIC_FOLDER = required_folder(APP_FOLDER, "static")

# location where to store uploaded files:
UPLOAD_FOLDER = required_folder(APP_FOLDER, "uploads")

# send verification email on registration
VERIFY_EMAIL = True

# account requires to be approved ?
REQUIRES_APPROVAL = False

# auto login after registration
# requires False VERIFY_EMAIL & REQUIRES_APPROVAL
LOGIN_AFTER_REGISTRATION = False

# ALLOWED_ACTIONS in API / default Forms:
# ["all"]
# ["login", "logout", "request_reset_password", "reset_password", \
#  "change_password", "change_email", "profile", "config", "register",
#  "verify_email", "unsubscribe"]
# Note: if you add "login", add also "logout"
ALLOWED_ACTIONS = ["all"]

# email settings
SMTP_SSL = False
SMTP_SERVER = None
SMTP_SENDER = "you@example.com"
SMTP_LOGIN = "username:password"
SMTP_TLS = False

# session settings
SESSION_TYPE = "cookies"
SESSION_SECRET_KEY = None   # or replace with your own secret
MEMCACHE_CLIENTS = ["127.0.0.1:11211"]
REDIS_SERVER = "localhost:6379"
REDIS_URL = os.environ.get("REDIS_URL", "redis://127.0.0.1:6379/0")
OFFLINE_MODE = os.environ.get("OFFLINE_MODE", "false").lower() == "true"


# logger settings
LOGGERS = [
    "warning:stdout",
    "debug:logs/debug.log"
]  # syntax "severity:filename" filename can be stderr or stdout

# Disable default login when using OAuth
DEFAULT_LOGIN_ENABLED = True

# single sign on Google (will be used if provided)
OAUTH2GOOGLE_CLIENT_ID = None
OAUTH2GOOGLE_CLIENT_SECRET = None

# Single sign on Google, with stored credentials for scopes (will be used if provided).
# set it to something like os.path.join(APP_FOLDER, "private/credentials.json"
OAUTH2GOOGLE_SCOPED_CREDENTIALS_FILE = None

# single sign on Okta (will be used if provided. Please also add your tenant
# name to py4web/utils/auth_plugins/oauth2okta.py. You can replace the XXX
# instances with your tenant name.)
OAUTH2OKTA_CLIENT_ID = None
OAUTH2OKTA_CLIENT_SECRET = None

# single sign on Google (will be used if provided)
OAUTH2FACEBOOK_CLIENT_ID = None
OAUTH2FACEBOOK_CLIENT_SECRET = None

# single sign on GitHub (will be used if provided)
OAUTH2GITHUB_CLIENT_ID = None
OAUTH2GITHUB_CLIENT_SECRET = None

# enable PAM
USE_PAM = False

# enable LDAP
USE_LDAP = False
LDAP_SETTINGS = {
    "mode": "ad",  # Microsoft Active Directory
    "server": "mydc.domain.com", # FQDN or IP of one Domain Controller
    "base_dn": "cn=Users,dc=domain,dc=com", # base dn, i.e. where the users are located
}

# i18n settings
T_FOLDER = required_folder(APP_FOLDER, "translations")

# Celery settings
USE_CELERY = False
CELERY_BROKER = "redis://localhost:6379/0"

# try import private settings
try:
    from .settings_private import *
except (ImportError, ModuleNotFoundError):
    pass

```

### FILE: server\socket_handler.py (SKIPPED - >10KB)
### FILE: server\tasks.py
```py
"""
To use celery tasks:
1) pip install -U "celery[redis]"
2) In settings.py:
   USE_CELERY = True
   CELERY_BROKER = "redis://localhost:6379/0"
3) Start "redis-server"
4) Start "celery -A apps.{appname}.tasks beat"
5) Start "celery -A apps.{appname}.tasks worker --loglevel=info" for each worker

"""
from .common import settings, scheduler, db, Field

# example of task that needs db access
@scheduler.task
def my_task():
    try:
        # this task will be executed in its own thread, connect to db
        db._adapter.reconnect()
        # do something here
        db.commit()
    except:
        # rollback on failure
        db.rollback()


# run my_task every 10 seconds
scheduler.conf.beat_schedule = {
    "my_first_task": {
        "task": "apps.%s.tasks.my_task" % settings.APP_NAME,
        "schedule": 10.0,
        "args": (),
    },
}

```

### FILE: server\test_client.py
```py
import socketio
import time
import sys

# Create a Socket.IO client
sio = socketio.Client()

@sio.event
def connect():
    print("Test Client Connected!")

@sio.event
def disconnect():
    print("Test Client Disconnected!")

@sio.event
def game_update(data):
    # print("State Update:", data)
    gs = data
    if 'gameState' in data: gs = data['gameState']
    
    phase = gs.get('phase')
    turn_idx = gs.get('currentTurnIndex')
    players = gs.get('players', [])
    
    print(f"Phase: {phase}, Turn: {turn_idx}")
    
    # Find me
    my_idx = -1
    for i, p in enumerate(players):
        if p.get('socketId') == sio.get_sid():
            my_idx = i
            break
            
    if my_idx != -1 and turn_idx == my_idx:
        print(f"MY TURN! (Index {my_idx})")
        
        if phase == 'BIDDING':
            print("Action: PASS")
            sio.emit('game_action', {'roomId': room_id, 'action': 'BID', 'payload': 'PASS'})
            
        elif phase == 'PLAYING':
            hand = players[my_idx].get('hand', [])
            if not hand:
                print("Hand empty?!")
                return
            
            # Simple Strategy: Play first card
            print(f"Action: PLAY Card 0")
            sio.emit('game_action', {'roomId': room_id, 'action': 'PLAY', 'payload': {'cardIndex': 0}})

@sio.event
def system_message(data):
    print("System:", data)

if __name__ == '__main__':
    try:
        sio.connect('http://localhost:3001')
        
        # Create Room
        print("Creating Room...")
        room_id = None
        
        def on_create(data):
            global room_id
            if data['success']:
                room_id = data['roomId']
                print(f"Room Created: {room_id}")
            else:
                print("Create failed:", data)
                sys.exit(1)
                
        sio.emit('create_room', {}, callback=on_create)
        
        # Wait for callback
        time.sleep(1)
        if not room_id:
             print("Timout creating room")
             sys.exit(1)

        # Add Bots
        print("Adding Bots...")
        sio.emit('add_bot', {'roomId': room_id})
        time.sleep(0.5)
        sio.emit('add_bot', {'roomId': room_id})
        time.sleep(0.5)
        sio.emit('add_bot', {'roomId': room_id})
        
        # Loop forever
        sio.wait()
        
    except Exception as e:
        print("Error:", e)

```

### FILE: server\__init__.py
```py
# from .socket_handler import sio
# from .room_manager import room_manager

```

### FILE: server\content\puzzles\basic_01_revoke.json
```json
{
    "id": "basic_01_revoke",
    "title": "Don't Break the Sira!",
    "description": "Your partner led a Heart. You have a Heart. You MUST play it.",
    "difficulty": "Beginner",
    "tags": ["Rules", "Sira", "Revoke"],
    "initial_state": {
        "players": [
            {"name": "Me", "position": "Bottom", "hand": [{"rank": "K", "suit": "H"}, {"rank": "7", "suit": "D"}]},
            {"name": "Right", "position": "Right", "hand": []},
            {"name": "Partner", "position": "Top", "hand": []},
            {"name": "Left", "position": "Left", "hand": []}
        ],
        "playedCards": {
            "Top": {"rank": "A", "suit": "H"}
        },
        "currentTurn": 0,
        "dealerIndex": 3,
        "bid": {"type": "SUN", "suit": "H", "playerIndex": 0},
        "scores": {"us": 0, "them": 0}
    },
    "solution": {
        "type": "sequence",
        "data": ["KH"]
    }
}

```

### FILE: server\content\puzzles\exam_1769835452_d3f85038.json
```json
{
    "id": "exam_1769835452_d3f85038",
    "title": "Professor's Exam: SUN Blunder",
    "description": "You played 8\u2665. The Professor found a better line. Can you find it?",
    "difficulty": "Intermediate",
    "tags": [
        "Professor",
        "SUN",
        "Blunder"
    ],
    "initial_state": {
        "roomId": "d3f85038",
        "phase": "PLAYING",
        "biddingPhase": "DOUBLING",
        "players": [
            {
                "id": "-s6jsqensKqVyplnAAAD",
                "name": "Me",
                "avatar": "https://picsum.photos/id/64/100/100",
                "index": 0,
                "hand": [
                    {
                        "suit": "\u2665",
                        "rank": "7",
                        "id": "7\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2665",
                        "rank": "8",
                        "id": "8\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2660",
                        "rank": "9",
                        "id": "9\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2660",
                        "rank": "J",
                        "id": "J\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2660",
                        "rank": "Q",
                        "id": "Q\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "8",
                        "id": "8\u2663",
                        "value": 0
                    }
                ],
                "score": 0,
                "team": "us",
                "position": "Bottom",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "",
                "isBot": false,
                "isActive": true,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_0_1769835444965",
                "name": "Saad (Bot)",
                "avatar": "avatar_saad",
                "index": 1,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Right",
                "isDealer": true,
                "actionText": "",
                "lastReasoning": "",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_1_1769835444965",
                "name": "Khalid (Bot)",
                "avatar": "avatar_khalid",
                "index": 2,
                "hand": [],
                "score": 0,
                "team": "us",
                "position": "Top",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "Collaborative Signal: Encourage \u2666 (Discarding K)",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_2_1769835444965",
                "name": "Abu Fahad (Bot)",
                "avatar": "avatar_abu_fahad",
                "index": 3,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Left",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "Collaborative Signal: Encourage \u2663 (Discarding A)",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            }
        ],
        "tableCards": [],
        "currentTurnIndex": 0,
        "gameMode": "SUN",
        "trumpSuit": null,
        "bid": {
            "type": "SUN",
            "bidder": "Left",
            "doubled": false,
            "suit": null,
            "level": 1,
            "variant": null,
            "isAshkal": false,
            "isTentative": false
        },
        "teamScores": {
            "us": 0,
            "them": 0
        },
        "matchScores": {
            "us": 0,
            "them": 0
        },
        "analytics": {
            "winProbability": [
                {
                    "trick": 1,
                    "us": 0.3881578947368421
                },
                {
                    "trick": 2,
                    "us": 0.4440789473684211
                }
            ],
            "blunders": {}
        },
        "floorCard": null,
        "dealerIndex": 1,
        "biddingRound": 1,
        "declarations": {},
        "timer": {
            "remaining": 4.115278959274292,
            "duration": 5,
            "elapsed": 0.884721040725708,
            "active": true
        },
        "isProjectRevealing": false,
        "doublingLevel": 1,
        "isLocked": false,
        "dealingPhase": 0,
        "lastTrick": {
            "cards": [
                {
                    "suit": "\u2665",
                    "rank": "9",
                    "id": "9\u2665",
                    "value": 0
                },
                {
                    "suit": "\u2666",
                    "rank": "K",
                    "id": "K\u2666",
                    "value": 0
                },
                {
                    "suit": "\u2663",
                    "rank": "A",
                    "id": "A\u2663",
                    "value": 0
                },
                {
                    "suit": "\u2665",
                    "rank": "J",
                    "id": "J\u2665",
                    "value": 0
                }
            ],
            "winner": "Bottom"
        },
        "roundHistory": [],
        "currentRoundTricks": [
            {
                "winner": "Right",
                "points": 34,
                "cards": [
                    {
                        "suit": "\u2665",
                        "rank": "Q",
                        "id": "Q\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2660",
                        "rank": "10",
                        "id": "10\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2665",
                        "rank": "10",
                        "id": "10\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2665",
                        "rank": "A",
                        "id": "A\u2665",
                        "value": 0
                    }
                ],
                "playedBy": [
                    "Top",
                    "Left",
                    "Bottom",
                    "Right"
                ]
            },
            {
                "winner": "Bottom",
                "points": 17,
                "cards": [
                    {
                        "suit": "\u2665",
                        "rank": "9",
                        "id": "9\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "K",
                        "id": "K\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "A",
                        "id": "A\u2663",
                        "value": 0
                    },
                    {
                        "suit": "\u2665",
                        "rank": "J",
                        "id": "J\u2665",
                        "value": 0
                    }
                ],
                "playedBy": [
                    "Right",
                    "Top",
                    "Left",
                    "Bottom"
                ]
            }
        ],
        "sawaState": {
            "active": false,
            "claimer": null,
            "responses": {},
            "status": "NONE",
            "challenge_active": false
        },
        "timerStartTime": 1769835444.9626749,
        "turnDuration": 30,
        "serverTime": 1769835451.958181,
        "akkaState": null,
        "gameId": "d3f85038",
        "settings": {}
    },
    "solution": {
        "type": "sequence",
        "data": [
            "8\u2663"
        ]
    }
}
```

### FILE: server\content\puzzles\exam_1769837385_6794507b.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769837979_4596701f.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769930202_f3f907ba.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769935578_ddd5b8c8.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769936135_490c0ceb.json
```json
{
    "id": "exam_1769936135_490c0ceb",
    "title": "Professor's Exam: HOKUM Blunder",
    "description": "You played K\u2660. The Professor found a better line. Can you find it?",
    "difficulty": "Intermediate",
    "tags": [
        "Professor",
        "HOKUM",
        "Blunder"
    ],
    "initial_state": {
        "roomId": "490c0ceb",
        "phase": "PLAYING",
        "biddingPhase": "DOUBLING",
        "players": [
            {
                "id": "atkqGSC3UqT_B3bQAAAB",
                "name": "Me",
                "avatar": "https://picsum.photos/id/64/100/100",
                "index": 0,
                "hand": [
                    {
                        "suit": "\u2660",
                        "rank": "K",
                        "id": "K\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "8",
                        "id": "8\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "10",
                        "id": "10\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "K",
                        "id": "K\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "A",
                        "id": "A\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "8",
                        "id": "8\u2663",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "K",
                        "id": "K\u2663",
                        "value": 0
                    }
                ],
                "score": 0,
                "team": "us",
                "position": "Bottom",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "",
                "isBot": false,
                "isActive": true,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_0_1769936123493",
                "name": "Saad (Bot)",
                "avatar": "avatar_saad",
                "index": 1,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Right",
                "isDealer": true,
                "actionText": "",
                "lastReasoning": "Partner Winning - Feeding",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_1_1769936123493",
                "name": "Khalid (Bot)",
                "avatar": "avatar_khalid",
                "index": 2,
                "hand": [],
                "score": 0,
                "team": "us",
                "position": "Top",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "Smart Sahn (Drawing Trumps)",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_2_1769936123493",
                "name": "Abu Fahad (Bot)",
                "avatar": "avatar_abu_fahad",
                "index": 3,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Left",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            }
        ],
        "tableCards": [
            {
                "playerId": "BOT_2_1769936123493",
                "card": {
                    "suit": "\u2665",
                    "rank": "7",
                    "id": "7\u2665",
                    "value": 0
                },
                "playedBy": "Left",
                "metadata": null
            }
        ],
        "currentTurnIndex": 0,
        "gameMode": "HOKUM",
        "trumpSuit": "\u2665",
        "bid": {
            "type": "HOKUM",
            "bidder": "Top",
            "doubled": false,
            "suit": "\u2665",
            "level": 1,
            "variant": null,
            "isAshkal": false,
            "isTentative": false
        },
        "teamScores": {
            "us": 0,
            "them": 0
        },
        "matchScores": {
            "us": 0,
            "them": 0
        },
        "analytics": {
            "winProbability": [
                {
                    "trick": 1,
                    "us": 0.34210526315789475
                }
            ],
            "blunders": {}
        },
        "floorCard": null,
        "dealerIndex": 1,
        "biddingRound": 1,
        "declarations": {},
        "timer": {
            "remaining": 2.1476078033447266,
            "duration": 5,
            "elapsed": 2.8523921966552734,
            "active": true
        },
        "isProjectRevealing": false,
        "doublingLevel": 1,
        "isLocked": false,
        "dealingPhase": 0,
        "lastTrick": {
            "cards": [
                {
                    "suit": "\u2665",
                    "rank": "9",
                    "id": "9\u2665",
                    "value": 0
                },
                {
                    "suit": "\u2665",
                    "rank": "J",
                    "id": "J\u2665",
                    "value": 0
                },
                {
                    "suit": "\u2665",
                    "rank": "K",
                    "id": "K\u2665",
                    "value": 0
                },
                {
                    "suit": "\u2665",
                    "rank": "10",
                    "id": "10\u2665",
                    "value": 0
                }
            ],
            "winner": "Left"
        },
        "roundHistory": [],
        "currentRoundTricks": [
            {
                "winner": "Left",
                "points": 48,
                "cards": [
                    {
                        "suit": "\u2665",
                        "rank": "9",
                        "id": "9\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2665",
                        "rank": "J",
                        "id": "J\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2665",
                        "rank": "K",
                        "id": "K\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2665",
                        "rank": "10",
                        "id": "10\u2665",
                        "value": 0
                    }
                ],
                "playedBy": [
                    "Top",
                    "Left",
                    "Bottom",
                    "Right"
                ]
            }
        ],
        "sawaState": {
            "active": false,
            "claimer": null,
            "responses": {},
            "status": "NONE",
            "challenge_active": false
        },
        "qaydState": {
            "active": false,
            "reporter": null,
            "reason": null,
            "target_play": null
        },
        "challengeActive": false,
        "timerStartTime": 1769936123.4897623,
        "turnDuration": 30,
        "serverTime": 1769936135.2192357,
        "akkaState": null,
        "gameId": "490c0ceb",
        "settings": {}
    },
    "solution": {
        "type": "sequence",
        "data": [
            "8\u2666"
        ]
    }
}
```

### FILE: server\content\puzzles\exam_1769937668_f6256c41.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769937697_f6256c41.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769953888_cc5e55a6.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769955637_65a19c94.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769956891_9daafb9d.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769957124_b055bc19.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769957127_b055bc19.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769957138_b055bc19.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769962662_b2ed38a0.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769963606_3376291a.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769964094_af364ff4.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769964099_af364ff4.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769964102_af364ff4.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769964108_af364ff4.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769964111_af364ff4.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769964284_fdba5d3d.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769964291_fdba5d3d.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769964440_207352df.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769972846_6b1a6ffa.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769973119_825e19b2.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769973143_825e19b2.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1769987022_b62569fe.json
```json
{
    "id": "exam_1769987022_b62569fe",
    "title": "Professor's Exam: SUN Blunder",
    "description": "You played J\u2660. The Professor found a better line. Can you find it?",
    "difficulty": "Intermediate",
    "tags": [
        "Professor",
        "SUN",
        "Blunder"
    ],
    "initial_state": {
        "roomId": "b62569fe",
        "phase": "PLAYING",
        "biddingPhase": "DOUBLING",
        "players": [
            {
                "id": "f6FD-GF58CzJqin7AAAB",
                "name": "Me",
                "avatar": "https://picsum.photos/id/64/100/100",
                "index": 0,
                "hand": [
                    {
                        "suit": "\u2660",
                        "rank": "J",
                        "id": "J\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2660",
                        "rank": "A",
                        "id": "A\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "Q",
                        "id": "Q\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "K",
                        "id": "K\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "8",
                        "id": "8\u2663",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "9",
                        "id": "9\u2663",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "J",
                        "id": "J\u2663",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "Q",
                        "id": "Q\u2663",
                        "value": 0
                    }
                ],
                "score": 0,
                "team": "us",
                "position": "Bottom",
                "isDealer": true,
                "actionText": "",
                "lastReasoning": "",
                "isBot": false,
                "isActive": true,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_0_1769987017228",
                "name": "Saad (Bot)",
                "avatar": "avatar_saad",
                "index": 1,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Right",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "Fallback",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_1_1769987017228",
                "name": "Khalid (Bot)",
                "avatar": "avatar_khalid",
                "index": 2,
                "hand": [],
                "score": 0,
                "team": "us",
                "position": "Top",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "Cutting Enemy",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_2_1769987017228",
                "name": "Abu Fahad (Bot)",
                "avatar": "avatar_abu_fahad",
                "index": 3,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Left",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "Cutting Enemy",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            }
        ],
        "tableCards": [
            {
                "playerId": "BOT_0_1769987017228",
                "card": {
                    "suit": "\u2665",
                    "rank": "7",
                    "id": "7\u2665",
                    "value": 0
                },
                "playedBy": "Right",
                "metadata": {
                    "reasoning": "Fallback"
                }
            },
            {
                "playerId": "BOT_1_1769987017228",
                "card": {
                    "suit": "\u2665",
                    "rank": "J",
                    "id": "J\u2665",
                    "value": 0
                },
                "playedBy": "Top",
                "metadata": {
                    "reasoning": "Cutting Enemy"
                }
            },
            {
                "playerId": "BOT_2_1769987017228",
                "card": {
                    "suit": "\u2665",
                    "rank": "A",
                    "id": "A\u2665",
                    "value": 0
                },
                "playedBy": "Left",
                "metadata": {
                    "reasoning": "Cutting Enemy"
                }
            }
        ],
        "currentTurnIndex": 0,
        "gameMode": "SUN",
        "trumpSuit": null,
        "bid": {
            "type": "SUN",
            "bidder": "Right",
            "doubled": false,
            "suit": null,
            "level": 1,
            "variant": null,
            "isAshkal": true,
            "isTentative": false
        },
        "teamScores": {
            "us": 0,
            "them": 0
        },
        "matchScores": {
            "us": 0,
            "them": 0
        },
        "analytics": {
            "winProbability": [],
            "blunders": {}
        },
        "floorCard": null,
        "dealerIndex": 0,
        "biddingRound": 1,
        "declarations": {},
        "timer": {
            "remaining": 0.6890966892242432,
            "duration": 5,
            "elapsed": 4.310903310775757,
            "active": true
        },
        "isProjectRevealing": false,
        "doublingLevel": 1,
        "isLocked": false,
        "dealingPhase": 0,
        "lastTrick": null,
        "roundHistory": [],
        "currentRoundTricks": [],
        "sawaState": {
            "active": false,
            "claimer": null,
            "responses": {},
            "status": "NONE",
            "challenge_active": false
        },
        "qaydState": {
            "active": false,
            "reporter": null,
            "reason": null,
            "status": "NONE",
            "target_play": null,
            "verdict_message": null,
            "crime_card_index": -1,
            "proof_card_index": -1,
            "loser_team": null,
            "penalty_points": 0
        },
        "challengeActive": false,
        "timerStartTime": 1769987017.2254946,
        "turnDuration": 30,
        "serverTime": 1769987022.0489998,
        "akkaState": null,
        "gameId": "b62569fe",
        "settings": {}
    },
    "solution": {
        "type": "sequence",
        "data": [
            "A\u2660"
        ]
    }
}
```

### FILE: server\content\puzzles\exam_1769988803_feed187f.json
```json
{
    "id": "exam_1769988803_feed187f",
    "title": "Professor's Exam: SUN Blunder",
    "description": "You played K\u2660. The Professor found a better line. Can you find it?",
    "difficulty": "Intermediate",
    "tags": [
        "Professor",
        "SUN",
        "Blunder"
    ],
    "initial_state": {
        "roomId": "feed187f",
        "phase": "PLAYING",
        "biddingPhase": "DOUBLING",
        "players": [
            {
                "id": "vP9f0aLEje73mliuAAAB",
                "name": "Me",
                "avatar": "https://picsum.photos/id/64/100/100",
                "index": 0,
                "hand": [
                    {
                        "suit": "\u2665",
                        "rank": "J",
                        "id": "J\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2665",
                        "rank": "K",
                        "id": "K\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2665",
                        "rank": "A",
                        "id": "A\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2660",
                        "rank": "7",
                        "id": "7\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2660",
                        "rank": "10",
                        "id": "10\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2660",
                        "rank": "K",
                        "id": "K\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "9",
                        "id": "9\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "K",
                        "id": "K\u2666",
                        "value": 0
                    }
                ],
                "score": 0,
                "team": "us",
                "position": "Bottom",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "",
                "isBot": false,
                "isActive": true,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_0_1769988799697",
                "name": "Saad (Bot)",
                "avatar": "avatar_saad",
                "index": 1,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Right",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_1_1769988799697",
                "name": "Khalid (Bot)",
                "avatar": "avatar_khalid",
                "index": 2,
                "hand": [],
                "score": 0,
                "team": "us",
                "position": "Top",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_2_1769988799697",
                "name": "Abu Fahad (Bot)",
                "avatar": "avatar_abu_fahad",
                "index": 3,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Left",
                "isDealer": true,
                "actionText": "",
                "lastReasoning": "",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            }
        ],
        "tableCards": [],
        "currentTurnIndex": 0,
        "gameMode": "SUN",
        "trumpSuit": null,
        "bid": {
            "type": "SUN",
            "bidder": "Bottom",
            "doubled": false,
            "suit": null,
            "level": 1,
            "variant": null,
            "isAshkal": false,
            "isTentative": false
        },
        "teamScores": {
            "us": 0,
            "them": 0
        },
        "matchScores": {
            "us": 0,
            "them": 0
        },
        "analytics": {
            "winProbability": [],
            "blunders": {}
        },
        "floorCard": null,
        "dealerIndex": 3,
        "biddingRound": 1,
        "declarations": {},
        "timer": {
            "remaining": 3.3386240005493164,
            "duration": 5,
            "elapsed": 1.6613759994506836,
            "active": true
        },
        "isProjectRevealing": false,
        "doublingLevel": 1,
        "isLocked": false,
        "dealingPhase": 0,
        "lastTrick": null,
        "roundHistory": [],
        "currentRoundTricks": [],
        "sawaState": {
            "active": false,
            "claimer": null,
            "responses": {},
            "status": "NONE",
            "challenge_active": false
        },
        "qaydState": {
            "active": false,
            "reporter": null,
            "reason": null,
            "status": "NONE",
            "target_play": null,
            "verdict_message": null,
            "crime_card_index": -1,
            "proof_card_index": -1,
            "loser_team": null,
            "penalty_points": 0
        },
        "challengeActive": false,
        "timerStartTime": 1769988799.694315,
        "turnDuration": 30,
        "serverTime": 1769988803.4402287,
        "akkaState": null,
        "gameId": "feed187f",
        "settings": {}
    },
    "solution": {
        "type": "sequence",
        "data": [
            "A\u2665"
        ]
    }
}
```

### FILE: server\content\puzzles\exam_1770070329_cfa4bc90.json
```json
{
    "id": "exam_1770070329_cfa4bc90",
    "title": "Professor's Exam: SUN Blunder",
    "description": "You played 10\u2660. The Professor found a better line. Can you find it?",
    "difficulty": "Intermediate",
    "tags": [
        "Professor",
        "SUN",
        "Blunder"
    ],
    "initial_state": {
        "roomId": "cfa4bc90",
        "phase": "PLAYING",
        "biddingPhase": "DOUBLING",
        "players": [
            {
                "id": "X_CxIzDSsCCfhyDuAAAD",
                "name": "Me",
                "avatar": "https://picsum.photos/id/64/100/100",
                "index": 0,
                "hand": [
                    {
                        "suit": "\u2660",
                        "rank": "10",
                        "id": "10\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "7",
                        "id": "7\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "Q",
                        "id": "Q\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "9",
                        "id": "9\u2663",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "J",
                        "id": "J\u2663",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "Q",
                        "id": "Q\u2663",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "K",
                        "id": "K\u2663",
                        "value": 0
                    }
                ],
                "score": 0,
                "team": "us",
                "position": "Bottom",
                "isDealer": true,
                "actionText": "",
                "lastReasoning": "",
                "isBot": false,
                "isActive": true,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_0_1770070301386",
                "name": "Saad (Bot)",
                "avatar": "avatar_saad",
                "index": 1,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Right",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "Fallback",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_1_1770070301386",
                "name": "Khalid (Bot)",
                "avatar": "avatar_khalid",
                "index": 2,
                "hand": [],
                "score": 0,
                "team": "us",
                "position": "Top",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "Fallback",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_2_1770070301386",
                "name": "Abu Fahad (Bot)",
                "avatar": "avatar_abu_fahad",
                "index": 3,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Left",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "Cutting Enemy",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            }
        ],
        "tableCards": [
            {
                "playerId": "BOT_1_1770070301386",
                "card": {
                    "suit": "\u2665",
                    "rank": "8",
                    "id": "8\u2665",
                    "value": 0
                },
                "playedBy": "Top",
                "metadata": {
                    "reasoning": "Fallback"
                }
            },
            {
                "playerId": "BOT_2_1770070301386",
                "card": {
                    "suit": "\u2665",
                    "rank": "Q",
                    "id": "Q\u2665",
                    "value": 0
                },
                "playedBy": "Left",
                "metadata": {
                    "reasoning": "Cutting Enemy"
                }
            }
        ],
        "currentTurnIndex": 0,
        "gameMode": "SUN",
        "trumpSuit": null,
        "bid": {
            "type": "SUN",
            "bidder": "Bottom",
            "doubled": false,
            "suit": null,
            "level": 1,
            "variant": null,
            "isAshkal": false,
            "isTentative": false
        },
        "teamScores": {
            "us": 0,
            "them": 0
        },
        "matchScores": {
            "us": 0,
            "them": 0
        },
        "analytics": {
            "winProbability": [
                {
                    "trick": 1,
                    "us": 0.5328947368421053
                }
            ],
            "blunders": {}
        },
        "floorCard": null,
        "dealerIndex": 0,
        "biddingRound": 1,
        "declarations": {},
        "timer": {
            "remaining": 3.085489511489868,
            "duration": 5,
            "elapsed": 1.9145104885101318,
            "active": true
        },
        "isProjectRevealing": false,
        "doublingLevel": 1,
        "isLocked": false,
        "dealingPhase": 0,
        "lastTrick": {
            "cards": [
                {
                    "suit": "\u2665",
                    "rank": "7",
                    "id": "7\u2665",
                    "value": 0
                },
                {
                    "suit": "\u2665",
                    "rank": "10",
                    "id": "10\u2665",
                    "value": 0
                },
                {
                    "suit": "\u2665",
                    "rank": "9",
                    "id": "9\u2665",
                    "value": 0
                },
                {
                    "suit": "\u2663",
                    "rank": "7",
                    "id": "7\u2663",
                    "value": 0
                }
            ],
            "winner": "Top",
            "metadata": [
                {
                    "reasoning": "Fallback"
                },
                {
                    "reasoning": "Cutting Enemy"
                },
                {
                    "reasoning": "Ducking (Can't Win)"
                },
                {
                    "cardId": "7\u2663"
                }
            ]
        },
        "roundHistory": [],
        "currentRoundTricks": [
            {
                "winner": "Top",
                "points": 10,
                "cards": [
                    {
                        "suit": "\u2665",
                        "rank": "7",
                        "id": "7\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2665",
                        "rank": "10",
                        "id": "10\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2665",
                        "rank": "9",
                        "id": "9\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "7",
                        "id": "7\u2663",
                        "value": 0
                    }
                ],
                "playedBy": [
                    "Right",
                    "Top",
                    "Left",
                    "Bottom"
                ]
            }
        ],
        "sawaState": {
            "active": false,
            "claimer": null,
            "responses": {},
            "status": "NONE",
            "challenge_active": false
        },
        "qaydState": {
            "active": false,
            "reporter": null,
            "reason": null,
            "status": "NONE",
            "target_play": null,
            "verdict_message": null,
            "crime_card_index": -1,
            "proof_card_index": -1,
            "loser_team": null,
            "penalty_points": 0
        },
        "challengeActive": false,
        "timerStartTime": 1770070301.3846118,
        "turnDuration": 30,
        "serverTime": 1770070329.178738,
        "akkaState": null,
        "gameId": "cfa4bc90",
        "settings": {}
    },
    "solution": {
        "type": "sequence",
        "data": [
            "7\u2666"
        ]
    }
}
```

### FILE: server\content\puzzles\exam_1770070603_c57c1a0b.json
```json
{
    "id": "exam_1770070603_c57c1a0b",
    "title": "Professor's Exam: SUN Blunder",
    "description": "You played A\u2663. The Professor found a better line. Can you find it?",
    "difficulty": "Intermediate",
    "tags": [
        "Professor",
        "SUN",
        "Blunder"
    ],
    "initial_state": {
        "roomId": "c57c1a0b",
        "phase": "PLAYING",
        "biddingPhase": "DOUBLING",
        "players": [
            {
                "id": "A9_0AYluLQDXiW9PAAAB",
                "name": "Me",
                "avatar": "https://picsum.photos/id/64/100/100",
                "index": 0,
                "hand": [
                    {
                        "suit": "\u2665",
                        "rank": "9",
                        "id": "9\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2665",
                        "rank": "10",
                        "id": "10\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "7",
                        "id": "7\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "K",
                        "id": "K\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "7",
                        "id": "7\u2663",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "10",
                        "id": "10\u2663",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "A",
                        "id": "A\u2663",
                        "value": 0
                    }
                ],
                "score": 0,
                "team": "us",
                "position": "Bottom",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "",
                "isBot": false,
                "isActive": true,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_0_1770070579429",
                "name": "Saad (Bot)",
                "avatar": "avatar_saad",
                "index": 1,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Right",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "Fallback",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_1_1770070579429",
                "name": "Khalid (Bot)",
                "avatar": "avatar_khalid",
                "index": 2,
                "hand": [],
                "score": 0,
                "team": "us",
                "position": "Top",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "Collaborative Signal: Encourage \u2666 (Discarding 10)",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_2_1770070579429",
                "name": "Abu Fahad (Bot)",
                "avatar": "avatar_abu_fahad",
                "index": 3,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Left",
                "isDealer": true,
                "actionText": "",
                "lastReasoning": "Partner winning - Safe Feed",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            }
        ],
        "tableCards": [
            {
                "playerId": "BOT_0_1770070579429",
                "card": {
                    "suit": "\u2660",
                    "rank": "8",
                    "id": "8\u2660",
                    "value": 0
                },
                "playedBy": "Right",
                "metadata": {
                    "reasoning": "Fallback"
                }
            },
            {
                "playerId": "BOT_1_1770070579429",
                "card": {
                    "suit": "\u2666",
                    "rank": "10",
                    "id": "10\u2666",
                    "value": 0
                },
                "playedBy": "Top",
                "metadata": {
                    "reasoning": "Collaborative Signal: Encourage \u2666 (Discarding 10)"
                }
            },
            {
                "playerId": "BOT_2_1770070579429",
                "card": {
                    "suit": "\u2660",
                    "rank": "7",
                    "id": "7\u2660",
                    "value": 0
                },
                "playedBy": "Left",
                "metadata": {
                    "reasoning": "Partner winning - Safe Feed"
                }
            }
        ],
        "currentTurnIndex": 0,
        "gameMode": "SUN",
        "trumpSuit": null,
        "bid": {
            "type": "SUN",
            "bidder": "Bottom",
            "doubled": false,
            "suit": null,
            "level": 1,
            "variant": null,
            "isAshkal": false,
            "isTentative": false
        },
        "teamScores": {
            "us": 0,
            "them": 0
        },
        "matchScores": {
            "us": 0,
            "them": 0
        },
        "analytics": {
            "winProbability": [
                {
                    "trick": 1,
                    "us": 0.4375
                }
            ],
            "blunders": {
                "Bottom": 1
            }
        },
        "floorCard": null,
        "dealerIndex": 3,
        "biddingRound": 1,
        "declarations": {},
        "timer": {
            "remaining": 3.7899045944213867,
            "duration": 5,
            "elapsed": 1.2100954055786133,
            "active": true
        },
        "isProjectRevealing": false,
        "doublingLevel": 1,
        "isLocked": false,
        "dealingPhase": 0,
        "lastTrick": {
            "cards": [
                {
                    "suit": "\u2660",
                    "rank": "J",
                    "id": "J\u2660",
                    "value": 0
                },
                {
                    "suit": "\u2660",
                    "rank": "A",
                    "id": "A\u2660",
                    "value": 0
                },
                {
                    "suit": "\u2665",
                    "rank": "Q",
                    "id": "Q\u2665",
                    "value": 0
                },
                {
                    "suit": "\u2660",
                    "rank": "Q",
                    "id": "Q\u2660",
                    "value": 0
                }
            ],
            "winner": "Right",
            "metadata": [
                {
                    "cardId": "J\u2660"
                },
                {
                    "reasoning": "Cutting Enemy"
                },
                {
                    "reasoning": "Collaborative Signal: Encourage \u2665 (Discarding Q)"
                },
                {
                    "reasoning": "Partner winning - Safe Feed"
                }
            ]
        },
        "roundHistory": [],
        "currentRoundTricks": [
            {
                "winner": "Right",
                "points": 19,
                "cards": [
                    {
                        "suit": "\u2660",
                        "rank": "J",
                        "id": "J\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2660",
                        "rank": "A",
                        "id": "A\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2665",
                        "rank": "Q",
                        "id": "Q\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2660",
                        "rank": "Q",
                        "id": "Q\u2660",
                        "value": 0
                    }
                ],
                "playedBy": [
                    "Bottom",
                    "Right",
                    "Top",
                    "Left"
                ]
            }
        ],
        "sawaState": {
            "active": false,
            "claimer": null,
            "responses": {},
            "status": "NONE",
            "challenge_active": false
        },
        "qaydState": {
            "active": false,
            "reporter": null,
            "reason": null,
            "status": "NONE",
            "target_play": null,
            "verdict_message": null,
            "crime_card_index": -1,
            "proof_card_index": -1,
            "loser_team": null,
            "penalty_points": 0
        },
        "challengeActive": false,
        "timerStartTime": 1770070579.4256213,
        "turnDuration": 30,
        "serverTime": 1770070602.702675,
        "akkaState": null,
        "gameId": "c57c1a0b",
        "settings": {}
    },
    "solution": {
        "type": "sequence",
        "data": [
            "7\u2663"
        ]
    }
}
```

### FILE: server\content\puzzles\exam_1770129452_61046bf4.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1770130109_dbb2f496.json
```json
{
    "id": "exam_1770130109_dbb2f496",
    "title": "Professor's Exam: None Blunder",
    "description": "You played 10\u2660. The Professor found a better line. Can you find it?",
    "difficulty": "Intermediate",
    "tags": [
        "Professor",
        null,
        "Blunder"
    ],
    "initial_state": {
        "roomId": "dbb2f496",
        "phase": "PLAYING",
        "biddingPhase": "DOUBLING",
        "players": [
            {
                "id": "_HYZHc3xSUtWChadAAAB",
                "name": "Me",
                "avatar": "https://picsum.photos/id/64/100/100",
                "index": 0,
                "hand": [
                    {
                        "suit": "\u2660",
                        "rank": "9",
                        "id": "9\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2660",
                        "rank": "10",
                        "id": "10\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2660",
                        "rank": "J",
                        "id": "J\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "8",
                        "id": "8\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "10",
                        "id": "10\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "J",
                        "id": "J\u2663",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "Q",
                        "id": "Q\u2663",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "A",
                        "id": "A\u2663",
                        "value": 0
                    }
                ],
                "score": 0,
                "team": "us",
                "position": "Bottom",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "",
                "isBot": false,
                "isActive": true,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_0_1770130094483",
                "name": "Saad (Bot)",
                "avatar": "avatar_saad",
                "index": 1,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Right",
                "isDealer": true,
                "actionText": "",
                "lastReasoning": "",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_1_1770130094483",
                "name": "Khalid (Bot)",
                "avatar": "avatar_khalid",
                "index": 2,
                "hand": [],
                "score": 0,
                "team": "us",
                "position": "Top",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_2_1770130094483",
                "name": "Abu Fahad (Bot)",
                "avatar": "avatar_abu_fahad",
                "index": 3,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Left",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            }
        ],
        "tableCards": [
            {
                "playerId": "BOT_1_1770130094483",
                "card": {
                    "suit": "\u2665",
                    "rank": "10",
                    "id": "10\u2665",
                    "value": 0
                },
                "playedBy": "Top",
                "metadata": {
                    "reasoning": "Fallback"
                }
            },
            {
                "playerId": "BOT_2_1770130094483",
                "card": {
                    "suit": "\u2665",
                    "rank": "7",
                    "id": "7\u2665",
                    "value": 0
                },
                "playedBy": "Left",
                "metadata": {
                    "reasoning": "Fallback"
                }
            }
        ],
        "currentTurnIndex": 0,
        "gameMode": null,
        "trumpSuit": null,
        "bid": {
            "type": "SUN",
            "bidder": "Bottom",
            "doubled": false,
            "suit": null,
            "level": 1,
            "variant": null,
            "isAshkal": false,
            "isTentative": false
        },
        "teamScores": {
            "us": 0,
            "them": 0
        },
        "matchScores": {
            "us": 0,
            "them": 0
        },
        "analytics": {
            "winProbability": [],
            "blunders": {}
        },
        "floorCard": null,
        "dealerIndex": 1,
        "biddingRound": 1,
        "declarations": {},
        "timer": {
            "remaining": 3.800011396408081,
            "duration": 5,
            "elapsed": 1.199988603591919,
            "active": true
        },
        "isProjectRevealing": false,
        "doublingLevel": 1,
        "isLocked": false,
        "strictMode": false,
        "dealingPhase": 0,
        "lastTrick": null,
        "roundHistory": [],
        "currentRoundTricks": [],
        "sawaState": {
            "active": false,
            "claimer": null,
            "responses": {},
            "status": "NONE",
            "challenge_active": false
        },
        "qaydState": {
            "active": false,
            "reporter": null,
            "reason": null,
            "status": "NONE",
            "target_play": null,
            "verdict_message": null,
            "crime_card_index": -1,
            "proof_card_index": -1,
            "loser_team": null,
            "penalty_points": 0
        },
        "challengeActive": false,
        "timerStartTime": 1770130094.4784777,
        "turnDuration": 30,
        "serverTime": 1770130109.1141298,
        "akkaState": null,
        "gameId": "dbb2f496",
        "settings": {}
    },
    "solution": {
        "type": "sequence",
        "data": [
            "9\u2660"
        ]
    }
}
```

### FILE: server\content\puzzles\exam_1770160063_b0010e79.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1770200861_b800206a.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1770203870_afdbf722.json (SKIPPED - >10KB)
### FILE: server\content\puzzles\exam_1770209211_68efeed2.json
```json
{
    "id": "exam_1770209211_68efeed2",
    "title": "Professor's Exam: None Blunder",
    "description": "You played 8\u2666. The Professor found a better line. Can you find it?",
    "difficulty": "Intermediate",
    "tags": [
        "Professor",
        null,
        "Blunder"
    ],
    "initial_state": {
        "roomId": "68efeed2",
        "phase": "PLAYING",
        "biddingPhase": "DOUBLING",
        "players": [
            {
                "id": "v3269px_w50-C5zwAAAF",
                "name": "Me",
                "avatar": "https://picsum.photos/id/64/100/100",
                "index": 0,
                "hand": [
                    {
                        "suit": "\u2665",
                        "rank": "A",
                        "id": "A\u2665",
                        "value": 0
                    },
                    {
                        "suit": "\u2660",
                        "rank": "Q",
                        "id": "Q\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2660",
                        "rank": "K",
                        "id": "K\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2660",
                        "rank": "A",
                        "id": "A\u2660",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "8",
                        "id": "8\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2666",
                        "rank": "9",
                        "id": "9\u2666",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "9",
                        "id": "9\u2663",
                        "value": 0
                    },
                    {
                        "suit": "\u2663",
                        "rank": "Q",
                        "id": "Q\u2663",
                        "value": 0
                    }
                ],
                "score": 0,
                "team": "us",
                "position": "Bottom",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "",
                "isBot": false,
                "isActive": true,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_0_1770209205363",
                "name": "Saad (Bot)",
                "avatar": "avatar_saad",
                "index": 1,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Right",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_1_1770209205363",
                "name": "Khalid (Bot)",
                "avatar": "avatar_khalid",
                "index": 2,
                "hand": [],
                "score": 0,
                "team": "us",
                "position": "Top",
                "isDealer": false,
                "actionText": "",
                "lastReasoning": "",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            },
            {
                "id": "BOT_2_1770209205363",
                "name": "Abu Fahad (Bot)",
                "avatar": "avatar_abu_fahad",
                "index": 3,
                "hand": [],
                "score": 0,
                "team": "them",
                "position": "Left",
                "isDealer": true,
                "actionText": "",
                "lastReasoning": "",
                "isBot": true,
                "isActive": false,
                "strategy": "heuristic",
                "profile": null
            }
        ],
        "tableCards": [],
        "currentTurnIndex": 0,
        "gameMode": null,
        "trumpSuit": null,
        "bid": {
            "type": "SUN",
            "bidder": "Bottom",
            "doubled": false,
            "suit": null,
            "level": 1,
            "variant": null,
            "isAshkal": false,
            "isTentative": false
        },
        "teamScores": {
            "us": 0,
            "them": 0
        },
        "matchScores": {
            "us": 0,
            "them": 0
        },
        "analytics": {
            "winProbability": [],
            "blunders": {}
        },
        "floorCard": null,
        "dealerIndex": 3,
        "biddingRound": 1,
        "declarations": {},
        "timer": {
            "remaining": 2.486764430999756,
            "duration": 5,
            "elapsed": 2.513235569000244,
            "active": true
        },
        "isProjectRevealing": false,
        "doublingLevel": 1,
        "isLocked": false,
        "strictMode": false,
        "dealingPhase": 0,
        "lastTrick": null,
        "roundHistory": [],
        "currentRoundTricks": [],
        "sawaState": {
            "active": false,
            "claimer": null,
            "responses": {},
            "status": "NONE",
            "challenge_active": false
        },
        "qaydState": {},
        "challengeActive": false,
        "timerStartTime": 1770209205.3611352,
        "turnDuration": 30,
        "serverTime": 1770209211.3026175,
        "akkaState": null,
        "gameId": "68efeed2",
        "settings": {}
    },
    "solution": {
        "type": "sequence",
        "data": [
            "A\u2660"
        ]
    }
}
```

### FILE: server\content\puzzles_test\exam_1769726116_test_game_XYZ.json
```json
{
    "id": "exam_1769726116_test_game_XYZ",
    "title": "Professor's Exam: SUN Blunder",
    "description": "You played 7S. The Professor found a better line. Can you find it?",
    "difficulty": "Intermediate",
    "tags": [
        "Professor",
        "SUN",
        "Blunder"
    ],
    "initial_state": {
        "gameId": "test_game_XYZ",
        "roundHistory": [],
        "players": [
            {
                "name": "Me",
                "index": 0,
                "hand": [
                    "S7",
                    "HA"
                ]
            },
            {
                "name": "Right",
                "index": 1,
                "hand": []
            },
            {
                "name": "Partner",
                "index": 2,
                "hand": []
            },
            {
                "name": "Left",
                "index": 3,
                "hand": []
            }
        ]
    },
    "solution": {
        "type": "sequence",
        "data": [
            "AH"
        ]
    }
}
```

### FILE: server\databases\fb87181b96a99be45f5a23f4277867ce_app_user.table
```table
.      }(id}(lengthM uniquenotnullsortableKtypeidsql!INTEGER PRIMARY KEY AUTOINCREMENTrname"id"	raw_rnamehu
first_name}(hM hhhKhstringh		CHAR(512)h"first_name"h
first_nameu	last_name}(hM hhhKhhh		CHAR(512)h"last_name"h
	last_nameuemail}(hM hhhKhhh	CHAR(512) UNIQUEh"email"h
emailupassword}(hM hhhKhpasswordh		CHAR(512)h
"password"h
h u
league_points}(hM hhhKhintegerh	INTEGERh"league_points"h

league_pointsuu.
```

### FILE: server\databases\fb87181b96a99be45f5a23f4277867ce_bot_training_data.table
```table
      }(id}(lengthM uniquenotnullsortableKtypeidsql!INTEGER PRIMARY KEY AUTOINCREMENTrname"id"	raw_rnamehucontext_hash}(hM hhhKhstringh		CHAR(512)h"context_hash"h
context_hashugame_state_json}(hM hhhKhtexth	TEXTh"game_state_json"h
game_state_jsonu
bad_move_json}(hM hhhKhhh	hh"bad_move_json"h

bad_move_jsonucorrect_move_json}(hM hhhKhhh	hh"correct_move_json"h
correct_move_jsonureason}(hM hhhKhhh	hh"reason"h
reasonu
created_on}(hM hhhKhdatetimeh		TIMESTAMPh"created_on"h
created_onuimage_filename}(hM hhhKhhh		CHAR(512)h"image_filename"h
image_filenameuu.
```

### FILE: server\databases\fb87181b96a99be45f5a23f4277867ce_foo.table
```table
      }(id}(lengthM uniquenotnullsortableKtypeidsql!INTEGER PRIMARY KEY AUTOINCREMENTrname"id"	raw_rnamehu
first_name}(hM hhhKhstringh		CHAR(512)h"first_name"h
first_nameu	last_name}(hM hhhKhhh		CHAR(512)h"last_name"h
	last_nameuemail}(hM hhhKhhh	CHAR(512) UNIQUEh"email"h
emailupassword}(hM hhhKhpasswordh		CHAR(512)h
"password"h
h uu.
```

### FILE: server\databases\fb87181b96a99be45f5a23f4277867ce_game_result.table
```table
&      }(id}(lengthM uniquenotnullsortableKtypeidsql!INTEGER PRIMARY KEY AUTOINCREMENTrname"id"	raw_rnamehu
user_email}(hM hhhKhstringh		CHAR(512)h"user_email"h
user_emailuscore_us}(hM hhhKhintegerh	INTEGERh
"score_us"h
score_usu
score_them}(hM hhhKhhh	hh"score_them"h
score_themuis_win}(hM hhhKhbooleanh	CHAR(1)h"is_win"h
is_winu	timestamp}(hM hhhKhdatetimeh		TIMESTAMPh"timestamp"h
	timestampuu.
```

### FILE: server\databases\fb87181b96a99be45f5a23f4277867ce_match_archive.table
```table
      }(id}(lengthM uniquenotnullsortableKtypeidsql!INTEGER PRIMARY KEY AUTOINCREMENTrname"id"	raw_rnamehugame_id}(hM hhhKhstringh	CHAR(512) UNIQUEh	"game_id"h
game_idu
user_email}(hM hhhKhhh		CHAR(512)h"user_email"h
user_emailuhistory_json}(hM hhhKhtexth	TEXTh"history_json"h
history_jsonufinal_score_us}(hM hhhKhintegerh	INTEGERh"final_score_us"h
final_score_usufinal_score_them}(hM hhhKhh!h	h"h"final_score_them"h
final_score_themu	timestamp}(hM hhhKhdatetimeh		TIMESTAMPh"timestamp"h
	timestampuu.
```

### FILE: server\schemas\base.py
```py
from enum import Enum
from typing import List

class Suit(str, Enum):
    SPADES = '‚ô†'
    HEARTS = '‚ô•'
    DIAMONDS = '‚ô¶'
    CLUBS = '‚ô£'

class Rank(str, Enum):
    SEVEN = '7'
    EIGHT = '8'
    NINE = '9'
    TEN = '10'
    JACK = 'J'
    QUEEN = 'Q'
    KING = 'K'
    ACE = 'A'

class GamePhase(str, Enum):
    WAITING = 'WAITING'
    BIDDING = 'BIDDING'
    PLAYING = 'PLAYING'
    FINISHED = 'FINISHED'
    GAMEOVER = 'GAMEOVER'
    DOUBLING = 'DOUBLING'
    VARIANT_SELECTION = 'VARIANT_SELECTION'
    CHALLENGE = 'CHALLENGE'

class BiddingPhase(str, Enum):
    ROUND_1 = "ROUND_1"
    GABLAK_WINDOW = "GABLAK_WINDOW"
    ROUND_2 = "ROUND_2"
    DOUBLING = "DOUBLING"
    VARIANT_SELECTION = "VARIANT_SELECTION"
    FINISHED = "FINISHED"

class BidType(str, Enum):
    PASS = "PASS"
    HOKUM = "HOKUM"
    SUN = "SUN"
    ASHKAL = "ASHKAL"
    DOUBLE = "DOUBLE"
    TRIPLE = "TRIPLE"
    FOUR = "FOUR"
    GAHWA = "GAHWA"
    KAWESH = "KAWESH"

class Team(str, Enum):
    US = 'us'
    THEM = 'them'

```

### FILE: server\schemas\cards.py
```py
from pydantic import BaseModel, Field, ConfigDict
from typing import Optional
from server.schemas.base import Suit, Rank

class CardModel(BaseModel):
    suit: Suit
    rank: Rank
    id: str
    value: int = 0

    model_config = ConfigDict(populate_by_name=True)

class DeckModel(BaseModel):
    cards: list[CardModel]

```

### FILE: server\schemas\game.py
```py
from pydantic import BaseModel, Field, ConfigDict
from typing import List, Dict, Optional, Any, Union
from server.schemas.base import GamePhase, BiddingPhase, BidType, Team
from server.schemas.cards import CardModel

class PlayerModel(BaseModel):
    id: str
    name: str
    avatar: str
    index: int
    hand: List[CardModel] = []
    score: int = 0
    team: Team
    position: str
    isDealer: bool
    actionText: str = ""
    lastReasoning: str = ""
    isBot: bool
    isActive: bool = False
    isThinking: bool = False

class TableCardModel(BaseModel):
    playerId: str
    card: CardModel
    playedBy: str
    metadata: Optional[Dict[str, Any]] = None

class TimerState(BaseModel):
    remaining: float
    duration: float
    elapsed: float
    active: bool

class AnalyticsModel(BaseModel):
    winProbability: List[Union[float, Dict[str, Any]]] = []
    blunders: Union[List[Any], Dict[str, int]] = {}

class GameStateModel(BaseModel):
    roomId: str
    phase: GamePhase
    biddingPhase: Optional[str] = None # String because sometimes it's None or Enum name
    players: List[PlayerModel]
    tableCards: List[TableCardModel]
    currentTurnIndex: int
    gameMode: Optional[str] = None
    trumpSuit: Optional[str] = None
    bid: Optional[Dict[str, Any]] = None
    teamScores: Dict[str, int]
    matchScores: Dict[str, int]
    analytics: AnalyticsModel
    floorCard: Optional[CardModel] = None
    dealerIndex: int
    biddingRound: int
    declarations: Dict[str, List[Dict[str, Any]]] # Complex structure, kept generic for now
    timer: TimerState
    isProjectRevealing: bool
    doublingLevel: int
    isLocked: bool
    dealingPhase: Union[str, int]
    lastTrick: Optional[Any] = None
    roundHistory: List[Any] = []
    currentRoundTricks: List[Any] = []
    sawaState: Optional[Dict[str, Any]] = None
    qaydState: Optional[Dict[str, Any]] = None
    challengeActive: bool
    timerStartTime: float
    turnDuration: float
    serverTime: float
    akkaState: Optional[Dict[str, Any]] = None
    gameId: str
    settings: Dict[str, Any] = {}

    model_config = ConfigDict(populate_by_name=True)

```

### FILE: server\schemas\__init__.py
```py
from server.schemas.base import *
from server.schemas.cards import *
from server.schemas.game import *

```

### FILE: server\services\archiver.py
```py
from server.common import db, logger
from server.logging_utils import log_event, log_error
import json
import datetime

from server.serializers import serialize

def archive_match(game_instance):
    """
    Saves the full match history of a completed game to the database.
    """
    try:
        if not game_instance.full_match_history:
            log_event("ARCHIVE_SKIPPED", game_instance.room_id, details={"reason": "No history"})
            return

        # Check if already exists? (Maybe updated?)
        existing = db.match_archive(game_id=game_instance.room_id)
        if existing:
             # Update?
             pass
        
        # Serialize history
        # Ensure deep serialization if objects exist (though Game.end_round usually handles to_dict)
        data = serialize(game_instance.full_match_history)
        history_json = json.dumps(data)
        
        db.match_archive.insert(
            game_id=game_instance.room_id,
            user_email=None, # Update if we can link to a user later
            history_json=history_json,
            final_score_us=game_instance.match_scores['us'],
            final_score_them=game_instance.match_scores['them'],
            timestamp=datetime.datetime.now()
        )
        db.commit()
        log_event("MATCH_ARCHIVED", game_instance.room_id, details={
            "final_scores": game_instance.match_scores, 
            "history_stats": {"rounds": len(game_instance.full_match_history)}
        })
        
    except Exception as e:
        log_error(game_instance.room_id, "Archive Failed", {"error": str(e)})

```

### FILE: server\translations\it.json
```json
{"Hello World from {name}": {"0": "Salve Mondo da {name}"}, "thing": {"0": "cosa", "1": "cose"}}

```

### FILE: services\geminiService.ts
```ts
import { GoogleGenAI } from "@google/genai";
import { GameState, PlayerPosition } from "../types";

// Initialize with a fallback to avoid crash if env is missing during init
const apiKey = process.env.API_KEY || 'DUMMY_KEY'; 
const ai = new GoogleGenAI({ apiKey });

// Using Flash for faster responses in a game loop
const MODEL_NAME = 'gemini-2.5-flash';

export const getBotDecision = async (gameState: GameState, playerPos: PlayerPosition): Promise<{ action: string, cardIndex?: number }> => {
  // Silent fallback if no key is present to allow gameplay without AI
  if (!process.env.API_KEY) {
    console.warn("No API Key available for bot decision. Using random fallback.");
    return { action: 'PASS' };
  }

  try {
    const prompt = `
      You are playing a game of Baloot (Saudi Arabian card game).
      Current Game State:
      - Phase: ${gameState.phase}
      - My Position: ${playerPos}
      - Current Floor Card (if bidding): ${gameState.floorCard ? `${gameState.floorCard.rank}${gameState.floorCard.suit}` : 'None'}
      - Current Bid: ${gameState.bid.type || 'None'}
      - Cards on Table: ${gameState.tableCards.map(c => `${c.card.rank}${c.card.suit}`).join(', ')}
      
      Your hand contains valid Baloot cards.
      
      If Phase is BIDDING:
      Return a JSON object with "action" being one of: "SUN", "HOKUM", "PASS".
      Prioritize "PASS" unless you have high cards (Ace, Ten, King).
      
      If Phase is PLAYING:
      Return a JSON object with "action": "PLAY" and "cardIndex" (0-based index of the card to play from hand).
      Pick a valid card to win the trick or follow suit.
      
      Return ONLY valid JSON.
    `;

    const response = await ai.models.generateContent({
      model: MODEL_NAME,
      contents: prompt,
      config: {
        responseMimeType: "application/json"
      }
    });

    const text = response.text;
    if (!text) throw new Error("Empty response");
    
    return JSON.parse(text);

  } catch (error) {
    // Catch 403 Permission Denied or other API errors
    console.error("Gemini API Error (falling back to simple logic):", error);
    return { action: 'PASS', cardIndex: 0 };
  }
};
```

### FILE: tests\conftest.py
```py
import sys
import os

# Add the project root directory to sys.path
# This ensures that tests in this directory can import modules from the project root
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

```

### FILE: tests\headless_debug.py
```py

import socketio
import time
import sys

# Color codes
GREEN = '\033[92m'
RED = '\033[91m'
YELLOW = '\033[93m'
RESET = '\033[0m'
BLUE = '\033[94m'

sio = socketio.Client()
room_id = None
my_player_index = -1

@sio.event
def connect():
    print(f"{GREEN}Connected to Game Server!{RESET}")

@sio.event
def connect_error(data):
    print(f"{RED}Connection Failed:{RESET}", data)

@sio.event
def disconnect():
    print(f"{RED}Disconnected.{RESET}")

@sio.event
def disconnect():
    print(f"{RED}Disconnected.{RESET}")

def create_room_callback(data):
    global room_id
    room_id = data['roomId']
    print(f"{BLUE}Room Created via Callback: {room_id}{RESET}")
    
    # Add Bots
    print("Adding Bot 1...")
    sio.emit('add_bot', {'roomId': room_id})

@sio.on('player_joined')
def on_player_joined(data):
    player = data['player']
    print(f"Player Joined: {player['name']} (Index: {player.get('index')})")
    
    # We don't have direct player count here easily unless we track it
    # But for headless debug, we can just sequentially add bots based on logic
    # Or just spam add_bot 3 times after creation
    
    # Logic: If I just joined, add Bot 1. If Bot 1 joined, add Bot 2...
    # But `add_bot` relies on server handling the count.
    
    # Better approach for CLI:
    # Just emit add_bot 3 times with small delay in main loop/callback
    pass

@sio.on('game_start')
def on_game_start(data):
    print(f"{GREEN}>>> GAME STARTED! <<<{RESET}")
    # Initialize basic state tracking if needed

@sio.on('game_state_update')
def on_game_state(data):
    phase = data.get('phase', 'UNKNOWN')
    turn_idx = data.get('currentTurnIndex', -1)
    
    # Pretty print state
    print(f"\n{YELLOW}--- STATE UPDATE ({phase}) ---{RESET}")
    print(f"Turn: Player {turn_idx}")
    
    if phase == 'BIDDING':
        print(f"Bidding Round: {data.get('biddingRound')}, Floor: {data.get('floorCard')}")
    elif phase == 'PLAYING':
        print(f"Table Cards: {len(data.get('tableCards', []))}")
        
    # Check if game is "Frozen" (Bot loop hanging?)
    # If the turn stays on a BOT for too long, we know it's stuck.

@sio.on('error')
def on_error(data):
    print(f"{RED}ERROR: {data}{RESET}")

def main():
    try:
        url = 'http://localhost:3001'
        print(f"Connecting to {url}...")
        sio.connect(url)
        
        # Create Room
        print("Creating Room...")
        sio.emit('create_room', {'player_name': 'HeadlessDebugger'}, callback=create_room_callback)
        
        # Wait for room creation before adding bots
        # The callback is async in threaded mode.
        # We can just wait a bit in loop
        time.sleep(1)
        if room_id:
             print("Adding remaining bots...")
             sio.emit('add_bot', {'roomId': room_id})
             time.sleep(0.5)
             sio.emit('add_bot', {'roomId': room_id})
             time.sleep(0.5)
             sio.emit('add_bot', {'roomId': room_id})
        
        # Keep alive
        while True:
            time.sleep(1)
            
    except KeyboardInterrupt:
        print("Stopping...")
        sio.disconnect()
    except Exception as e:
        print(f"{RED}Exception: {e}{RESET}")

if __name__ == '__main__':
    main()

```

### FILE: tests\repro_qayd_reversion.py
```py
import sys
import os
import unittest
from unittest.mock import MagicMock

# Add project root to path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from game_engine.logic.game import Game
from game_engine.models.constants import GamePhase
from game_engine.logic.phases.challenge_phase import ChallengePhase

class TestQaydPhaseReversion(unittest.TestCase):
    def setUp(self):
        self.game = Game("test_room")
        # Mock dependencies to avoid full stack requirement
        self.game.trick_manager = MagicMock()
        self.game.trick_manager.propose_qayd.return_value = {'success': True}
        self.game.trick_manager.cancel_qayd.return_value = {'success': True}
        self.game.trick_manager.qayd_state = {'active': False}
        
        # Ensure ChallengePhase is attached
        self.game.challenge_phase = ChallengePhase(self.game)
        
        # Add a dummy player
        from game_engine.models.player import Player
        p = Player("p0", "P0", 0, self.game)
        self.game.players.append(p)

    def test_revert_to_finished(self):
        """
        Test that cancelling Qayd when game was FINISHED returns to FINISHED, not PLAYING.
        """
        # 1. Simulate Round End
        self.game.phase = GamePhase.FINISHED.value
        print(f"\n[TEST] Initial Phase: {self.game.phase}")
        
        # 2. Trigger Qayd
        print("[TEST] Triggering Qayd...")
        self.game.handle_qayd_trigger(0)
        
        self.assertEqual(self.game.phase, GamePhase.CHALLENGE.value, "Game should be in CHALLENGE phase")
        print(f"[TEST] Phase after Trigger: {self.game.phase}")
        
        # 3. Cancel Qayd
        print("[TEST] Cancelling Qayd...")
        self.game.handle_qayd_cancel()
        
        print(f"[TEST] Phase after Cancel: {self.game.phase}")
        
        # 4. Assert
        self.assertEqual(self.game.phase, GamePhase.FINISHED.value, 
                        f"Game Phase should be FINISHED, but was {self.game.phase}")

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\repro_qayd_score.py
```py
import sys
import os
import unittest
from unittest.mock import MagicMock

# Add project root to path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from game_engine.logic.game import Game
from game_engine.models.constants import GamePhase
from game_engine.logic.phases.challenge_phase import ChallengePhase
from game_engine.logic.trick_manager import TrickManager
from game_engine.models.player import Player

class TestQaydScore(unittest.TestCase):
    def setUp(self):
        self.game = Game("test_room_score")
        
        # Setup Players
        self.game.players = []
        for i in range(4):
            p = Player(f"p{i}", f"P{i}", i, self.game)
            # Team: Bottom(0)/Top(2) = 'us', Right(1)/Left(3) = 'them'
            self.game.players.append(p)
            
        self.game.trick_manager = TrickManager(self.game)
        self.game.challenge_phase = ChallengePhase(self.game)
        
        # Setup Game Mode
        self.game.game_mode = 'SUN'
        self.game.bid = {'type': 'SUN'}
        self.game.match_scores = {'us': 0, 'them': 0}
        self.game.past_round_results = []

    def test_self_report_score(self):
        """
        Test: User (Bottom, 'us') triggers Qayd with NO crime found (False Accusation / Self-Report?).
        Expectation: 'us' is the LOSER. 'them' gets 26 points.
        """
        reporter_idx = 0 # Bottom (Us)
        
        # 1. Trigger Qayd (No crime on table)
        print(f"\n[TEST] Triggering Qayd by {self.game.players[reporter_idx].position} ('us')...")
        self.game.trick_manager.propose_qayd(reporter_idx)
        
        qayd_state = self.game.trick_manager.qayd_state
        print(f"[TEST] Verdict: {qayd_state.get('verdict')}")
        print(f"[TEST] Loser Team: {qayd_state.get('loser_team')}")
        
        # 2. Confirm Qayd
        print("[TEST] Confirming Qayd...")
        self.game.challenge_phase.resolve_verdict()
        
        # 3. Check Scores
        scores = self.game.match_scores
        print(f"[TEST] Finals Scores -> US: {scores['us']}, THEM: {scores['them']}")
        
        # Expectation: US (Reporter) made False Accusation -> US Loses -> THEM gets 26.
        self.assertEqual(scores['them'], 26, "Opponent should get 26 points")
        self.assertEqual(scores['us'], 0, "Reporter (Us) should get 0 points")

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\repro_qayd_user_revoke.py
```py
"""
Reproduction Script: User Revokes and Gets Rewarded (Bug)

This script simulates the exact scenario the user reported:
1. User (Bottom, 'us' team) plays an illegal card (revokes)
2. Someone triggers Qayd
3. Qayd is confirmed
4. Expected: Us=0, Them=26
5. Actual (per user): Us=26, Them=0
"""

import sys
import os
sys.path.insert(0, os.path.abspath('.'))

from game_engine.game import Game
from game_engine.models.card import Card
import unittest

class TestQaydUserRevoke(unittest.TestCase):
    def test_user_revoke_penalty(self):
        """Test that when Bottom (us) revokes, they get penalized (0 points), opponent gets 26."""
        game = Game(room_id="test_user_revoke")
        
        # Add 4 players
        for i in range(4):
            game.add_player(f"p{i}", f"Player{i}")
        
        # Start game
        game.start_game()
        
        # Force SUN mode
        game.game_mode = "SUN"
        game.bid = {'type': 'SUN', 'bidder': 'Bottom'}
        
        # Bottom is index 0, team 'us'
        bottom = game.players[0]
        right = game.players[1]
        
        # Clear hands for this test
        bottom.hand = [
            Card('Hearts', 'A'),  # Has Hearts
            Card('Spades', '7')
        ]
        right.hand = [Card('Hearts', 'K')]
        
        # Bottom leads with Hearts A
        game.current_turn = 0
        game.play_card(0, 0)  # Bottom plays Hearts A
        
        # Right plays Hearts K (legal)
        game.current_turn = 1
        game.play_card(1, 0)
        
        # Now Bottom plays again (trick continues)
        # Bottom should follow suit but doesn't (revokes)
        # Wait, this scenario doesn't make sense for a single trick.
        
        # Let me create a proper revoke scenario:
        # 1. Right leads Hearts
        # 2. Bottom has Hearts but plays Spades (illegal)
        
        # Reset
        game.table_cards = []
        game.current_turn = 1
        
        # Right leads Hearts K
        right.hand = [Card('Hearts', 'K')]
        game.play_card(1, 0)
        
        # Bottom has Hearts but plays Spades (REVOKE)
        game.current_turn = 0
        bottom.hand = [Card('Hearts', 'A'), Card('Spades', '7')]
        game.play_card(0, 1, metadata={'cardId': 'S7'})  # Plays Spades (illegal)
        
        # Check if Referee flagged it
        last_play = game.table_cards[-1]
        is_illegal = last_play.get('metadata', {}).get('is_illegal', False)
        print(f"[TEST] Bottom's Spades play flagged as illegal: {is_illegal}")
        
        # Trigger Qayd
        print(f"[TEST] Triggering Qayd...")
        result = game.trick_manager.propose_qayd(
            reporter_index=1,  # Right reports
            crime_card={'suit': 'Spades', 'rank': '7'},
            proof_card={'suit': 'Hearts', 'rank': 'A'},
            qayd_type='REVOKE'
        )
        
        print(f"[TEST] Qayd State: {game.trick_manager.qayd_state}")
        print(f"[TEST] Loser Team: {game.trick_manager.qayd_state.get('loser_team')}")
        print(f"[TEST] Penalty Points: {game.trick_manager.qayd_state.get('penalty_points')}")
        
        # Confirm Qayd
        game.trick_manager.confirm_qayd()
        
        # Check past_round_results
        if game.past_round_results:
            latest = game.past_round_results[-1]
            print(f"\n[TEST] Round Result:")
            print(f"  Us: {latest['us']['result']}")
            print(f"  Them: {latest['them']['result']}")
            print(f"  Winner: {latest['winner']}")
            print(f"  Reason: {latest['reason']}")
            
            # Assert correct scoring
            self.assertEqual(latest['us']['result'], 0, "Bottom (us) should get 0 for revoking")
            self.assertEqual(latest['them']['result'], 26, "Opponent (them) should get 26")
            self.assertEqual(latest['winner'], 'them', "Winner should be 'them'")
        else:
            self.fail("No round results found")

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_adaptive_atmosphere.py
```py

import pytest
from unittest.mock import MagicMock

# Since the hook is React code, we can't test it directly in Python efficiently 
# without a complex setup. 
# However, I can test the logic if I extract it or just rely on the implementation simplicity.
# Given the user context, I better skip Python unit testing for a Typescript React Hook 
# unless I have a jest setup. 
# The user's repo seems to rely on Python for backend.
# I will write a dummy test that validates the logic by simulating it in Python 
# just to be sure my math is right before I claim it works.

def calculate_tension(score_us, score_them, phase, is_sawa):
    level = 'low'
    bpm = 0
    max_score = max(score_us, score_them)
    diff = abs(score_us - score_them)
    
    if max_score >= 145:
        level = 'critical'
        bpm = 100
    elif max_score > 100 and diff < 20:
        level = 'high'
        bpm = 80
    elif phase == 'DOUBLING' or is_sawa:
        level = 'medium'
        bpm = 60
        
    return level, bpm

def test_tension_logic():
    # 1. Critical
    l, b = calculate_tension(146, 100, 'PLAYING', False)
    assert l == 'critical'
    assert b == 100
    
    # 2. High
    l, b = calculate_tension(105, 100, 'PLAYING', False) # Diff 5, Score > 100
    assert l == 'high'
    assert b == 80
    
    # 3. Medium (Doubling)
    l, b = calculate_tension(0, 0, 'DOUBLING', False)
    assert l == 'medium'
    
    # 4. Low
    l, b = calculate_tension(50, 20, 'PLAYING', False)
    assert l == 'low'
    assert b == 0


```

### FILE: tests\test_advanced_signaling.py (SKIPPED - >10KB)
### FILE: tests\test_ai_agent.py
```py
import unittest
from unittest.mock import MagicMock, patch
import json
import sys
import os

# Ensure we can import from root
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from ai_worker.agent import BotAgent
from ai_worker.bot_context import BotContext

class TestBotAgent(unittest.TestCase):
    def setUp(self):
        # Patch Redis to avoid connection attempts
        self.redis_patcher = patch('ai_worker.agent.redis')
        self.mock_redis_module = self.redis_patcher.start()
        
        # Instantiate fresh agent
        self.agent = BotAgent()
        
        # Mock Strategies
        self.agent.bidding_strategy = MagicMock()
        self.agent.playing_strategy = MagicMock()
        
        # Mock Redis Client
        self.mock_redis_client = MagicMock()
        self.agent.redis_client = self.mock_redis_client

    def tearDown(self):
        self.redis_patcher.stop()

    def get_mock_game_state(self, phase="BIDDING"):
        return {
            'phase': phase,
            'players': [
                {'name': 'Me', 'hand': [], 'position': 'Bottom'},
                {'name': 'Right', 'hand': [], 'position': 'Right'},
                {'name': 'Top', 'hand': [], 'position': 'Top'},
                {'name': 'Left', 'hand': [], 'position': 'Left'}
            ],
            'currentTurnIndex': 0,
            'dealerIndex': 3,
            'bid': {},
            'tableCards': [],
            'matchScores': {'us': 0, 'them': 0},
            'sawaState': {'active': False},
            'biddingRound': 1,
            'floorCard': {'suit': 'S', 'rank': 'A'}
        }

    def test_bidding_delegation(self):
        state = self.get_mock_game_state("BIDDING")
        self.agent.bidding_strategy.get_decision.return_value = {"action": "PASS"}
        
        # Make redis return None (no brain override)
        self.mock_redis_client.get.return_value = None

        decision = self.agent.get_decision(state, 0)
        
        self.agent.bidding_strategy.get_decision.assert_called()
        self.assertEqual(decision['action'], "PASS")

    def test_playing_delegation(self):
        state = self.get_mock_game_state("PLAYING")
        self.agent.playing_strategy.get_decision.return_value = {"action": "PLAY", "cardIndex": 0}
        
        self.mock_redis_client.get.return_value = None

        decision = self.agent.get_decision(state, 0)
        
        self.agent.playing_strategy.get_decision.assert_called()
        self.assertEqual(decision['action'], "PLAY")

    def test_brain_override_playing(self):
        state = self.get_mock_game_state("PLAYING")
        # Player has Ace of Spades
        state['players'][0]['hand'] = [{'suit': 'S', 'rank': 'A', 'value': 4}] # Simplified Card
        
        # Brain says play Ace of Spades
        brain_move = {"rank": "A", "suit": "S", "reason": "Win Trick"}
        self.mock_redis_client.get.return_value = json.dumps(brain_move)
        
        decision = self.agent.get_decision(state, 0)
        
        # We expect cardIndex 0 because that matches A-S
        self.assertEqual(decision['action'], "PLAY")
        self.assertEqual(decision['cardIndex'], 0)
        self.assertIn("Brain Override", decision.get('reasoning', ''))

    def test_sawa_refusal(self):
        # Setup Sawa Scenario
        state = self.get_mock_game_state("PLAYING")
        state['sawaState'] = {
            'active': True,
            'status': 'PENDING',
            'claimer': 'Right', # Enemy
            'responses': {}
        }
        
        # Give Master Card (Ace of Spades in SUN mode)
        # Note: We need a valid context to check master card.
        # BotAgent uses BotContext internally. 
        # But we need mock hand to contain a master card.
        # Assuming Ace is master.
        state['players'][0]['hand'] = [{'suit': 'S', 'rank': 'A', 'value': 4}]
        state['bid'] = {'type': 'SUN'} # SUN Mode
        
        decision = self.agent.get_decision(state, 0)
        
        self.assertEqual(decision['action'], "SAWA_RESPONSE")
        self.assertEqual(decision['response'], "REFUSE")

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_ai_queue.py
```py
import sys
import os
import json
import time
import hashlib
import redis

# Add parent dir to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from dotenv import load_dotenv
load_dotenv(os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), '.env.local'))

REDIS_URL = os.environ.get("REDIS_URL", "redis://localhost:6379/0")

def push_task():
    r = redis.from_url(REDIS_URL, decode_responses=True)
    
    context = {
        'mode': 'SUN',
        'trump': None,
        'hand': [{'rank': 'A', 'suit': '‚ô†'}, {'rank': '10', 'suit': '‚ô†'}],
        'table': [],
        'position': 'Bottom',
        'phase': 'BIDDING', # Test Bidding
        'currentBid': {'type': 'PASS'},
        'scores': {'us': 0, 'them': 0},
        'dealerIndex': 0,
        'myIndex': 1,
        'round': 1
    }
    
    state_str = json.dumps(context, sort_keys=True)
    context_hash = hashlib.md5(state_str.encode()).hexdigest()
    
    payload = {
        'context_hash': context_hash,
        'timestamp': time.time(),
        'game_context': context
    }
    
    print(f"Pushing task {context_hash} to queue...")
    r.lpush("bot:analyze_queue", json.dumps(payload))
    
    # Poll for result
    print("Waiting for result...")
    for i in range(10):
        res = r.get(f"bot:move:{context_hash}")
        if res:
            print(f"\nSUCCESS! AI Brain Reply: {res}")
            return
        time.sleep(1)
        print(".", end="", flush=True)
        
    print("\nTIMEOUT: No result from worker.")

if __name__ == "__main__":
    push_task()

```

### FILE: tests\test_ai_worker_coverage.py
```py
import pytest
from unittest.mock import MagicMock, patch
import sys

# Mock Redis (still needed for BrainClient import inside agent)
mock_redis_module = MagicMock()
class MockPubSubWorkerThread: pass
mock_redis_module.client.PubSubWorkerThread = MockPubSubWorkerThread
sys.modules['redis'] = mock_redis_module

from ai_worker.agent import BotAgent, bot_agent
from ai_worker.personality import BALANCED

class TestAIWorkerCoverage:
    
    @pytest.fixture
    def mock_game_state(self):
        return {
            'phase': 'BIDDING',
            'players': [
                {'index': 0, 'name': 'Bot1', 'hand': [{'rank': 'A', 'suit': 'S', 'id': 'AS'}], 'is_bot': True},
                {'index': 1, 'name': 'Player2', 'hand': [], 'is_bot': False},
                {'index': 2, 'name': 'Player3', 'hand': [], 'is_bot': False},
                {'index': 3, 'name': 'Dealer', 'hand': [], 'is_bot': False}
            ],
            'currentTurnIndex': 0,
            'dealerIndex': 3,
            'floorCard': {'rank': '7', 'suit': 'H', 'id': '7H'},
            'scores': {'us': 0, 'them': 0},
            'matchScores': {'us': 0, 'them': 0},
            'bid': None,
            'sawaState': {'active': False},
            'gameId': 'mock_game_1'
        }

    def test_get_decision_bidding_pass(self, mock_game_state):
        """Verify bot passes with weak hand (Brain returns None)"""
        # Mock BrainClient on the instance
        with patch.object(bot_agent.brain, 'lookup_move', return_value=None):
             # Mock Strategy to return PASS (via integration or just ensure logic falls through)
             # BiddingStrategy defaults are verified elsewhere, here we test the flow
             
             decision = bot_agent.get_decision(mock_game_state, 0)
             
             # Fallback logic should reach strategy or default
             # Given weak hand, strategy likely outputs PASS
             assert decision['action'] == 'PASS'


    def test_brain_override(self, mock_game_state):
        """Verify bot uses brain move if found by BrainClient"""
        mock_brain_move = {"action": "PLAY", "rank": "A", "suit": "S", "reason": "Strategic Win"}
        
        mock_game_state['phase'] = 'PLAYING'
        mock_game_state['bid'] = {'type': 'HOKUM', 'bidder': 1}
        
        with patch.object(bot_agent.brain, 'lookup_move', return_value=mock_brain_move):
            
            decision = bot_agent.get_decision(mock_game_state, 0)
            
            assert decision['action'] == 'PLAY'
            assert decision['cardIndex'] == 0
            assert "Brain Override" in decision['reasoning']

    def test_referee_qayd(self, mock_game_state):
        """Verify referee intercepts illegal move with Qayd claim"""
        mock_game_state['phase'] = 'PLAYING'
        mock_game_state['tableCards'] = [
             {'card': {'rank': 'K', 'suit': 'D'}, 'playedBy': 1, 'metadata': {'is_illegal': True}}
        ]
        
        # Test direct referee check via Agent
        # Note: BotAgent calls self.referee.check_qayd
        
        decision = bot_agent.get_decision(mock_game_state, 0)
        
        assert decision['action'] == 'QAYD_CLAIM'

    def test_referee_sawa(self, mock_game_state):
        """Verify referee responds to Sawa claim"""
        # Setup Sawa State: Player 1 (Opponent) claims Sawa
        mock_game_state['sawaState'] = {
            'active': True,
            'status': 'PENDING',
            'claimer': 'Right', # Assuming Player 1 is Right relative to Bot (0)
            'responses': {}
        }
        # Bot needs context to know positions, mock it via ctx or raw state
        # BotContext derives position from player data.
        mock_game_state['players'][0]['position'] = 'Bottom'
        mock_game_state['players'][1]['position'] = 'Right'
        
        # Test: Bot should respond (ACCEPT by default if no masters)
        decision = bot_agent.get_decision(mock_game_state, 0)
        
        assert decision['action'] == 'SAWA_RESPONSE'
        assert decision['response'] in ['ACCEPT', 'REFUSE']

```

### FILE: tests\test_akka.py
```py

import unittest
import sys
import os

# Add parent directory to path to import game modules
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from game_logic import Game, Card, Player

from room_manager import RoomManager
from game_logic import ORDER_HOKUM, ORDER_SUN

class TestAkkaLogic(unittest.TestCase):
    def setUp(self):
        self.game = Game("test_room")
        # Debug: Check play_card signature
        import inspect
        print(f"DEBUG: play_card args: {inspect.getfullargspec(Game.play_card)}")
        
        self.game.add_player("p1", "Player 1")
        self.game.add_player("p2", "Player 2")
        self.game.add_player("p3", "Player 3")
        self.game.add_player("p4", "Player 4")
        
        # Manually set up game state for testing to avoid randomness
        self.game.players[0].hand = [] # Clear hands
        
        # Start game (generates deck)
        self.game.start_game()
        
        # Force HOKUM mode
        # By bypassing handle_bid which is complex, we just set state
        self.game.game_mode = 'HOKUM'
        self.game.trump_suit = '‚ô†'
        self.game.phase = 'PLAYING'
        self.game.current_turn = 0
        self.game.table_cards = []
        self.game.round_history = []
        
    def test_akka_eligibility_simple(self):
        """Test simplest Akka scenario: Leading with Ace of non-trump"""
        p1 = self.game.players[0]
        # Give him A, K Hearts
        p1.hand = [Card('‚ô•', 'A'), Card('‚ô•', 'K')]
        
        # Check eligibility
        eligible_suits = self.game.check_akka_eligibility(0)
        print(f"Eligible Suits: {eligible_suits}")
        self.assertIn('‚ô•', eligible_suits)
        
    def test_akka_eligibility_king_after_ace_played(self):
        """Test Akka with King after Ace is gone"""
        p1 = self.game.players[0]
        p1.hand = [Card('‚ô•', 'K'), Card('‚ô•', 'Q')]
        
        # Simulate Ace being played in previous trick
        # round_history structure: [{'cards': [{'rank': 'A', 'suit': '‚ô•', ...}, ...], 'winner': ...}]
        self.game.round_history.append({
            'cards': [
                {'rank': 'A', 'suit': '‚ô•', 'playedBy': 'Right'},
                {'rank': '10', 'suit': '‚ô•', 'playedBy': 'Top'},
                {'rank': '8', 'suit': '‚ô•', 'playedBy': 'Left'},
                {'rank': '9', 'suit': '‚ô•', 'playedBy': 'Bottom'}
            ],
            'winner': 'Right'
        })
        
        eligible_suits = self.game.check_akka_eligibility(0)
        print(f"Eligible Suits (King): {eligible_suits}")
        self.assertIn('‚ô•', eligible_suits)

    def test_play_card_with_akka(self):
        """Test playing a card with Akka metadata updates state"""
        p1 = self.game.players[0]
        p1.hand = [Card('‚ô•', 'A'), Card('‚ô¶', '7')]
        
        # Play Ace with Akka
        # We need to make sure it is valid move
        # Table empty, leading Ace. Valid.
        
        res = self.game.play_card(0, 0, metadata={'akka': True})
        
        if not res.get('success'):
             print(f"Play Card Failed: {res}")
             
        self.assertTrue(res['success'])
        self.assertIsNotNone(self.game.akka_state)
        self.assertEqual(self.game.akka_state['suit'], '‚ô•')
        self.assertEqual(self.game.akka_state['claimer'], p1.position)

    def test_play_card_invalid_akka(self):
        """Test playing Akka when not eligible"""
        p1 = self.game.players[0]
        p1.hand = [Card('‚ô•', '7'), Card('‚ô•', '8')] 
        # Ace is NOT played. 7 is low.
        
        # Try to play 7 with Akka
        res = self.game.play_card(0, 0, metadata={'akka': True})
        
        self.assertFalse(res.get('success'))
        self.assertIn('error', res)
        # Ensure akka_state is NOT set
        self.assertIsNone(self.game.akka_state)

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_akka_strict.py
```py
import unittest
from game_logic import Game, Player, Card, GamePhase

class TestAkkaStrict(unittest.TestCase):
    def setUp(self):
        self.game = Game("test_room")
        self.game.add_player("p1", "Player 1")
        self.game.add_player("p2", "Player 2")
        self.game.add_player("p3", "Player 3")
        self.game.add_player("p4", "Player 4")
        self.game.start_game()
        
        # Set to Playing phase manually
        self.game.phase = GamePhase.PLAYING.value
        self.p1 = self.game.players[0]
        self.p2 = self.game.players[1]
        
    def test_akka_mode_restriction(self):
        # 1. SUN Mode -> Akka disabled
        self.game.game_mode = 'SUN'
        self.p1.hand = [Card('‚ô•', 'K')]
        # Make Ace played
        self.game.round_history = [{'cards': [{'rank': 'A', 'suit': '‚ô•'}, {'rank': '7', 'suit': '‚ô•'}, {'rank': '8', 'suit': '‚ô•'}, {'rank': '9', 'suit': '‚ô•'}]}]
        
        eligible = self.game.check_akka_eligibility(0)
        self.assertEqual(eligible, [], "Should be empty in SUN mode")

    def test_akka_trump_restriction(self):
        # 2. Trump Suit -> Akka disabled
        self.game.game_mode = 'HOKUM'
        self.game.trump_suit = '‚ô†' # Spades is trump
        
        # Player has master of Trump (J in Hokum)
        # Or let's say King of Trump (if J/9 played) - logic handles strict trump exclusion
        self.p1.hand = [Card('‚ô†', 'K')]
        
        eligible = self.game.check_akka_eligibility(0)
        self.assertEqual(eligible, [], "Should be empty for Trump suit")

    def test_akka_ace_restriction(self):
        # 3. Ace -> Akka disabled (Self-evident)
        self.game.game_mode = 'HOKUM'
        self.game.trump_suit = '‚ô†'
        
        # Player has Ace of Hearts (Non-Trump)
        self.p1.hand = [Card('‚ô•', 'A')]
        
        eligible = self.game.check_akka_eligibility(0)
        self.assertEqual(eligible, [], "Should be empty for Ace")

    def test_akka_valid_scenario(self):
        # 4. Valid Scenario: 10 of Hearts is master (Ace played)
        self.game.game_mode = 'HOKUM'
        self.game.trump_suit = '‚ô†'
        
        self.p1.hand = [Card('‚ô•', '10')]
        
        # Determine that Ace is played
        self.game.round_history = [{'cards': [{'rank': 'A', 'suit': '‚ô•'}, {'rank': '7', 'suit': '‚ô¶'}, {'rank': '8', 'suit': '‚ô¶'}, {'rank': '9', 'suit': '‚ô¶'}]}]
        
        eligible = self.game.check_akka_eligibility(0)
        self.assertEqual(eligible, ['‚ô•'], "Should be eligible for Hearts")

    def test_akka_invalid_scenario(self):
        # 5. Invalid Scenario: 10 of Hearts, but Ace NOT played
        self.game.game_mode = 'HOKUM'
        self.game.trump_suit = '‚ô†'
        
        self.p1.hand = [Card('‚ô•', '10')]
        self.game.round_history = [] # Nothing played
        self.game.table_cards = []
        
        eligible = self.game.check_akka_eligibility(0)
        self.assertEqual(eligible, [], "Should NOT be eligible if Ace is unplayed")

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_ashkal.py
```py

import unittest
from game_logic import Game, Player, GamePhase

class TestAshkal(unittest.TestCase):
    def setUp(self):
        self.game = Game("test")
        # Add 4 players
        # Index assignments:
        # P1 -> Index 0 (Dealer) - Position Bottom?
        # Game add_player logic: first added is first in list.
        # Dealer Index default is 0.
        
        self.game.add_player("1", "Dealer") # Idx 0
        self.game.add_player("2", "Right")  # Idx 1
        self.game.add_player("3", "Partner")# Idx 2
        self.game.add_player("4", "Left")   # Idx 3
        
        self.game.dealer_index = 0
        self.game.phase = GamePhase.BIDDING.value
        self.game.bidding_round = 1
        
        # Mock deal
        # Note: sort_hand expects Unicode Suit symbols ‚ô†, ‚ô•, ‚ô£, ‚ô¶
        self.game.floor_card = type('Card', (object,), {'suit': '‚ô†', 'rank': 'A', 'to_dict': lambda: {}})()
        for p in self.game.players:
             p.hand = [] # Empty hand mock

    def test_ashkal_valid_dealer(self):
        # Dealer is Index 0.
        # It must be Dealer's turn to bid? 
        # Ashkal button only appears when it's your turn.
        self.game.current_turn = 0 
        
        res = self.game.handle_bid(0, "ASHKAL")
        self.assertTrue(res.get("success"), f"Dealer should be allowed to Ashkal. Error: {res.get('error')}")
        self.assertEqual(self.game.game_mode, "SUN")
        # Player 0 is Bottom usually in standard deal
        self.assertEqual(self.game.bid['bidder'], "Bottom")

    def test_ashkal_valid_left_opponent(self):
        # Left of Dealer (0) is Index 3. 
        self.game.current_turn = 3
        
        res = self.game.handle_bid(3, "ASHKAL")
        self.assertTrue(res.get("success"), f"Left Opponent should be allowed to Ashkal. Error: {res.get('error')}")
        self.assertEqual(self.game.game_mode, "SUN")
        self.assertEqual(self.game.bid['bidder'], "Left")
        
    def test_ashkal_invalid_right_opponent(self):
        # Right of Dealer (0) is Index 1.
        self.game.current_turn = 1
        
        res = self.game.handle_bid(1, "ASHKAL")
        self.assertFalse(res.get("success"))
        self.assertEqual(res.get("error"), "Only Dealer or Left Opponent can call Ashkal")

    def test_ashkal_invalid_partner(self):
        # Partner of Dealer (0) is Index 2.
        self.game.current_turn = 2
        
        res = self.game.handle_bid(2, "ASHKAL")
        self.assertFalse(res.get("success"))
        self.assertEqual(res.get("error"), "Only Dealer or Left Opponent can call Ashkal")

    def test_ashkal_valid_round_2(self):
        self.game.bidding_round = 2
        self.game.current_turn = 0 # Dealer
        
        res = self.game.handle_bid(0, "ASHKAL")
        self.assertTrue(res.get("success"), "Ashkal should be allowed in Round 2")
        self.assertEqual(self.game.game_mode, "SUN")

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_ashkal_rules.py
```py

import unittest
from game_engine.logic.bidding_engine import BiddingEngine
from game_engine.models.constants import BiddingPhase, BidType

class MockPlayer:
    def __init__(self, idx, pos, team):
        self.index = idx
        self.position = pos
        self.team = team
        self.hand = [] # Needed for Kawesh checks potentially

class MockCard:
    def __init__(self, rank, suit):
        self.rank = rank
        self.suit = suit
    def to_dict(self):
        return {'rank': self.rank, 'suit': self.suit}

class TestAshkalRules(unittest.TestCase):
    def setUp(self):
        # Dealer = 0 (Bottom) -> Turn Order: Right(1), Top(2), Left(3), Bottom(0)
        self.players = [
            MockPlayer(0, 'Bottom', 'us'),
            MockPlayer(1, 'Right', 'them'),
            MockPlayer(2, 'Top', 'us'),
            MockPlayer(3, 'Left', 'them')
        ]
        self.floor_not_ace = MockCard('7', '‚ô•')
        self.floor_ace = MockCard('A', '‚ô•')
        
    def test_ashkal_eligibility_round_1(self):
        """Test Ashkal in Round 1. Only Dealer(0) and Left(3) eligible."""
        dealer_idx = 0
        engine = BiddingEngine(dealer_idx, self.floor_not_ace, self.players, {'us':0, 'them':0})
        
        # 1. Right (1) [Prio 0] - Cannot Ashkal
        res = engine.process_bid(1, 'ASHKAL')
        self.assertFalse(res.get('success'), "Right Opponent (1) should NOT be eligible")
        engine.process_bid(1, 'PASS') # Pass to move turn
        
        # 2. Top (2) [Partner, Prio 1] - Cannot Ashkal
        res = engine.process_bid(2, 'ASHKAL')
        self.assertFalse(res.get('success'), "Partner (2) should NOT be eligible")
        engine.process_bid(2, 'PASS') # Pass
        
        # 3. Left (3) [Prio 2] - ELIGIBLE
        # Since 0 and 1 passed, Prio 2 is highest available. Should finalize immediately?
        res = engine.process_bid(3, 'ASHKAL')
        self.assertTrue(res.get('success'), f"Left (3) should be eligible. Err: {res.get('error')}")
        self.assertEqual(engine.contract.is_ashkal, True)
        self.assertEqual(engine.contract.type, BidType.SUN)
        self.assertEqual(engine.contract.bidder_idx, 1) # Partner of 3 is 1 (Right)
        
    def test_ashkal_dealer_eligibility(self):
        """Test Dealer (0) Ashkal Eligibility"""
        engine = BiddingEngine(0, self.floor_not_ace, self.players, {'us':0, 'them':0})
        # Reset turns by passing everyone up to Dealer
        engine.process_bid(1, 'PASS')
        engine.process_bid(2, 'PASS')
        engine.process_bid(3, 'PASS')
        
        # Dealer (0) [Prio 3]
        res = engine.process_bid(0, 'ASHKAL')
        self.assertTrue(res.get('success'))
        self.assertEqual(engine.contract.is_ashkal, True)
        self.assertEqual(engine.contract.bidder_idx, 2) # Partner of 0 is 2 (Top)

    def test_ashkal_round_2(self):
        """Test Ashkal in Round 2"""
        engine = BiddingEngine(0, self.floor_not_ace, self.players, {'us':0, 'them':0})
        # Round 1 Passes
        engine.process_bid(1, 'PASS')
        engine.process_bid(2, 'PASS')
        engine.process_bid(3, 'PASS')
        engine.process_bid(0, 'PASS')
        
        self.assertEqual(engine.phase, BiddingPhase.ROUND_2)
        
        # Round 2: Right(1) passes
        engine.process_bid(1, 'PASS')
        
        # Partner(2) passes
        engine.process_bid(2, 'PASS')
        
        # Left(3) calls Ashkal in R2
        res = engine.process_bid(3, 'ASHKAL')
        self.assertTrue(res.get('success'), "Ashkal should be allowed in Round 2")
        self.assertEqual(engine.contract.is_ashkal, True)
        self.assertEqual(engine.contract.type, BidType.SUN)

    def test_ashkal_ace_constraint(self):
        """Cannot call Ashkal if floor is Ace"""
        engine = BiddingEngine(0, self.floor_ace, self.players, {'us':0, 'them':0})
        engine.process_bid(1, 'PASS')
        engine.process_bid(2, 'PASS')
        
        res = engine.process_bid(3, 'ASHKAL')
        self.assertFalse(res.get('success'))
        self.assertIn("Ace", res.get('error', ''))

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_baloot_project.py
```py

import sys
import os

# Add parent directory to path to import game_logic
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from game_logic import validate_project, Card

def test_baloot_project_valid():
    # Setup: Hokum mode, Trump = Hearts
    game_mode = 'HOKUM'
    trump_suit = '‚ô•'
    
    # Hand: K‚ô•, Q‚ô•, 7‚ô†, 8‚ô†, 9‚ô†
    hand = [
        Card('‚ô•', 'K'),
        Card('‚ô•', 'Q'),
        Card('‚ô†', '7'),
        Card('‚ô†', '8'),
        Card('‚ô†', '9')
    ]
    
    result = validate_project(hand, 'BALOOT', game_mode, trump_suit)
    
    if result['valid'] and result['type'] == 'BALOOT' and result['score'] == 20:
        print("PASS: Baloot detected correctly.")
    else:
        print(f"FAIL: Expected Baloot valid, got {result}")

def test_baloot_project_invalid_suit():
    # Setup: Hokum mode, Trump = Hearts
    game_mode = 'HOKUM'
    trump_suit = '‚ô•'
    
    # Hand: K‚ô†, Q‚ô† (Not trump), ...
    hand = [
        Card('‚ô†', 'K'),
        Card('‚ô†', 'Q'),
        Card('‚ô†', '7'),
        Card('‚ô†', '8'),
        Card('‚ô†', '9')
    ]
    
    result = validate_project(hand, 'BALOOT', game_mode, trump_suit)
    
    if not result['valid']:
        print("PASS: Non-trump Baloot rejected.")
    else:
        print(f"FAIL: Expected Invalid, got {result}")

def test_baloot_project_invalid_mode():
    # Setup: SUN mode (Baloot invalid in Sun)
    game_mode = 'SUN'
    trump_suit = None
    
    # Hand: K‚ô•, Q‚ô•
    hand = [
        Card('‚ô•', 'K'),
        Card('‚ô•', 'Q'),
        Card('‚ô†', '7'),
        Card('‚ô†', '8'),
        Card('‚ô†', '9')
    ]
    
    result = validate_project(hand, 'BALOOT', game_mode, trump_suit)
    
    if not result['valid']:
        print("PASS: Sun Baloot rejected.")
    else:
        print(f"FAIL: Expected Invalid in Sun, got {result}")

if __name__ == "__main__":
    try:
        test_baloot_project_valid()
        test_baloot_project_invalid_suit()
        test_baloot_project_invalid_mode()
        print("All Baloot tests completed.")
    except Exception as e:
        print(f"ERROR: {e}")

```

### FILE: tests\test_bidding_engine.py
```py

import unittest
import time
from game_engine.logic.bidding_engine import BiddingEngine, BiddingPhase, BidType

class MockPlayer:
    def __init__(self, idx, pos, team):
        self.index = idx
        self.position = pos
        self.team = team

class MockCard:
    def __init__(self, rank, suit):
        self.rank = rank
        self.suit = suit
    def to_dict(self):
        return {'rank': self.rank, 'suit': self.suit}

class TestBiddingEngine(unittest.TestCase):
    def setUp(self):
        self.players = [
            MockPlayer(0, 'Bottom', 'us'),
            MockPlayer(1, 'Right', 'them'),
            MockPlayer(2, 'Top', 'us'),
            MockPlayer(3, 'Left', 'them')
        ]
        # Dealer is 3 (Left). Prio: 0, 1, 2, 3
        self.floor_card = MockCard('7', '‚ô•')
        self.floor_card = MockCard('7', '‚ô•')
        self.engine = BiddingEngine(dealer_index=3, floor_card=self.floor_card, players=self.players, match_scores={'us': 0, 'them': 0})

    def test_sun_firewall_rule(self):
        # Case A: Scores satisfy firewall (Us=120, Them=50)
        # Testing Sun Bid by Us (0), Double by Them (1)
        # Bidder > 100, Doubler < 100 -> OK
        scores_valid = {'us': 120, 'them': 50}
        engine = BiddingEngine(dealer_index=3, floor_card=self.floor_card, players=self.players, match_scores=scores_valid)
        
        engine.process_bid(0, "SUN", None) 
        engine._finalize_auction() # Force to Doubling Phase

        res = engine.process_bid(1, "DOUBLE", "OPEN") # Variant ignored for Sun but okay
        self.assertTrue(res.get('success'), f"Double Allowed. Msg: {res.get('error')}")
        self.assertEqual(engine.contract.level, 2)
        
        # Case B: Scores FAIL firewall (Us=80, Them=50) -> Bidder too low
        scores_invalid = {'us': 80, 'them': 50}
        engine_fail = BiddingEngine(dealer_index=3, floor_card=self.floor_card, players=self.players, match_scores=scores_invalid)
        
        engine_fail.process_bid(0, "SUN", None)
        engine_fail._finalize_auction()

        res_fail = engine_fail.process_bid(1, "DOUBLE", None)
        self.assertIn("error", res_fail)
        self.assertIn("Firewall Active", res_fail['error'])
        self.assertEqual(engine_fail.contract.level, 1, "Double rejected")

    def test_priority_queue(self):
        self.assertEqual(self.engine.priority_queue, [0, 1, 2, 3])

    def test_sun_hijack_with_priority(self):
        # 0 Passes
        self.engine.process_bid(0, 'PASS')
        
        # 1 Bids Hokum
        res = self.engine.process_bid(1, 'HOKUM', '‚ô•')
        self.assertTrue(res['success'])
        self.assertEqual(self.engine.contract.type, BidType.HOKUM)
        self.assertEqual(self.engine.contract.bidder_idx, 1)

        # 2 Bids Sun
        # Priority Queue: [0, 1, 2, 3]. 
        # 1 (Current Contract) is higher priority than 2.
        # So when 2 bids, it should trigger Gablak Window for 1.
        
        res = self.engine.process_bid(2, 'SUN')
        self.assertTrue(res['success'])
        self.assertEqual(res.get('status'), 'GABLAK_TRIGGERED')
        
        # Now 1 must decide. 
        # If 1 Passes (Waives hijack right)
        res = self.engine.process_bid(1, 'PASS')
        self.assertEqual(res.get('status'), 'WAIVED_GABLAK')
        
        # To simulate timeout in test: modify gablak_timer_start locally
        self.engine.gablak_timer_start -= 10 # Force timeout
        
        # Retry finalizing (Any action triggers check? Or separate 'poll' endpoint? logic calls process_bid)
        # Assuming UI would invoke a check or next polling call updates state.
        # Using process_bid again with ANY valid action from ANYONE usually triggers timeout check first.
        # Let's say 2 (who is eager) clicks Sun again?
        res = self.engine.process_bid(2, 'SUN')
        self.assertEqual(res.get('status'), 'GABLAK_TIMEOUT')
        
        # NOW check if contract updated
        self.assertEqual(self.engine.contract.type, BidType.SUN, "Contract should update to Sun after timeout")
        self.assertEqual(self.engine.contract.bidder_idx, 2)
        self.assertEqual(self.engine.phase, BiddingPhase.DOUBLING)

    def test_gablak_interrupt(self):
        # Reset Engine
        self.engine = BiddingEngine(dealer_index=3, floor_card=self.floor_card, players=self.players, match_scores={'us': 0, 'them': 0})
        
        # 0 Passes.
        res = self.engine.process_bid(0, 'PASS')
        self.assertTrue(res['success'])
        
        # Turn is now 1.
        # 2 tries to bid. (Strict turn order says "Not your turn").
        res = self.engine.process_bid(2, 'HOKUM', '‚ô•')
        self.assertEqual(res.get('error'), 'Not your turn', "Strict turn order should block P2 if P1 hasn't acted")

    def test_doubling_chain(self):
        # Setup specific scores to allow Sun Doubling (Firewall: Bidder > 100, Doubler < 100)
        self.engine.match_scores = {'us': 120, 'them': 50} 

        # 0 Bids Sun
        self.engine.process_bid(0, 'SUN')
        self.assertEqual(self.engine.phase, BiddingPhase.DOUBLING)
        
        # 1 (Opponent) Doubles
        res = self.engine.process_bid(1, 'DOUBLE')
        self.assertEqual(self.engine.contract.level, 2)
        
        # 2 (Partner of Taker) Triples
        res = self.engine.process_bid(2, 'TRIPLE')
        self.assertEqual(self.engine.contract.level, 3)
        
        # 3 (Opponent) Fours
        res = self.engine.process_bid(3, 'FOUR')
        self.assertEqual(self.engine.contract.level, 4)
        
        # 0 (Taker) Gahwa
        res = self.engine.process_bid(0, 'GAHWA')
        self.assertEqual(self.engine.contract.level, 100)

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_bidding_engine_unit.py
```py
import pytest
import time
from game_engine.logic.bidding_engine import BiddingEngine, BiddingPhase, BidType, ContractState
from game_engine.models.card import Card

class MockPlayer:
    def __init__(self, index, team, position):
        self.index = index
        self.team = team
        self.position = position
        self.hand = []

@pytest.fixture
def players():
    return [
        MockPlayer(0, 'us', 'Bottom'),
        MockPlayer(1, 'them', 'Right'),
        MockPlayer(2, 'us', 'Top'),
        MockPlayer(3, 'them', 'Left')
    ]

@pytest.fixture
def floor_card():
    return Card('‚ô†', '7')

@pytest.fixture
def engine(players, floor_card):
    # Dealer is P3 (Left). First turn is P0.
    return BiddingEngine(dealer_index=3, floor_card=floor_card, players=players, match_scores={'us': 0, 'them': 0})

def test_initial_state(engine):
    assert engine.phase == BiddingPhase.ROUND_1
    assert engine.current_turn == 0
    assert engine.priority_queue == [0, 1, 2, 3]

def test_pass_round_1_all(engine):
    for i in range(4):
        res = engine.process_bid(i, "PASS")
        assert res.get("success") is True
    assert engine.phase == BiddingPhase.ROUND_2

def test_pass_round_1_and_2_all(engine):
    # Pass R1
    for i in range(4): engine.process_bid(i, "PASS")
    # Pass R2
    for i in range(4): engine.process_bid(i, "PASS")
    assert engine.phase == BiddingPhase.FINISHED
    assert engine.contract.type is None

def test_hokum_bid_round_1_success(engine):
    # P0 bids Hokum Spades (floor suit)
    res = engine.process_bid(0, "HOKUM", suit='‚ô†')
    assert res.get("success") is True
    assert engine.contract.type == BidType.HOKUM
    assert engine.contract.bidder_idx == 0
    assert engine.current_turn == 1

def test_hokum_bid_round_1_wrong_suit(engine):
    res = engine.process_bid(0, "HOKUM", suit='‚ô•')
    assert res.get("error") == "Round 1 Hokum must be floor suit"

def test_sun_bid_hijack_hokum_directly(engine):
    # P0 bids Sun (Highest Priority)
    res = engine.process_bid(0, "SUN")
    assert res.get("success") is True
    assert res.get("phase_change") == "DOUBLING"
    assert engine.contract.type == BidType.SUN
    assert engine.contract.bidder_idx == 0

def test_gablak_trigger_simple(engine):
    # If P0 passes, P1 is turn. 
    engine.process_bid(0, "PASS")
    # If P1 (turn) bids, and P0 has already passed R1, no Gablak window should trigger 
    # because no one with BETTER priority is "Available" (Has not passed current round).
    res = engine.process_bid(1, "HOKUM", suit='‚ô†')
    assert res.get("success") is True
    assert engine.contract.type == BidType.HOKUM

def test_gablak_priority_steal_window(engine):
    # Rotate to P2
    engine.process_bid(0, "PASS")
    engine.process_bid(1, "PASS")
    
    # P2 bids HOKUM. P0 and P1 have passed, so no Gablak.
    res = engine.process_bid(2, "HOKUM", suit='‚ô†')
    assert res.get("success") is True
    assert engine.phase == BiddingPhase.ROUND_1
    
    # Now P3 (Dealer) wants to bid SUN. 
    # Wait, it's P3's turn now. 
    # If P3 bids SUN, P2 (who bid Hokum) is higher priority? 
    # self.priority_queue is [0, 1, 2, 3]. P2 (index 2) is priority 2. P3 (index 3) is priority 3.
    # P2 is indeed higher priority than P3.
    res = engine.process_bid(3, "SUN")
    assert res.get("status") == "GABLAK_TRIGGERED"
    assert engine.phase == BiddingPhase.GABLAK_WINDOW

def test_doubling_chain(engine):
    # 1. Finalize an auction (P0 bids Sun)
    engine.process_bid(0, "SUN")
    assert engine.phase == BiddingPhase.DOUBLING
    
    # Set scores to allow SUN doubling firewall
    engine.match_scores = {'us': 150, 'them': 50}
    
    # 2. P1 (Opponent) Doubles
    res = engine.process_bid(1, "DOUBLE")
    assert res.get("success") is True
    assert engine.contract.level == 2
    
    # 3. P0 (Taker) Triples
    res = engine.process_bid(0, "TRIPLE")
    assert res.get("success") is True
    assert engine.contract.level == 3
    
    # 4. P3 (Opponent Partner) Fours
    res = engine.process_bid(3, "FOUR")
    assert res.get("success") is True
    assert engine.contract.level == 4
    
    # 5. P2 (Partner of P0 - Taker Team) Gahwa
    res = engine.process_bid(2, "GAHWA")
    assert res.get("success") is True
    assert engine.contract.level == 100

def test_sun_double_firewall(engine):
    # Set scores below threshold
    engine.match_scores = {'us': 50, 'them': 50}
    engine.process_bid(0, "SUN") # Taker: P0 (us)
    
    # P1 (them) tries to double. 
    res = engine.process_bid(1, "DOUBLE")
    assert res.get("error") is not None
    assert "Firewall Active" in res.get("error")

def test_variant_selection(engine):
    # 1. Hokum Bid
    engine.process_bid(0, "HOKUM", suit='‚ô†')
    # Finalize contract by passing around
    engine.process_bid(1, "PASS")
    engine.process_bid(2, "PASS")
    engine.process_bid(3, "PASS")
    
    assert engine.phase == BiddingPhase.DOUBLING
    
    # 2. P1 (Opponent) doubles
    engine.process_bid(1, "DOUBLE")
    
    # 3. Everyone passes to end doubling phase
    # Current implementation: ONE pass from anyone in doubling phase transitions if Hokum
    res = engine.process_bid(2, "PASS") 
    
    assert res.get("phase_change") == "VARIANT_SELECTION"
    assert engine.phase == BiddingPhase.VARIANT_SELECTION
    assert engine.current_turn == 0 # P0 is bidder
    
    # 4. P0 selects OPEN
    res = engine.process_bid(0, "OPEN")
    assert res.get("success") is True
    assert engine.contract.variant == "OPEN"
    assert engine.phase == BiddingPhase.FINISHED

def test_kawesh_pre_bid(engine, players):
    # P0 has zero point hand
    p0 = players[0]
    p0.hand = [Card('‚ô†', '7'), Card('‚ô†', '8'), Card('‚ô†', '9'), Card('‚ô•', '7'), Card('‚ô•', '8')]
    
    res = engine.process_bid(0, "KAWESH")
    assert res.get("success") is True
    assert res.get("action") == "REDEAL"
    assert res.get("rotate_dealer") is False

def test_kawesh_post_bid_rotation(engine, players):
    # 1. P0 bids Sun
    engine.process_bid(0, "SUN")
    
    # 2. P1 has zero point hand
    p1 = players[1]
    p1.hand = [Card('‚ô†', '7'), Card('‚ô†', '8'), Card('‚ô†', '9'), Card('‚ô•', '7'), Card('‚ô•', '8')]
    
    res = engine.process_bid(1, "KAWESH")
    assert res.get("success") is True
    assert res.get("action") == "REDEAL"
    assert res.get("rotate_dealer") is True

```

### FILE: tests\test_bidding_rules.py
```py
import pytest
from game_engine.logic.game import Game
from game_engine.models.player import Player
from game_engine.models.card import Card
from game_engine.models.constants import BiddingPhase

@pytest.fixture
def game():
    g = Game("test_room")
    g.add_player("p1", "Player 1")
    g.add_player("p2", "Player 2")
    g.add_player("p3", "Player 3")
    g.add_player("p4", "Player 4")
    g.start_game()
    return g

def test_ashkal_ace_constraint(game):
    """Test that Ashkal is rejected if Floor Card is an Ace"""
    # 1. Setup: Force Floor Card to be Ace of Hearts
    game.floor_card = Card('‚ô•', 'A')
    if game.bidding_engine:
        game.bidding_engine.floor_card = game.floor_card
    
    # Advance to Dealer's turn 
    for i in range(3):
        idx = (game.dealer_index + 1 + i) % 4
        game.handle_bid(idx, "PASS")
        
    game.current_turn = game.dealer_index 
    
    # 2. Attempt Ashkal
    res = game.handle_bid(game.current_turn, "ASHKAL")
    
    # 3. Assert Failure
    assert res.get("error") == "Ashkal banned on Ace"
    assert game.bid["type"] is None

def test_ashkal_success_non_ace(game):
    """Test that Ashkal works if Floor Card is NOT an Ace"""
    # 1. Setup: Force Floor Card to be King of Hearts
    game.floor_card = Card('‚ô•', 'K')
    if game.bidding_engine:
         game.bidding_engine.floor_card = game.floor_card
    
    # 2. Advance to Dealer's turn by passing others
    for i in range(3):
        idx = (game.dealer_index + 1 + i) % 4
        game.handle_bid(idx, "PASS")
    
    game.current_turn = game.dealer_index 
    
    # 3. Attempt Ashkal
    res = game.handle_bid(game.current_turn, "ASHKAL")
    
    # 4. Assert Success (Since no one better exists, it finalizes)
    assert res.get("success") is True
    assert game.bid["type"] == "SUN"
    # Bidder should be PARTNER (dealer index + 2)
    partner_pos = game.players[(game.dealer_index + 2) % 4].position
    assert game.bid["bidder"] == partner_pos
    # Verify card was taken (Ashkal logic: Bidder takes it, but usually Partner gets it? 
    # Current implementation says: "Calling Ashkal buys the card as Sun, but the card is given to the Partner".
    # Wait, existing logic in `handle_bid` logic: `player.action_text = "ASHKAL"`. `self.complete_deal(player_index)`.
    # Does `complete_deal` give it to partner?
    # `game_logic.py` L550 just calls `complete_deal(player_index)`.
    # The rulebook says: "card is given to the Partner".
    # I need to check `complete_deal` or `handle_bid` logic again.
    # Currently `handle_bid` for Ashkal calls `complete_deal(player_index)` which gives to BIDDER (caller).
    # THIS IS A BUG found during test writing! The user who calls Ashkal (Dealer) usually PASSES the card to partner?
    # Or Ashkal means "I buy for my partner".
    # "Ashkal... buys the card as Sun, but the card is given to the Partner, not the caller."
    # I need to fix this in game_logic.py!
    pass

def test_kawesh_success(game):
    """Test using Kawesh to redeal (Pre-Bid: Same Dealer)"""
    # 1. Setup Zero Value Hand
    player = game.players[game.current_turn]
    player.hand = [
        Card('‚ô†', '7'), Card('‚ô†', '8'), Card('‚ô†', '9'),
        Card('‚ô•', '7'), Card('‚ô•', '8')
    ]
    
    old_dealer = game.dealer_index
    # Sync Engine
    if game.bidding_engine:
         game.bidding_engine.current_turn = game.current_turn

    # 2. Attempt Kawesh (Pre-Bid -> Same Dealer)
    res = game.handle_bid(game.current_turn, "KAWESH")
    
    assert res.get("success") is True
    assert res.get("action") == "REDEAL"
    assert "Same Dealer" in res.get("message")
    assert game.dealer_index == old_dealer # Retained

def test_kawesh_fail_with_points(game):
    """Test Kawesh rejected if hand has points"""
    player = game.players[game.current_turn]
    # Give player points (Ace)
    player.hand = [
        Card('‚ô†', 'A'), Card('‚ô†', '8'), Card('‚ô†', '9'),
        Card('‚ô•', '7'), Card('‚ô•', '8')
    ]
    if game.bidding_engine:
         game.bidding_engine.current_turn = game.current_turn
    
    res = game.handle_bid(game.current_turn, "KAWESH")
    assert res.get("error") == "Cannot call Kawesh with points (A, K, Q, J, 10) in hand"

def test_kawesh_post_bid_rotation(game):
    """Test using Kawesh AFTER a bid (Post-Bid: Next Dealer)"""
    # 1. Setup: P1 bids SUN
    game.floor_card = Card('‚ô•', 'K') # Ensure floor is not Ace for Ashkal/etc
    p1_idx = game.current_turn
    game.handle_bid(p1_idx, "SUN")
    
    # 2. Setup: P2 (Next Player) has Zero Value Hand
    p2_idx = (p1_idx + 1) % 4
    player = game.players[p2_idx]
    player.hand = [
        Card('‚ô†', '7'), Card('‚ô†', '8'), Card('‚ô†', '9'),
        Card('‚ô•', '7'), Card('‚ô•', '8')
    ]
    
    old_dealer = game.dealer_index
    
    # Force turn to P2 (Engine auto-rotates, but ensuring sync)
    if game.bidding_engine:
         game.bidding_engine.current_turn = p2_idx
         game.current_turn = p2_idx

    # 3. Attempt Kawesh (Post-Bid -> Rotate Dealer)
    res = game.handle_bid(p2_idx, "KAWESH")
    
    assert res.get("success") is True
    assert res.get("action") == "REDEAL"
    assert "Dealer Rotation" in res.get("message")
    
    # Check Rotation
    expected_dealer = (old_dealer + 1) % 4
    assert game.dealer_index == expected_dealer

def test_round_2_hukum_restriction(game):
    """Test rejection of Hukum bid on Floor Card suit in Round 2"""
    # 1. Advance to Round 2
    game.bidding_round = 2
    game.floor_card = Card('‚ô†', 'K') # Spades
    # Reset phase and sync floor card
    if game.bidding_engine: 
        game.bidding_engine.phase = BiddingPhase.ROUND_2
        game.bidding_engine.floor_card = game.floor_card
    
    # 2. Attempt Hukum Spades
    res = game.handle_bid(game.current_turn, "HOKUM", suit='‚ô†')
    
    assert res.get("error") == "Cannot bid floor suit in Round 2"
    
    # 3. Attempt Hukum Hearts (Valid)
    res = game.handle_bid(game.current_turn, "HOKUM", suit='‚ô•')
    assert res.get("success") is True

```

### FILE: tests\test_bot_crash.py
```py
import time
from game_logic import Game, GamePhase
from ai_worker.agent import bot_agent
import traceback

def run_bot_simulation():
    print("Starting Bot Logic Crash Test...")
    game = Game("bot_sim_room")
    
    # Add Players (All Bots)
    players = []
    for i in range(4):
        p = game.add_player(f"bot_p{i}", f"BotAgent {i}")
        p.is_bot = True # Mark as bot for logic if needed (though we drive manually)
        players.append(p)
        
    print("Players added.")
    
    if not game.start_game():
        print("Failed to start game.")
        return

    round_count = 0
    while game.phase != GamePhase.FINISHED.value and round_count < 200:
        current_idx = game.current_turn
        current_p = game.players[current_idx]
        
        print(f"--- Turn: {current_p.name} ({game.phase}) ---")
        
        try:
            # Get decision from BotAgent
            # We must pass the serialized game state as the bot expects
            game_state = game.get_game_state()
            decision = bot_agent.get_decision(game_state, current_idx)
            print(f"Decision: {decision}")
            
            action = decision.get('action')
            res = {'success': False}
            
            if game.phase == "BIDDING":
                # Bot returns string action usually? 
                # BotAgent returns {"action": "SUN"} etc.
                if action:
                    res = game.handle_bid(current_idx, action, decision.get('suit'))
                else:
                    print("Error: No action in decision")
                    
            elif game.phase == "PLAYING":
                card_idx = decision.get('cardIndex', 0)
                # Check bounds
                if card_idx < 0 or card_idx >= len(current_p.hand):
                     print(f"CRASH POTENTIAL: Invalid Card Index {card_idx} for hand size {len(current_p.hand)}")
                
                res = game.play_card(current_idx, card_idx)
                
            print(f"Result: {res}")
            
            if not res.get('success'):
                # If bot makes invalid move, it might loop forever or crash
                print("Invalid Move! Stopping to prevent loop.")
                break
                
        except Exception:
            print("CRASH DETECTED IN BOT LOGIC!")
            traceback.print_exc()
            break
            
        round_count += 1
        
    print("Bot Simulation Ended.")
    print(f"Phase: {game.phase}")

if __name__ == "__main__":
    run_bot_simulation()

```

### FILE: tests\test_bot_kawesh.py
```py
import pytest
from ai_worker.agent import BotAgent

@pytest.fixture
def bot():
    return BotAgent()

def create_card(rank, suit):
    return {'rank': rank, 'suit': suit}

@pytest.fixture
def kawesh_hand():
    return [
        create_card('7', '‚ô†'), create_card('8', '‚ô†'), create_card('9', '‚ô†'),
        create_card('7', '‚ô•'), create_card('8', '‚ô•')
    ]

@pytest.fixture
def normal_hand():
    return [
        create_card('A', '‚ô†'), create_card('K', '‚ô†'), create_card('Q', '‚ô†'),
        create_card('J', '‚ô•'), create_card('10', '‚ô•')
    ]

def test_kawesh_pre_bid(bot, kawesh_hand):
    """Case A: No bids yet -> Call Kawesh"""
    game_state = {
        'biddingPhase': 'ROUND_1',
        'matchScores': {'us': 0, 'them': 0},
        'bid': {'type': None, 'bidder': None},
        'floorCard': {'rank': 'K', 'suit': '‚ô¶'}
    }
    player = {'index': 0, 'position': 'Bottom', 'hand': kawesh_hand}
    
    decision = bot.get_bidding_decision(game_state, player)
    assert decision['action'] == "KAWESH"
    assert "Standard Gravity" in decision['reasoning']

def test_kawesh_opponent_bid(bot, kawesh_hand):
    """Case B: Opponent Bids -> Call Kawesh (Tactical Nuke)"""
    # Opponent is Right (1) or Left (3) relative to Bottom (0)
    game_state = {
        'biddingPhase': 'ROUND_1',
        'matchScores': {'us': 0, 'them': 0},
        'bid': {'type': 'SUN', 'bidder': 'Right'}, 
        'floorCard': {'rank': 'K', 'suit': '‚ô¶'}
    }
    player = {'index': 0, 'position': 'Bottom', 'hand': kawesh_hand}
    
    decision = bot.get_bidding_decision(game_state, player)
    assert decision['action'] == "KAWESH"
    assert "Antigravity" in decision['reasoning']

def test_kawesh_partner_bid_safe(bot, kawesh_hand):
    """Case C1: Partner Bids (Safe Score) -> PASS (Friendly Fire)"""
    # Partner is Top (2) relative to Bottom (0)
    game_state = {
        'biddingPhase': 'ROUND_1',
        'matchScores': {'us': 0, 'them': 0},
        'bid': {'type': 'SUN', 'bidder': 'Top'}, 
        'floorCard': {'rank': 'K', 'suit': '‚ô¶'}
    }
    player = {'index': 0, 'position': 'Bottom', 'hand': kawesh_hand}
    
    decision = bot.get_bidding_decision(game_state, player)
    assert decision['action'] == "PASS" # Don't void partner
    assert "Friendly Fire" in decision['reasoning']

def test_kawesh_partner_bid_risky(bot, kawesh_hand):
    """Case C2: Partner Bids (Risk Zone >100 vs <100) -> KAWESH (Safety Nuke)"""
    game_state = {
        'biddingPhase': 'ROUND_1',
        # US > 100, THEM < 100 -> Danger of Double
        'matchScores': {'us': 120, 'them': 50},
        'bid': {'type': 'SUN', 'bidder': 'Top'}, 
        'floorCard': {'rank': 'K', 'suit': '‚ô¶'}
    }
    player = {'index': 0, 'position': 'Bottom', 'hand': kawesh_hand}
    
    decision = bot.get_bidding_decision(game_state, player)
    assert decision['action'] == "KAWESH"
    assert "Safety Nuke" in decision['reasoning']

def test_no_kawesh_with_points(bot, normal_hand):
    """Invalid Hand -> Normal Logic (Not Kawesh)"""
    game_state = {
        'biddingPhase': 'ROUND_1',
        'matchScores': {'us': 0, 'them': 0},
        'bid': {'type': None, 'bidder': None},
        'floorCard': {'rank': 'K', 'suit': '‚ô¶'}
    }
    player = {'index': 0, 'position': 'Bottom', 'hand': normal_hand}
    
    decision = bot.get_bidding_decision(game_state, player)
    # Should bid based on strength (Sun >= 20)
    # Normal hand (A, K, Q...) is very strong Sun.
    assert decision['action'] in ["SUN", "HOKUM", "ASHKAL", "PASS"]
    assert decision['action'] != "KAWESH"

```

### FILE: tests\test_bot_scenarios.py (SKIPPED - >10KB)
### FILE: tests\test_bot_strategies.py
```py

import unittest
from ai_worker.bot_context import BotContext
from ai_worker.strategies.playing import PlayingStrategy
from ai_worker.strategies.bidding import BiddingStrategy
from ai_worker.personality import BALANCED

class MockCard:
    def __init__(self, rank, suit):
        self.rank = rank
        self.suit = suit
        self.points = 0 # Simplified
    def to_dict(self):
        return {'rank': self.rank, 'suit': self.suit}
    def __repr__(self):
        return f"{self.rank}{self.suit}"

class TestBotStrategies(unittest.TestCase):
    def setUp(self):
        self.playing_strategy = PlayingStrategy()
        self.bidding_strategy = BiddingStrategy()
        
    def _create_ctx(self, phase, hand_strs, raw_state_extras=None):
        hand = []
        for s in hand_strs:
            rank = s[:-1]
            suit = s[-1]
            hand.append(MockCard(rank, suit))
            
        raw_state = {
            'bid': {},
            'floorCard': {'rank': '7', 'suit': '‚ô•'}, # Heart Floor
            'roundHistory': [],
            'matchScores': {'us': 0, 'them': 0},
            'biddingPhase': phase,
            'players': [
                {'position': 'Bottom', 'team': 'us', 'hand': [], 'name': 'Me'},
                {'position': 'Right', 'team': 'them', 'hand': [], 'name': 'Bot1'},
                {'position': 'Top', 'team': 'us', 'hand': [], 'name': 'Partner'},
                {'position': 'Left', 'team': 'them', 'hand': [], 'name': 'Bot2'}
            ]
        }
        if raw_state_extras:
            raw_state.update(raw_state_extras)
            
        # Mock Context
        class MockCtx(BotContext):
            def __init__(self, raw, h):
                self.raw_state = raw
                self.hand = h
                self.phase = phase
                self.mode = 'SUN' # Default
                self.table_cards = []
                self.player_index = 0
                self.dealer_index = 0 # I am dealer?
                self.position = 'Bottom'
                self.team = 'us'
                self.memory = None # Mock Memory
                self.personality = BALANCED
                self.floor_card = MockCard(raw['floorCard']['rank'], raw['floorCard']['suit']) if raw.get('floorCard') else None
                # Check Dealer logic
                self.is_dealer = (self.player_index == self.dealer_index)
                self.bidding_round = 1 if phase == 'ROUND_1' else 2 # approx
                self.trump = None
                self.bidding_round_history = []
                
            def is_master_card(self, c): return False # MOCK

        return MockCtx(raw_state, hand)

    def test_ashkal_response_round_1(self):
        """Round 1 Ashkal: Partner (Bidder) wants SAME COLOR (Red). Floor=Hearts."""
        # My Hand: Spades (Black), Clubs (Black), Diamonds (Red)
        # Should play Diamond.
        hand = ['7‚ô†', '8‚ô£', '10‚ô¶', 'K‚ô¶']
        
        # Ashkal Bid by Partner
        bid_state = {
            'isAshkal': True,
            'round': 1,
            'bidder': 'Top', # Partner
            'type': 'SUN'
        }
        
        ctx = self._create_ctx('PLAYING', hand, {'bid': bid_state})
        decision = self.playing_strategy.get_decision(ctx)
        
        self.assertEqual(decision['action'], 'PLAY')
        # Check played card is Diamond (Red)
        played_idx = decision['cardIndex']
        played_card = ctx.hand[played_idx]
        self.assertEqual(played_card.suit, '‚ô¶', f"Round 1 Ashkal (Floor Heart) -> Should play Diamond (Same Color). Got {played_card}")
        self.assertIn("Ashkal", decision['reasoning'])

    def test_ashkal_response_round_2(self):
        """Round 2 Ashkal: Partner wants OPPOSITE COLOR (Black). Floor=Hearts."""
        # My Hand: Spades (Black), Clubs (Black), Diamonds (Red)
        # Should play Spade or Club.
        hand = ['7‚ô†', '8‚ô£', '10‚ô¶', 'K‚ô¶']
        
        bid_state = {
            'isAshkal': True,
            'round': 2,
            'bidder': 'Top',
            'type': 'SUN'
        }
        
        ctx = self._create_ctx('PLAYING', hand, {'bid': bid_state})
        decision = self.playing_strategy.get_decision(ctx)
        
        self.assertEqual(decision['action'], 'PLAY')
        played_idx = decision['cardIndex']
        played_card = ctx.hand[played_idx]
        self.assertIn(played_card.suit, ['‚ô†', '‚ô£'], f"Round 2 Ashkal (Floor Heart) -> Should play Black. Got {played_card}")

    def test_strong_project_ashkal_bid(self):
        """Should Force Ashkal if holding 4 Aces"""
        hand = ['A‚ô†', 'A‚ô£', 'A‚ô¶', 'A‚ô•', '7‚ô†', '8‚ô†', '9‚ô†', '10‚ô†'] # 4 Aces
        
        # Dealer Position (Eligible for Ashkal)
        ctx = self._create_ctx('ROUND_1', hand, {'biddingPhase': 'ROUND_1'})
        ctx.dealer_index = 0
        ctx.player_index = 0 # Dealer
        ctx.is_dealer = True
        # Floor not Ace
        ctx.floor_card = MockCard('7', '‚ô¶')
        ctx.ctx_floor_card = ctx.floor_card # Hack for Mock
        
        decision = self.bidding_strategy.get_decision(ctx)
        
        self.assertEqual(decision['action'], 'ASHKAL')
        self.assertIn("Strong Project", decision['reasoning'])

    def test_strong_project_ashkal_banned_on_ace(self):
        """Should NOT force Ashkal if Floor is Ace"""
        hand = ['A‚ô†', 'A‚ô£', 'A‚ô¶', 'A‚ô•', '7‚ô†', '8‚ô†', '9‚ô†', '10‚ô†'] # 4 Aces
        
        ctx = self._create_ctx('ROUND_1', hand)
        ctx.dealer_index = 0
        ctx.player_index = 0
        ctx.is_dealer = True
        ctx.floor_card = MockCard('A', '‚ô¶') # Ace Floor
        
        decision = self.bidding_strategy.get_decision(ctx)
        
        # Should fall back to SUN or PASS (Sun Score is high, so likely SUN)
        self.assertNotEqual(decision['action'], 'ASHKAL', "Ashkal banned on Ace floor")
        self.assertEqual(decision['action'], 'SUN') # Normal Sun logic takes over

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_bot_strategy.py
```py

import unittest
from ai_worker.agent import BotAgent, BotContext
from game_engine.models.card import Card
from game_engine.models.constants import SUITS

# SUITS = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£']
S, H, D, C = SUITS

class TestBotRefactor(unittest.TestCase):
    def test_calculate_sun_strength(self):
        bot = BotAgent()
        # Hand: A, 10, K, Q (Strong Sun)
        hand = [
            Card(S, 'A'), Card(S, '10'), Card(S, 'K'), Card(S, 'Q'),
            Card(H, '7'), Card(D, '8'), Card(C, '9'), Card(C, 'J')
        ]
        
        score = bot.calculate_sun_strength(hand)
        print(f"Sun Score: {score}")
        # Base: A(10)+10(5)+K(3)+Q(2) = 20.
        # Long Suit (S): 4 cards. (4-3)*2 = +2.
        # Total: 22.
        self.assertGreater(score, 20)

    def test_calculate_hokum_strength(self):
        bot = BotAgent()
        # Hand: J, 9, 7 of Trump (S)
        hand = [
            Card(S, 'J'), Card(S, '9'), Card(S, '7'),
            Card(H, 'A'), Card(D, 'K')
        ]
        score = bot.calculate_hokum_strength(hand, S)
        print(f"Hokum Score: {score}")
        
        # Base: J(12) + 9(10) + 7(1) = 23.
        # Non-Trump: A(5) + K(1) = 6.
        # Trump Count (3) * 2 = 6.
        # Dist: H(1)->+1, D(1)->+1, C(0)->+3. Total +5.
        # Grand Total: 23+6+6+5 = 40.
        
        self.assertEqual(score, 40)

    def test_bot_context_init(self):
        game_state = {
            'phase': 'BIDDING',
            'gameMode': 'SUN',
            'trumpSuit': None,
            'dealerIndex': 0,
            'biddingRound': 1,
            'floorCard': {'suit': H, 'rank': 'A'},
            'tableCards': [],
            'players': [
                {'hand': [{'suit': S, 'rank': 'A'}], 'position': 'Bottom', 'name': 'P1', 'team': 'us'},
                {'hand': [], 'position': 'Right', 'name': 'P2', 'team': 'them'},
                {'hand': [], 'position': 'Top', 'name': 'P3', 'team': 'us'},
                {'hand': [], 'position': 'Left', 'name': 'P4', 'team': 'them'},
            ]
        }
        ctx = BotContext(game_state, 0)
        self.assertEqual(len(ctx.hand), 1)
        self.assertEqual(ctx.hand[0].rank, 'A')
        self.assertEqual(ctx.floor_card.suit, H)
        self.assertTrue(ctx.is_dealer)

    def test_playing_decision_with_declaration(self):
        bot = BotAgent()
        # Hand with Project: K, Q, J of Hearts (Sira)
        hand = [
            {'suit': H, 'rank': 'K'}, {'suit': H, 'rank': 'Q'}, {'suit': H, 'rank': 'J'},
            {'suit': S, 'rank': '7'}
        ]
        
        game_state = {
            'phase': 'PLAYING',
            'gameMode': 'SUN',
            'trumpSuit': None,
            'dealerIndex': 0,
            'currentRoundTricks': [], # Trick 1
            'tableCards': [],
            'players': [
                {'hand': hand, 'position': 'Bottom', 'name': 'P1', 'team': 'us', 'index': 0},
                {'hand': [], 'position': 'Right', 'name': 'P2', 'team': 'them', 'index': 1},
                {'hand': [], 'position': 'Top', 'name': 'P3', 'team': 'us', 'index': 2},
                {'hand': [], 'position': 'Left', 'name': 'P4', 'team': 'them', 'index': 3},
            ]
        }
        
        # Mock memory sync? 
        # bot.sync_memory handles failures gracefully?
        # It relies on game_state props.
        
        decision = bot.get_playing_decision(game_state, game_state['players'][0])
        print(f"Playing Decision: {decision}")
        
        self.assertEqual(decision['action'], 'PLAY')
        # Check declaration
        self.assertIn('declarations', decision)
        # Verify it found the Sira
        # Expected project: {'type': 'SIRA', 'suit': H, 'master': 'K'} (approx)
        self.assertTrue(len(decision['declarations']) > 0)

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_builder.py
```py
from typing import List, Dict, Optional, Any
from game_engine.logic.game import Game
from game_engine.models.player import Player
from game_engine.models.card import Card
from game_engine.models.constants import GamePhase, BiddingPhase, BidType

class TestBuilder:
    def __init__(self):
        self.game = Game("test_room")
        # Default initialization with 4 players
        self.game.players = [
            Player("p1", "Player 1", 0, self.game),
            Player("p2", "Player 2", 1, self.game),
            Player("p3", "Player 3", 2, self.game),
            Player("p4", "Player 4", 3, self.game)
        ]
        self.game.dealer_index = 0
        self.game.current_turn = 1
        
    def with_mode(self, mode: str):
        self.game.game_mode = mode
        return self

    def with_trump(self, suit: str):
        self.game.trump_suit = suit
        return self
        
    def with_phase(self, phase: str):
        # Map string to Enum value if needed, strict for now
        self.game.phase = phase
        return self

    def with_bid(self, type: str, suit: str = None, bidder_idx: int = 0):
        self.game.bid = {
            "type": type,
            "suit": suit,
            "bidder": self.game.players[bidder_idx].position,
            "doubled": False,
            "level": 1
        }
        return self

    def with_hand(self, player_idx: int, card_strs: List[str]):
        """
        Populate a player's hand using short codes.
        e.g. ["AS", "10H", "KD"] -> [Card('S', 'A'), Card('H', '10'), Card('D', 'K')]
        """
        cards = []
        for s in card_strs:
            cards.append(self._parse_card(s))
        self.game.players[player_idx].hand = cards
        return self

    def with_table(self, plays: List[Dict[str, Any]]):
        """
        Setup table cards.
        plays: List of {'p_idx': 0, 'card': 'AS', 'illegal': False}
        """
        self.game.table_cards = []
        for p in plays:
            player = self.game.players[p['p_idx']]
            c_obj = self._parse_card(p['card'])
            entry = {
                "playerId": player.id,
                "card": c_obj,
                "playedBy": player.position,
                "metadata": {"is_illegal": True} if p.get('illegal') else {}
            }
            self.game.table_cards.append(entry)
        return self

    def _parse_card(self, s: str) -> Card:
        # Expected format: "RankSuit" or "10Suit" -> "AS", "10H", "7D"
        # Since 10 is the only 2-char rank, handle it specifically or regex
        # Simple parsing logic from utils/scenarios
        if s.startswith("10"):
            rank = "10"
            suit = s[2]
        else:
            rank = s[0]
            suit = s[1]
        
        # Validate Suit/Rank?
        return Card(suit, rank)

    def build(self) -> Game:
        # Ensure managers are initialized properly if needed
        # (Game.__init__ already handles this)
        return self.game

```

### FILE: tests\test_connection.py
```py
import socketio
import time

sio = socketio.Client()

@sio.event
def connect():
    print("Test Script: Connected to Server!")
    sio.emit('create_room', {}, callback=on_create_room)

def on_create_room(data):
    print(f"Test Script: Room Created! {data}")
    sio.disconnect()

try:
    sio.connect('http://localhost:3005')
    sio.wait()
except Exception as e:
    print(f"Test Script: Connection Failed: {e}")

```

### FILE: tests\test_data_flywheel.py
```py
import sys
import os
import json
import logging
import time

# Add parent dir to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from ai_worker.agent import bot_agent
from dotenv import load_dotenv

# Load env
load_dotenv(os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), '.env.local'))

def test_flywheel():
    print("Testing Data Flywheel...")
    
    if not bot_agent.brain.redis_client:
        print("SKIPPING: No Redis Connection.")
        return

    # Mock Round Snapshot
    snapshot = {
        'roundNumber': 1,
        'winner': 'us',
        'scores': {'us': 26, 'them': 0},
        'timestamp': time.time()
    }
    
    print("Capturing Data...")
    bot_agent.capture_round_data(snapshot)
    
    # Verify Stream
    print("Reading Stream 'analytics:hand_finished'...")
    # Read last entry
    entries = bot_agent.brain.redis_client.xread({'analytics:hand_finished': '0-0'}, count=1)
    
    if entries:
        stream_key, messages = entries[0]
        msg_id, data = messages[0]
        print(f"\nSUCCESS: Found entry in stream!")
        print(f"ID: {msg_id}")
        print(f"Data: {data['data'][:50]}...")
    else:
        print("\nFAILURE: Stream is empty.")

if __name__ == "__main__":
    test_flywheel()

```

### FILE: tests\test_dda.py
```py
import unittest
from unittest.mock import MagicMock
from ai_worker.cognitive import CognitiveOptimizer
from ai_worker.bot_context import BotContext

class TestDDA(unittest.TestCase):
    def setUp(self):
        self.optimizer = CognitiveOptimizer(use_inference=False)
        self.ctx = MagicMock(spec=BotContext)
        self.ctx.raw_state = {}

    def test_mercy_rule(self):
        """Test that budget is reduced when winning big"""
        # Us: 100, Them: 20 -> Diff: +80
        self.ctx.raw_state = { 'matchScores': {'us': 100, 'them': 20} }
        
        budget = self.optimizer._calculate_budget(self.ctx)
        self.assertEqual(budget, 500, "Should use Mercy budget (500) when winning by >50")

    def test_panic_rule(self):
        """Test that budget is increased when losing big"""
        # Us: 20, Them: 100 -> Diff: -80
        self.ctx.raw_state = { 'matchScores': {'us': 20, 'them': 100} }
        
        budget = self.optimizer._calculate_budget(self.ctx)
        self.assertEqual(budget, 5000, "Should use Panic budget (5000) when losing by >50")

    def test_neutral_rule(self):
        """Test that base budget is used in close games"""
        # Us: 50, Them: 40 -> Diff: +10
        self.ctx.raw_state = { 'matchScores': {'us': 50, 'them': 40} }
        
        budget = self.optimizer._calculate_budget(self.ctx)
        self.assertEqual(budget, 2000, "Should use Base budget (2000) in close games")

    def test_mcts_respects_limit(self):
        """Test that MCTSSolver stops at max_iterations"""
        from ai_worker.mcts.mcts import MCTSSolver
        from ai_worker.mcts.fast_game import FastGame
        
        solver = MCTSSolver()
        mock_game = MagicMock(spec=FastGame)
        mock_game.get_legal_moves.return_value = [0, 1]
        mock_game.clone.return_value = mock_game
        # Fix: is_terminal must be True so rollout finishes immediately
        mock_game.is_terminal.return_value = True 
        mock_game.scores = {'us': 0, 'them': 0}
        
        # MCTS needs teams/turn to check for adversarial toggle
        mock_game.teams = ['us', 'them', 'us', 'them']
        mock_game.current_turn = 0
        
        # Run with limit 5
        _, details = solver.search_with_details(mock_game, timeout_ms=5000, max_iterations=5)
        
        # Calculate total visits
        total_visits = sum(d['visits'] for d in details.values())
        
        # It might do 1 extra due to expansion or initial node, but it should be close to 5
        # The loop condition is `iterations >= max_iterations`
        # Each loop creates one node.
        # With max_iterations=5, it runs 5 times.
        # Total visits should match.
        
        # Note: visits are incremented during backprop.
        # If we run 5 iterations, we do 5 backprops.
        self.assertLessEqual(total_visits, 6, "Should not significantly exceed max_iterations")
        self.assertGreaterEqual(total_visits, 5, "Should verify at least max_iterations")

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_feature_extractor.py
```py

import unittest
from unittest.mock import MagicMock
from ai_worker.learning.feature_extractor import FeatureExtractor
from ai_worker.bot_context import BotContext
from game_engine.models.card import Card
from ai_worker.memory import CardMemory

class TestFeatureExtractor(unittest.TestCase):
    def setUp(self):
        self.extractor = FeatureExtractor()
        self.ctx = MagicMock(spec=BotContext)
        self.ctx.hand = []
        self.ctx.memory = MagicMock(spec=CardMemory)
        self.ctx.memory.played_cards = set()
        self.ctx.raw_state = {}
        self.ctx.trump = 'S'
        self.ctx.mode = 'SUN'

    def test_hand_encoding(self):
        """Test that hand cards are encoded correctly"""
        # Spades 7 (First card in standard ordering S, H, D, C | 7..A)
        # S7 should be index 0
        c = Card('S', '7')
        self.ctx.hand = [c]
        
        vec = self.extractor.encode(self.ctx)
        
        self.assertEqual(vec[0], 1.0, "Spades 7 should be index 0")
        self.assertEqual(sum(vec[:32]), 1.0, "Only 1 card in hand")

    def test_dimensions(self):
        """Test vector size is exactly 138"""
        vec = self.extractor.encode(self.ctx)
        self.assertEqual(len(vec), 138)

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_flywheel.py
```py
import requests
import json
import time

BASE_URL = "http://127.0.0.1:3005/react-py4web"
LOG_FILE = "logs/gemini_debug.log"
UNIQUE_REASON = "FLYWHEEL_VERIFICATION_REASON_XYZ"

def test_flywheel():
    print("1. Submitting Training Example...")
    example = {
        "contextHash": f"test-flywheel-{time.time()}",
        "gameState": json.dumps({
            "players": [{"name": "Me", "position": "Bottom", "hand": []}],
            "bid": {"type": "SUN", "suit": None},
            "phase": "Bidding"
        }),
        "badMove": "PASS",
        "correctMove": json.dumps({"action": "SUN"}),
        "reason": UNIQUE_REASON
    }
    
    # Correction: correctMove expects a string in the endpoint usually, but let's check.
    # The endpoint parses request.json.
    # 'correctMove' field in DB is TEXT.
    # In AIStudio, we send: correctMove: batchBid (string) or correctAction (string).
    # So passing a JSON string is correct.
    example["correctMove"] = json.dumps({"action": "SUN"})

    try:
        res = requests.post(f"{BASE_URL}/submit_training", json=example)
        if res.status_code != 200:
            print(f"Failed to submit: {res.text}")
            return
        print("   Submission Successful.")
    except Exception as e:
        print(f"   API Error: {e}")
        return

    print("2. Requesting Strategy (Triggering RAG)...")
    strategy_req = {
        "gameState": {
            "players": [{"name": "Me", "position": "Bottom", "hand": [{"rank": "A", "suit": "S"}]}],
            "bid": {"type": "SUN", "suit": None}, # Matches the example mode
            "phase": "Bidding"
        }
    }
    
    try:
        res = requests.post(f"{BASE_URL}/ask_strategy", json=strategy_req)
        print(f"   Response Code: {res.status_code}")
        # We don't care about the result, only the LOGS.
    except Exception as e:
        print(f"   API Error: {e}")

    print("3. Checking Logs for Injection...")
    time.sleep(1) # Wait for flush
    try:
        found = False
        with open(LOG_FILE, "r", encoding="utf-8") as f:
            # Read last 100 lines maybe? Or all.
            lines = f.readlines()
            for line in lines[-50:]: # Check last 50 lines
                if UNIQUE_REASON in line:
                    found = True
                    break
        
        if found:
            print(f"SUCCESS: Found '{UNIQUE_REASON}' in logs. Flywheel is working!")
        else:
            print(f"FAILURE: Did not find '{UNIQUE_REASON}' in logs.")
            print("Tail of logs:")
            print("".join(lines[-10:]))
            
    except Exception as e:
        print(f"   Log Read Error: {e}")

if __name__ == "__main__":
    test_flywheel()

```

### FILE: tests\test_full_scenario.py
```py

import sys
import os
import logging
from unittest.mock import MagicMock

# Setup environment to load local modules
sys.path.append(os.getcwd())

from game_logic import Game, Player, Card

# Mock SIO to avoid server dependencies
class MockSIO:
    def emit(self, *args, **kwargs): pass
    def start_background_task(self, *args, **kwargs): pass

# Setup Game
game = Game("test_room")
game.sio = MockSIO()

# Add Players
for i in range(4):
    game.add_player(f"p{i}", f"Player {i}")

game.start_game()

# --- TEST 1: ASHKAL BIDDING & SCORING ---
print("--- TEST 1: ASHKAL SCORING ---")
# Force Dealer to P0
game.dealer_index = 0
game.current_turn = 1
game.phase = "BIDDING"
game.bidding_round = 1

# P0 (Dealer) passes
game.handle_bid(1, "PASS") # P1
game.handle_bid(2, "PASS") # P2
game.handle_bid(3, "PASS") # P3

# P0 calls ASHKAL
print("P0 (Dealer) calling ASHKAL...")
res = game.handle_bid(0, "ASHKAL")
print(f"Bid Result: {res}")

if game.game_mode == "SUN" and game.bid['type'] == "SUN":
    print("SUCCESS: Game Mode set to SUN correctly for Ashkal.")
else:
    print(f"FAILURE: Game Mode is {game.game_mode}, Bid Type is {game.bid['type']}")

# Check Partner (P2) is bidder
if game.bid['bidder'] == game.players[2].position:
    print("SUCCESS: Partner (P2) became bidder.")
else:
    print(f"FAILURE: Bidder is {game.bid['bidder']}, expected {game.players[2].position}")

# --- TEST 2: PROJECT DEDUPLICATION ---
print("\n--- TEST 2: PROJECT DEDUPLICATION ---")
p2 = game.players[2]
# Give P2 a Sira: A, K, Q Spades
p2.hand = [
    Card('‚ô†', 'A'), Card('‚ô†', 'K'), Card('‚ô†', 'Q'), 
    Card('‚ô•', '7'), Card('‚ô•', '8'), Card('‚ô•', '9'), # Sira Hearts
    Card('‚ô¶', '7'), Card('‚ô¶', '8')
]
# Force turn to P2
game.current_turn = 2
game.phase = "PLAYING"

# Declare SIRA (Spades)
print("Declaring SIRA (First Time)...")
game.handle_declare_project(2, 'SIRA')
count_1 = len(game.trick_1_declarations.get(p2.position, []))
print(f"Count after 1st declare: {count_1}")

# Declare SIRA (Spades) AGAIN - Should be blocked
print("Declaring SIRA (Duplicate)...")
game.handle_declare_project(2, 'SIRA')
count_2 = len(game.trick_1_declarations.get(p2.position, []))
print(f"Count after 2nd declare: {count_2}")

if count_1 == 1 and count_2 == 1:
    print("SUCCESS: Duplicate rejected.")
else:
    print(f"FAILURE: Counts are {count_1} -> {count_2}")

# --- TEST 3: SCORING CALCULATION (Mock End Game) ---
print("\n--- TEST 3: SCORING CALCULATION (Ashkal/Sun) ---")
# Simulate P2 Team taking all tricks (Kaboot) in Sun
game.round_history = [{'winner': p2.position, 'points': 100}] * 8 # Fake
# This bypasses calculation logic, let's call end_round with manually set points?
# Better: Just check calculate_game_points_with_tiebreak for 26 pts

# Test logic: 130 points in Sun -> 26 Game Points
raw_us = 130  # Max raw in Sun
raw_them = 0
game.game_mode = 'SUN'
result = game.scoring_engine.calculate_game_points_with_tiebreak(raw_us, raw_them, 0, 0, 'us')
print(f"Sun 130 pts -> Game Points: {result['game_points']}")

if result['game_points']['us'] == 26:
    print("SUCCESS: 130 raw points = 26 game points in Sun.")
else:
    print(f"FAILURE: Expected 26, got {result['game_points']['us']}")

print("\n--- TESTS COMPLETED ---")

```

### FILE: tests\test_game_logic.py (SKIPPED - >10KB)
### FILE: tests\test_holographic_thought.py
```py

import pytest
from unittest.mock import MagicMock, patch
from ai_worker.professor import Professor
from game_engine.models.card import Card

@pytest.fixture
def mock_game():
    game = MagicMock()
    game.players = [MagicMock(), MagicMock(), MagicMock(), MagicMock()]
    return game

def test_holographic_candidates_extraction():
    """
    Verify that check_move returns 'candidates' when a blunder is detected,
    and that these candidates are correctly ranked.
    """
    prof = Professor()
    prof.enabled = True
    prof.cognitive = MagicMock()
    
    # Mock Analysis
    # Best Move: Index 0 (Win Rate 0.8)
    # Runner Up: Index 1 (Win Rate 0.7)
    # Third: Index 2 (Win Rate 0.6)
    # Bad Move (Human): Index 3 (Win Rate 0.4)
    
    mock_details = {
        0: {'win_rate': 0.8, 'visits': 100},
        1: {'win_rate': 0.7, 'visits': 50},
        2: {'win_rate': 0.6, 'visits': 30},
        3: {'win_rate': 0.4, 'visits': 20}
    }
    
    prof.cognitive.analyze_position.return_value = {
        'best_move': 0,
        'move_values': mock_details
    }
    
    # Mock Player Hand
    human_card = Card('S', '7')
    best_card = Card('S', 'A')
    other_card1 = Card('S', 'K')
    other_card2 = Card('S', 'Q')
    
    player = MagicMock()
    player.hand = [best_card, other_card1, other_card2, human_card]
    player.name = "TestPlayer"
    
    game = MagicMock()
    game.players = [player]
    game.get_game_state.return_value = {} # Mock State
    
    # Mock BotContext to avoid validation errors
    with patch('ai_worker.professor.BotContext') as MockContext:
        MockContext.return_value = MagicMock()
        
        # Test: Human plays index 3 (Bad Move)
        # Expected: Intervention with top 3 candidates (0, 1, 2)
        
        result = prof.check_move(game, 0, 3)
    
        if result is None:
            print("Set -s to see this: Result is None!")
        
        assert result is not None
        assert result['type'] == 'BLUNDER' # 0.8 - 0.4 = 0.4 diff > 0.2
    assert 'candidates' in result
    
    candidates = result['candidates']
    assert len(candidates) == 3
    
    # Check Ranking
    assert candidates[0]['rank'] == 1
    assert candidates[0]['card'] == best_card.to_dict()
    assert candidates[0]['win_rate'] == 0.8
    
    assert candidates[1]['rank'] == 2
    assert candidates[1]['card'] == other_card1.to_dict()
    assert candidates[1]['win_rate'] == 0.7
    
    assert candidates[2]['rank'] == 3
    assert candidates[2]['card'] == other_card2.to_dict()
    
def test_no_intervention_if_optimal():
    prof = Professor()
    prof.cognitive = MagicMock()
    prof.cognitive.analyze_position.return_value = {
        'best_move': 0,
        'move_values': {0: {'win_rate': 0.8, 'visits': 100}}
    }
    
    game = MagicMock()
    player = MagicMock()
    player.hand = [Card('S', 'A')]
    game.players = [player]
    
    # Human plays 0 (Best)
    result = prof.check_move(game, 0, 0)
    assert result is None

```

### FILE: tests\test_kawesh.py
```py
import pytest
from game_engine.logic.utils import is_kawesh_hand
from game_engine.models.card import Card
from game_engine.logic.bidding_engine import BiddingEngine, BiddingPhase, BidType

# Mocks
class MockPlayer:
    def __init__(self, index, hand):
        self.index = index
        self.hand = hand
        self.position = ['Bottom', 'Right', 'Top', 'Left'][index]
        self.team = 'us' if index % 2 == 0 else 'them'
        self.name = f"Player {index}"

def test_is_kawesh_hand_valid():
    """Test that a hand with only 7, 8, 9 is a valid Kawesh hand"""
    # 7s, 8s, 9s
    hand = [
        Card('‚ô†', '7'), Card('‚ô•', '8'), Card('‚ô¶', '9'), Card('‚ô£', '7'), Card('‚ô†', '8')
    ]
    assert is_kawesh_hand(hand) == True

def test_is_kawesh_hand_invalid():
    """Test that a hand with a court card is NOT a valid Kawesh hand"""
    # Contains Ace
    hand = [
        Card('‚ô†', '7'), Card('‚ô•', '8'), Card('‚ô¶', 'A'), Card('‚ô£', '7'), Card('‚ô†', '8')
    ]
    assert is_kawesh_hand(hand) == False
    
    # Contains 10
    hand2 = [
        Card('‚ô†', '7'), Card('‚ô•', '8'), Card('‚ô¶', '10'), Card('‚ô£', '7'), Card('‚ô†', '8')
    ]
    assert is_kawesh_hand(hand2) == False

def test_kawesh_action_in_engine():
    """Test that the engine accepts KAWESH action and returns REDEAL"""
    # Setup
    p0_hand = [Card('‚ô†', '7'), Card('‚ô•', '8'), Card('‚ô¶', '9'), Card('‚ô£', '7'), Card('‚ô†', '8')] # Valid
    p1_hand = [Card('‚ô†', 'A'), Card('‚ô•', 'K'), Card('‚ô¶', 'Q'), Card('‚ô£', 'J'), Card('‚ô†', '10')] # Invalid
    
    players = [
        MockPlayer(0, p0_hand),
        MockPlayer(1, p1_hand),
        MockPlayer(2, []),
        MockPlayer(3, [])
    ]
    
    engine = BiddingEngine(dealer_index=3, floor_card=Card('‚ô†', '7'), players=players, match_scores={})
    
    # Case 1: Player 0 valid Kawesh
    result = engine.process_bid(0, "KAWESH")
    assert result['success'] == True
    assert result['action'] == "REDEAL"
    
    # Case 2: Player 1 invalid Kawesh
    result = engine.process_bid(1, "KAWESH")
    assert 'error' in result

```

### FILE: tests\test_mashaari.py
```py

import unittest
from game_logic import Game, Player, compare_projects, ORDER_PROJECTS

class MockProject:
    def __init__(self, type, rank, score):
        self.type = type
        self.rank = rank
        self.score = score
        
    def __getitem__(self, item):
        return getattr(self, item)

class TestMashaari(unittest.TestCase):
    def setUp(self):
        self.game = Game("test")
        # Setup 4 players
        self.game.add_player("1", "P1") # Dealer + 1 (Right) -> Index 0
        self.game.add_player("2", "P2") # Dealer + 2 (Top) -> Index 1
        self.game.add_player("3", "P3") # Dealer + 3 (Left) -> Index 2
        self.game.add_player("4", "P4") # Dealer (Bottom) -> Index 3 ?? 
        
        # Dealer Index logic in Game:
        # self.dealer_index = 0 initially.
        # current_turn = (dealer + 1) % 4 => 1.
        # Play Order: 1, 2, 3, 0.
        # Distance from Dealer (0):
        # P1 (Idx 1): (1 - 1) % 4 = 0 (Closest)
        # P2 (Idx 2): (2 - 1) % 4 = 1
        # P3 (Idx 3): (3 - 1) % 4 = 2
        # P4 (Idx 0): (0 - 1) % 4 = 3 (Furthest)
        
        self.game.dealer_index = 0 
        
    def test_compare_projects_score(self):
        # 400 vs 100
        p1 = {'type': 'FOUR_HUNDRED', 'rank': 'A', 'score': 40}
        p2 = {'type': 'HUNDRED', 'rank': 'K', 'score': 20}
        
        # P1 better
        self.assertEqual(compare_projects(p1, p2, 'SUN', 0, 1, 2), 1)
        self.assertEqual(compare_projects(p2, p1, 'SUN', 0, 1, 2), -1)

    def test_compare_projects_rank(self):
        # Sira A vs Sira K
        p1 = {'type': 'SIRA', 'rank': 'A', 'score': 4}
        p2 = {'type': 'SIRA', 'rank': 'K', 'score': 4}
        
        self.assertEqual(compare_projects(p1, p2, 'SUN', 0, 1, 2), 1) # A > K
        
    def test_compare_projects_tie_distance(self):
        # Sira A vs Sira A (Different suits, usually impossible for Sequence? 
        # Actually possible: P1 has hearts A-K-Q, P2 has spades A-K-Q.
        
        p1 = {'type': 'SIRA', 'rank': 'A', 'score': 4}
        p2 = {'type': 'SIRA', 'rank': 'A', 'score': 4}
        
        # P1 is Index 1 (Dist 0). P2 is Index 2 (Dist 1).
        # P1 Should win.
        self.assertEqual(compare_projects(p1, p2, 'SUN', 0, 1, 2), 1)
        
        # Reverse indices. P1 at Index 2, P2 at Index 1.
        # P2 Should win (return -1).
        self.assertEqual(compare_projects(p1, p2, 'SUN', 0, 2, 1), -1)

    def test_end_round_mashaari_us_wins(self):
        # Setup: Us (P1, P3) vs Them (P2, P4).
        
        # Avoid Khasara: Make Us the Bidder and give score > 13.
        self.game.bid = {'bidder': 'Bottom', 'type': 'SUN', 'doubled': False} # Bidder Us
        self.game.game_mode = 'SUN'
        
        # declarations
        self.game.declarations = {
            'Top': [{'type': 'SIRA', 'rank': 'A', 'score': 4}], # P3 (Us)
            'Right': [{'type': 'SIRA', 'rank': 'K', 'score': 4}] # P2 (Them)
        }
        
        # Give Us enough points (e.g. 100 raw -> 20 game points)
        self.game.round_history = [{'winner': 'Bottom', 'points': 100, 'cards': []}]
        self.game.match_scores = {'us': 0, 'them': 0}
        
        self.game.end_round(skip_scoring=False)
        
        # Us Points: 
        # Cards: 100 raw + 10 last trick = 110. /10 * 2 = 22.
        # Projects: 4 (Us wins Sira A vs K).
        # Total Us = 26.
        # Them = 0.
        
        # Khasara check: Bidder (Us) has 26 > 13. No Khasara.
        
        self.assertEqual(self.game.match_scores['us'], 26)
        self.assertEqual(self.game.match_scores['them'], 0)

    def test_end_round_mashaari_tie_breaker(self):
        # Tied Projects: Sira A vs Sira A.
        # Them (Right, P2) is Closer. Them wins project.
        
        # Avoid Khasara: Bidder Them. Give points.
        self.game.bid = {'bidder': 'Right', 'type': 'SUN', 'doubled': False} # Bidder Them
        self.game.game_mode = 'SUN'

        self.game.declarations = {
            'Top': [{'type': 'SIRA', 'rank': 'A', 'score': 4}], # Us (Idx 2)
            'Right': [{'type': 'SIRA', 'rank': 'A', 'score': 4}] # Them (Idx 1) -> Winner
        }
        
        # Them gets card points
        self.game.round_history = [{'winner': 'Right', 'points': 100, 'cards': []}]
        self.game.match_scores = {'us': 0, 'them': 0}
        
        self.game.end_round(skip_scoring=False)
        
        # Them:
        # Cards: 110 -> 22.
        # Projects: 4.
        # Total: 26.
        # Us: 0.
        
        self.assertEqual(self.game.match_scores['us'], 0) 
        self.assertEqual(self.game.match_scores['them'], 26)

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_mcts_solver.py
```py
import unittest
from ai_worker.mcts.mcts import MCTSSolver
from ai_worker.mcts.fast_game import FastGame
from game_engine.models.card import Card

class TestMCTSSolver(unittest.TestCase):
    def test_search_with_details(self):
        # Setup a simple endgame state
        # Bot has Ace Hearts. Opponent has King Hearts.
        # Bot leads.
        
        # Hands: 4 players.
        # P0 (Bot): [Ah]
        # P1: [Kh]
        # P2: [2h]
        # P3: [3h]
        
        # Hands: 4 players.
        # P0 (Bot): [Ah]
        # P1: [Kh]
        # P2: [2h]
        # P3: [3h]
        
        hands = [
            [Card('H', 'A')],
            [Card('H', 'K')],
            [Card('H', '7')],
            [Card('H', '8')]
        ]
        
        game = FastGame(
            players_hands=hands,
            trump='H',
            mode='HOKUM',
            current_turn=0,
            dealer_index=0,
            table_cards=[]
        )
        
        solver = MCTSSolver()
        
        # Run search
        best_move, details = solver.search_with_details(game, timeout_ms=500)
        
        # Check output structure
        self.assertIsInstance(best_move, int)
        self.assertIsInstance(details, dict)
        
        print(f"Best Move: {best_move}")
        print(f"Details: {details}")
        
        # We expect detailed stats for the only move (0)
        self.assertTrue(0 in details)
        stats = details[0]
        self.assertIn('visits', stats)
        self.assertIn('wins', stats)
        self.assertIn('win_rate', stats)
        
        # Since Bot has Ace and it's Hokum/Trump Hearts, Bot should win.
        # P0 plays A. P1 plays K. P2 plays 7. P3 plays 8.
        # P0 wins.
        # Win rate should be 1.0 (or close to 1.0 depending on reward normalization).
        # We calculate reward as 0.5 + score_diff/100.
        # Score diff will be positive (Ace=11 + K=4 + ...).
        
        # We expect win_rate > 0.5
        self.assertGreater(stats['win_rate'], 0.5)

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_memory_hall.py
```py

import pytest
from unittest.mock import MagicMock, patch
from ai_worker.memory_hall import MemoryHall
from unittest.mock import MagicMock, patch

@pytest.fixture
def mock_redis():
    with patch('ai_worker.memory_hall.redis') as mock_redis_lib:
        mock_client = MagicMock()
        mock_redis_lib.from_url.return_value = mock_client
        yield mock_client

def test_remember_match(mock_redis):
    hall = MemoryHall()
    hall.redis_client = mock_redis
    
    user_id = "user_123"
    match_data = {
        'winner': 'us',
        'my_partner': 'Khalid',
        'opponents': ['Saad', 'Fahad'],
        'score_us': 152,
        'score_them': 100
    }
    
    hall.remember_match(user_id, "TestUser", match_data)
    
    # Check HINCRBY calls
    # 1. games_played
    mock_redis.hincrby.assert_any_call(f"rivalry:{user_id}", "games_played", 1)
    # 2. wins_vs_ai
    mock_redis.hincrby.assert_any_call(f"rivalry:{user_id}", "wins_vs_ai", 1)
    
    # 3. Relationships
    rel_key = f"rivalry:{user_id}:relationships"
    mock_redis.hincrby.assert_any_call(rel_key, "Khalid:won_with", 1)
    mock_redis.hincrby.assert_any_call(rel_key, "Saad:won_against", 1)
    mock_redis.hincrby.assert_any_call(rel_key, "Fahad:won_against", 1)

def test_get_rivalry_summary(mock_redis):
    hall = MemoryHall()
    hall.redis_client = mock_redis
    
    user_id = "user_123"
    
    # Mock Redis Return Values
    mock_redis.hgetall.side_effect = [
        # First call: rivalry:{user_id}
        {
            'games_played': '10',
            'wins_vs_ai': '6',
            'losses_vs_ai': '4'
        },
        # Second call: rivalry:{user_id}:relationships
        {
           'Saad:lost_to': '3',
           'Fahad:lost_to': '1',
           'Khalid:won_with': '5'
        }
    ]
    
    summary = hall.get_rivalry_summary(user_id)
    
    assert summary['status'] == 'regular'
    assert summary['games_played'] == 10
    assert summary['win_rate'] == 60.0
    assert summary['nemesis'] == 'Saad' # 3 losses
    assert summary['total_wins'] == 6

```

### FILE: tests\test_oracle_bidding.py
```py

import unittest
from unittest.mock import MagicMock
from ai_worker.strategies.oracle_bidding import OracleBiddingStrategy
from ai_worker.bot_context import BotContext
from game_engine.models.card import Card
from ai_worker.memory import CardMemory
from game_engine.models.constants import BiddingPhase

class TestOracleBidding(unittest.TestCase):
    def setUp(self):
        self.oracle = OracleBiddingStrategy()
        
        # Setup specific strong hand
        self.hand = [
            Card('‚ô•', 'A'), Card('‚ô•', '10'), Card('‚ô•', 'K'), Card('‚ô•', 'Q'), 
            Card('‚ô†', 'A'), Card('‚ô†', '10'), Card('‚ô¶', 'A'), Card('‚ô£', 'A')
        ]
        
        self.ctx = MagicMock(spec=BotContext)
        self.ctx.hand = self.hand
        self.ctx.memory = CardMemory()
        self.ctx.raw_state = {
            'dealerIndex': 0,
            'currentRoundTricks': [],
            'tableCards': []
        }
        
    def test_strong_hand_valuation(self):
        """Oracle should give high value to a hand with 4 Aces"""
        summary = self.oracle.evaluate_hand(self.ctx)
        
        print("\nOracle Summary:", summary)
        
        print("\nOracle Summary:", summary)
        
        # New API returns 'details' dict
        sun_details = summary['details'].get('SUN', {})
        sun_ev = sun_details.get('ev', 0)
        
        # With 4 Aces + Strong Hearts, we should win almost all tricks.
        # Max score is 152.
        # We should get at least 100.
        
        self.assertGreater(sun_ev, 50, "Strong hand should have high EV")
        self.assertEqual(summary['best_bid'], 'SUN', "Should recommend SUN for 4 Aces")
        
if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_output.txt
```txt
============================= test session starts =============================
platform win32 -- Python 3.12.10, pytest-7.4.3, pluggy-1.6.0 -- C:\Users\MiEXCITE\AppData\Local\Programs\Python\Python312\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\MiEXCITE\Downloads\py4web\examples\react-py4web
configfile: pytest.ini
plugins: anyio-3.7.1
collecting ... collected 12 items

tests/test_bidding_engine_unit.py::test_initial_state PASSED             [  8%]
tests/test_bidding_engine_unit.py::test_pass_round_1_all PASSED          [ 16%]
tests/test_bidding_engine_unit.py::test_pass_round_1_and_2_all PASSED    [ 25%]
tests/test_bidding_engine_unit.py::test_hokum_bid_round_1_success PASSED [ 33%]
tests/test_bidding_engine_unit.py::test_hokum_bid_round_1_wrong_suit PASSED [ 41%]
tests/test_bidding_engine_unit.py::test_sun_bid_hijack_hokum FAILED      [ 50%]
tests/test_bidding_engine_unit.py::test_gablak_trigger_simple PASSED     [ 58%]
tests/test_bidding_engine_unit.py::test_doubling_chain FAILED            [ 66%]
tests/test_bidding_engine_unit.py::test_sun_double_firewall PASSED       [ 75%]
tests/test_bidding_engine_unit.py::test_variant_selection FAILED         [ 83%]
tests/test_bidding_engine_unit.py::test_kawesh_pre_bid PASSED            [ 91%]
tests/test_bidding_engine_unit.py::test_kawesh_post_bid_rotation PASSED  [100%]

================================== FAILURES ===================================
__________________________ test_sun_bid_hijack_hokum __________________________

engine = <server.bidding_engine.BiddingEngine object at 0x000002C1A12D8950>

    def test_sun_bid_hijack_hokum(engine):
        # P0 bids Hokum
        engine.process_bid(0, "HOKUM", suit='‚ô†')
        # P1 bids Sun (Higher Priority than anyone else for now? No, P1 is lower than P0, but turn is P1)
        res = engine.process_bid(1, "SUN")
        assert res.get("success") is True
>       assert res.get("phase_change") == "DOUBLING"
E       AssertionError: assert None == 'DOUBLING'
E        +  where None = <built-in method get of dict object at 0x000002C1A12E5B00>('phase_change')
E        +    where <built-in method get of dict object at 0x000002C1A12E5B00> = {'status': 'GABLAK_TRIGGERED', 'success': True, 'wait': 5}.get

tests\test_bidding_engine_unit.py:68: AssertionError
_____________________________ test_doubling_chain _____________________________

engine = <server.bidding_engine.BiddingEngine object at 0x000002C1A12DBCB0>

    def test_doubling_chain(engine):
        # 1. Finalize an auction (P0 bids Sun)
        engine.process_bid(0, "SUN")
        assert engine.phase == BiddingPhase.DOUBLING
    
        # 2. P1 (Opponent) Doubles
        res = engine.process_bid(1, "DOUBLE")
>       assert res.get("success") is True
E       AssertionError: assert None is True
E        +  where None = <built-in method get of dict object at 0x000002C1A1350800>('success')
E        +    where <built-in method get of dict object at 0x000002C1A1350800> = {'error': 'Sun Double Rejected. Firewall Active. Scores: us=0, them=0'}.get

tests\test_bidding_engine_unit.py:89: AssertionError
___________________________ test_variant_selection ____________________________

engine = <server.bidding_engine.BiddingEngine object at 0x000002C1A12D9880>

    def test_variant_selection(engine):
        # 1. Hokum Doubled
        engine.process_bid(0, "HOKUM", suit='‚ô†')
        # P1 (Opponent) doubles
        engine.process_bid(1, "DOUBLE")
    
        # Everyone else passes to finish doubling
        engine.process_bid(3, "PASS") # P3 passes doubling
        res = engine.process_bid(2, "PASS") # P2 passes doubling
    
>       assert res.get("phase_change") == "VARIANT_SELECTION"
E       AssertionError: assert None == 'VARIANT_SELECTION'
E        +  where None = <built-in method get of dict object at 0x000002C1A134DA40>('phase_change')
E        +    where <built-in method get of dict object at 0x000002C1A134DA40> = {'error': 'Not enough priority to Gablak/Steal'}.get

tests\test_bidding_engine_unit.py:133: AssertionError
=========================== short test summary info ===========================
FAILED tests/test_bidding_engine_unit.py::test_sun_bid_hijack_hokum - Asserti...
FAILED tests/test_bidding_engine_unit.py::test_doubling_chain - AssertionErro...
FAILED tests/test_bidding_engine_unit.py::test_variant_selection - AssertionE...
========================= 3 failed, 9 passed in 0.07s =========================

```

### FILE: tests\test_professor_mechanics.py
```py
import unittest
from unittest.mock import MagicMock, patch
from ai_worker.professor import Professor
from game_engine.models.card import Card
from game_engine.logic.game import Game

class TestProfessorMechanics(unittest.TestCase):
    def setUp(self):
        self.professor = Professor()
        self.professor.enabled = True
        
        # Mock Game and Player
        self.mock_game = MagicMock(spec=Game)
        self.mock_player = MagicMock()
        self.mock_player.hand = [
            Card('H', 'A'), # Index 0
            Card('H', 'K'), # Index 1
            Card('D', '7')  # Index 2
        ]
        self.mock_game.players = [self.mock_player]
        self.mock_game.get_game_state.return_value = {}

    @patch('ai_worker.professor.BotContext')
    def test_no_blunder_when_optimal(self, MockBotContext):
        """If human plays the best move, no warning."""
        # Mock Context
        MockBotContext.return_value = MagicMock()

        # Mock Analysis: Best move is 0 (Ace)
        analysis_result = {
            'best_move': 0,
            'move_values': {
                0: {'win_rate': 0.8},
                1: {'win_rate': 0.6},
                2: {'win_rate': 0.1}
            }
        }
        self.professor.cognitive.analyze_position = MagicMock(return_value=analysis_result)
        
        # Human plays 0
        result = self.professor.check_move(self.mock_game, 0, 0)
        self.assertIsNone(result)

    @patch('ai_worker.professor.BotContext')
    def test_blunder_detection(self, MockBotContext):
        """If human plays a much worse move, trigger BLUNDER."""
        MockBotContext.return_value = MagicMock()

        # Mock Analysis: Best move is 0 (Ace, 0.8), Human plays 2 (7, 0.1)
        # Diff = 0.7 > 0.25 (Threshold)
        analysis_result = {
            'best_move': 0,
            'move_values': {
                0: {'win_rate': 0.8},
                1: {'win_rate': 0.6},
                2: {'win_rate': 0.1}
            }
        }
        self.professor.cognitive.analyze_position = MagicMock(return_value=analysis_result)
        
        # Human plays 2
        result = self.professor.check_move(self.mock_game, 0, 2)
        
        self.assertIsNotNone(result)
        self.assertEqual(result['type'], 'BLUNDER')
        self.assertIn("better.", result['reason']) # +70% better

    @patch('ai_worker.professor.BotContext')
    def test_mistake_detection(self, MockBotContext):
        """If human plays a moderately worse move, trigger MISTAKE."""
        MockBotContext.return_value = MagicMock()
        
        # Mock Analysis: Best move is 0 (Ace, 0.8), Human plays 1 (King, 0.6)
        # Diff = 0.2. Thresholds: Blunder=0.25, Mistake=0.15
        # Should be MISTAKE
        analysis_result = {
            'best_move': 0,
            'move_values': {
                0: {'win_rate': 0.8},
                1: {'win_rate': 0.6},
                2: {'win_rate': 0.1}
            }
        }
        self.professor.cognitive.analyze_position = MagicMock(return_value=analysis_result)
        
        # Human plays 1
        result = self.professor.check_move(self.mock_game, 0, 1)
        
        self.assertIsNotNone(result)
        self.assertEqual(result['type'], 'MISTAKE')

    @patch('ai_worker.professor.BotContext')
    def test_ignore_minor_diff(self, MockBotContext):
        """If human plays a slightly worse move, ignore it."""
        MockBotContext.return_value = MagicMock()

        # Mock Analysis: Best move is 0 (Ace, 0.8), Human plays 1 (King, 0.78)
        # Diff = 0.02.
        analysis_result = {
            'best_move': 0,
            'move_values': {
                0: {'win_rate': 0.8},
                1: {'win_rate': 0.78},
                2: {'win_rate': 0.1}
            }
        }
        self.professor.cognitive.analyze_position = MagicMock(return_value=analysis_result)
        
        # Human plays 1
        result = self.professor.check_move(self.mock_game, 0, 1)
        
        self.assertIsNone(result)

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_projects_logic.py
```py

import sys
import os

# Add root directory to path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from game_logic import Game, Player, Card, validate_project, compare_projects, sort_hand, SUITS, RANKS, scan_hand_for_projects

# --- Helper Functions ---
def create_hand(cards_str_list):
    """
    Creates a list of Card objects from strings like '7‚ô•', 'A‚ô†'.
    """
    hand = []
    for c_str in cards_str_list:
        rank = c_str[:-1]
        suit = c_str[-1]
        hand.append(Card(suit, rank))
    return hand

def run_tests():
    print("Running tests...")
    
    # Test 1: Scan Sira
    hand = create_hand(['7‚ô•', '8‚ô•', '9‚ô•', 'K‚ô†', 'A‚ô†'])
    projs = scan_hand_for_projects(hand, 'SUN')
    sira = next((p for p in projs if p['type'] == 'SIRA'), None)
    assert sira is not None, "Failed to detect Sira"
    assert sira['rank'] == '9', f"Wrong rank for Sira: {sira['rank']}"
    print("Test 1 (Scan Sira): PASS")

    # Test 2: Validate Project (Integration)
    hand = create_hand(['7‚ô•', '8‚ô•', '9‚ô•'])
    res = validate_project(hand, "SIRA", "SUN")
    assert res['valid'] == True, "Failed to validate SIRA request"
    print("Test 2 (Validate SIRA): PASS")

    # Test 3: Fifty
    hand = create_hand(['7‚ô•', '8‚ô•', '9‚ô•', '10‚ô•'])
    res = validate_project(hand, "FIFTY", "SUN")
    assert res['valid'] == True
    assert res['type'] == 'FIFTY'
    print("Test 3 (Fifty): PASS")

    # Test 4: Hundred Sequence
    hand = create_hand(['7‚ô•', '8‚ô•', '9‚ô•', '10‚ô•', 'J‚ô•'])
    res = validate_project(hand, "HUNDRED", "SUN")
    assert res['valid'] == True
    assert res['type'] == 'HUNDRED'
    print("Test 4 (Hundred Seq): PASS")

    # Test 5: Hundred 4Kind
    hand = create_hand(['K‚ô•', 'K‚ô†', 'K‚ô¶', 'K‚ô£', '7‚ô•'])
    res = validate_project(hand, "HUNDRED", "SUN")
    assert res['valid'] == True
    # Check if 'kind' is mostly internal, but validation shoud pass
    print("Test 5 (Hundred 4Kind): PASS")

    # Test 6: 400
    hand = create_hand(['A‚ô•', 'A‚ô†', 'A‚ô¶', 'A‚ô£', '7‚ô•'])
    res = validate_project(hand, "FOUR_HUNDRED", "SUN")
    assert res['valid'] == True
    print("Test 6 (400): PASS")

    # Test 7: Comparison Hierarchy
    p1 = {'type': 'FOUR_HUNDRED', 'rank': 'A', 'score': 40}
    p2 = {'type': 'HUNDRED', 'rank': 'A', 'score': 20}
    res = compare_projects(p1, p2, "SUN", 0, 1, 2)
    assert res == 1, "400 did not beat 100"
    print("Test 7 (Comparison): PASS")

    # Test 8: Tie Breaker (Rank)
    p1 = {'type': 'SIRA', 'rank': 'A'}
    p2 = {'type': 'SIRA', 'rank': 'K'}
    res = compare_projects(p1, p2, "SUN", 0, 1, 2)
    assert res == 1, "Sira A did not beat Sira K"
    print("Test 8 (Tie Rank): PASS")
    
    # Test 9: Tie Breaker (Position)
    p1 = {'type': 'SIRA', 'rank': '9'}
    p2 = {'type': 'SIRA', 'rank': '9'}
    # P1 index 1, P2 index 2. Dealer 0. P1 is closer.
    res = compare_projects(p1, p2, "SUN", 0, 1, 2)
    assert res == 1, "Position tie-break failed (Expected 1)"
    print("Test 9 (Tie Position): PASS")

if __name__ == "__main__":
    try:
        run_tests()
        print("\nAll Tests Passed!")
    except AssertionError as e:
        print(f"\nTEST FAILED: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"\nERROR: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


```

### FILE: tests\test_qayd_flow.py
```py
"""
Integration test for Qayd (Forensic Investigation) flow.
Tests the complete cycle: illegal move detection ‚Üí Qayd trigger ‚Üí auto-confirm ‚Üí unlock.
"""
import pytest
import json
from game_engine.logic.game import Game
from game_engine.models.card import Card


def create_test_game_with_illegal_setup():
    """Create a game setup where an illegal move can be made"""
    game = Game("test_qayd_room")
    
    # Setup 4 players
    p0 = game.add_player("player0", "Player 0")
    p1 = game.add_player("bot1", "Bot 1")
    p2 = game.add_player("bot2", "Bot 2")
    p3 = game.add_player("bot3", "Bot 3")
    
    # Set bot flags
    p0.is_bot = False
    p1.is_bot = True
    p2.is_bot = True
    p3.is_bot = True
    
    # Start game
    game.start_game()
    
    # Force to PLAYING phase with HOKUM mode
    game.phase = "PLAYING"
    game.game_mode = "HOKUM"
    game.trump_suit = "HEARTS"
    game.current_turn = 0
    
    # Setup hands to create illegal move scenario
    # Player 0 has hearts but will try to play spades (illegal)
    game.players[0].hand = [
        Card("HEARTS", "ACE"),
        Card("HEARTS", "KING"),
        Card("SPADES", "ACE"),  # This will be the illegal card
    ]
    
    # Other players have cards
    for i in range(1, 4):
        game.players[i].hand = [
            Card("HEARTS", "10"),
            Card("DIAMONDS", "JACK"),
        ]
    
    # Start a trick with HEARTS lead
    game.table_cards = [{
        'card': Card("HEARTS", "QUEEN"),
        'playedBy': 'Bottom',
        'metadata': {}
    }]
    game.led_suit = "HEARTS"
    
    return game


def test_qayd_flow_no_freeze():
    """
    Test that Qayd doesn't freeze the game.
    Verifies: detect ‚Üí trigger ‚Üí auto-confirm ‚Üí unlock ‚Üí continue
    """
    game = create_test_game_with_illegal_setup()
    
    # Player 0 tries to play SPADES ACE when they have HEARTS (illegal move)
    # This should be flagged as illegal
    result = game.play_card(0, 2)  # Index 2 = SPADES ACE
    
    # The move should succeed (we allow illegal moves for Qayd detection)
    assert result.get('success'), f"Play card failed: {result}"
    
    # Verify the move was flagged as illegal
    last_play = game.table_cards[-1]
    assert last_play['metadata'].get('is_illegal'), "Move should be flagged as illegal"
    
    # Trigger Qayd (simulating user detection to verify locked state)
    game.players[1].is_bot = False
    qayd_result = game.handle_qayd_trigger(1)  # Player 1 triggers
    
    # Verify Qayd was triggered (Phase 1)
    assert qayd_result.get('success'), f"Qayd trigger failed: {qayd_result}"
    assert game.is_locked, "Game should be locked after Qayd trigger"
    assert game.phase == "CHALLENGE"

    # Confirm Qayd (Phase 2)
    confirm_result = game.handle_qayd_confirm()
    assert confirm_result.get('success'), f"Qayd confirm failed: {confirm_result}"
    
    # CRITICAL: Game should be unlocked after confirm
    assert not game.is_locked, "Game should be unlocked after Qayd confirm"
    
    # Verify Qayd state shows resolution
    assert game.qayd_state.get('status') == 'RESOLVED', \
        f"Qayd should be resolved, got: {game.qayd_state.get('status')}"


def test_qayd_state_serializable():
    """
    Test that Qayd state is JSON-serializable.
    This prevents the serialization error that caused the freeze.
    """
    import json
    game = create_test_game_with_illegal_setup()
    
    # Make illegal move
    game.play_card(0, 2)
    
    # Trigger Qayd
    game.handle_qayd_trigger(1)
    
    # Confirm
    game.handle_qayd_confirm()
    
    # Get qayd state directly (not full game state to avoid schema issues)
    qayd_state = game.qayd_state
    
    # Verify it's JSON-serializable (this would raise TypeError if not)
    try:
        json_str = json.dumps(qayd_state)
        assert json_str, "JSON serialization produced empty string"
    except TypeError as e:
        pytest.fail(f"Qayd state not JSON-serializable: {e}")
    
    # Verify qaydState has expected structure
    assert qayd_state.get('active') is not None, "qaydState.active should be set"
    assert qayd_state.get('status') == 'RESOLVED', "qaydState should be resolved"


def test_qayd_penalty_applied():
    """
    Test that Qayd correctly applies penalty to offending team.
    """
    game = create_test_game_with_illegal_setup()
    
    # Make illegal move
    game.play_card(0, 2)
    
    # Trigger Qayd
    game.handle_qayd_trigger(1)
    
    # Confirm Qayd
    game.handle_qayd_confirm()
    
    # Verify penalty was applied
    # Player 0 is on team 'us', so 'us' should have lost points
    assert game.qayd_state.get('loser_team') == 'us', \
        "Offending team should be marked as loser"
    
    # Verify penalty points were set
    penalty = game.qayd_state.get('penalty_points', 0)
    assert penalty > 0, f"Penalty should be positive, got: {penalty}"


def test_lock_decorator_prevents_timeout():
    """
    Test that @requires_unlocked decorator prevents timeout during Qayd.
    """
    game = create_test_game_with_illegal_setup()
    
    # Make illegal move and trigger Qayd
    game.play_card(0, 2)
    
    # Manually lock the game (simulating mid-Qayd state before auto-confirm)
    game.is_locked = True
    
    # Try to check timeout - should return None due to decorator
    result = game.check_timeout()
    assert result is None, "check_timeout should return None when game is locked"
    
    # Try to auto-play - should return None due to decorator
    result = game.auto_play_card(1)
    assert result is None, "auto_play_card should return None when game is locked"
    
    # Unlock and verify functions work again
    game.is_locked = False
    result = game.check_timeout()
    # Result can be None or dict, but shouldn't raise an error
    assert result is None or isinstance(result, dict), \
        f"check_timeout should work when unlocked, got: {type(result)}"


if __name__ == "__main__":
    # Run tests
    pytest.main([__file__, "-v"])

```

### FILE: tests\test_random_dealer.py
```py
import random
from game_logic import Game

def test_random_dealer_distribution():
    """Run start_game 100 times and check dealer distribution"""
    counts = {0: 0, 1: 0, 2: 0, 3: 0}
    
    for _ in range(100):
        g = Game("test")
        g.add_player("p1", "P1")
        g.add_player("p2", "P2")
        g.add_player("p3", "P3")
        g.add_player("p4", "P4")
        g.start_game()
        counts[g.dealer_index] += 1
        
    print("Dealer Distribution:", counts)
    
    # Assert reasonable distribution (each > 10)
    for i in range(4):
        assert counts[i] > 10, f"Dealer {i} appeared too few times: {counts[i]}"

if __name__ == "__main__":
    test_random_dealer_distribution()

```

### FILE: tests\test_rate_limiter.py
```py
import unittest
from unittest.mock import MagicMock, patch
import time
from server.rate_limiter import RateLimiter

class TestRateLimiter(unittest.TestCase):
    def setUp(self):
        # Mock the redis client within the RateLimiter instance
        self.mock_redis = MagicMock()
        self.limiter = RateLimiter(key_prefix="test_rl")
        self.limiter.redis = self.mock_redis

    def test_basic_limiting_logic(self):
        """Test that it allows N requests and blocks N+1 using Mock"""
        key = "user_1"
        limit = 5
        window = 60
        
        # Scenario: Redis INCR returns 1, 2, 3, 4, 5 (Allowed)
        # Then 6 (Blocked)
        
        # We simulate 6 calls
        # check_limit calls redis.incr
        self.mock_redis.incr.side_effect = [1, 2, 3, 4, 5, 6]
        
        # First 5 should match limit
        for i in range(5):
            allowed = self.limiter.check_limit(key, limit, window)
            self.assertTrue(allowed, f"Request {i+1} should be allowed")
            
        # 6th should fail
        allowed = self.limiter.check_limit(key, limit, window)
        self.assertFalse(allowed, "Request 6 should be blocked")
        
        # Verify INCR was called with correct key format
        # Key format: prefix:key:window_integer
        # We don't check the exact window integer as it depends on time, but we check prefix
        args, _ = self.mock_redis.incr.call_args
        self.assertTrue(args[0].startswith("test_rl:user_1:"), f"Bad key format: {args[0]}")

    def test_fail_open_on_redis_error(self):
        """Test that it returns True (Allowed) if Redis raises exception"""
        self.mock_redis.incr.side_effect = Exception("Connection Down")
        
        allowed = self.limiter.check_limit("user_x", 5, 60)
        self.assertTrue(allowed, "Should fail open (True) on redis error")

    def test_expiry_set_on_first_incr(self):
        """Test that EXPIRE is called when count is 1"""
        self.mock_redis.incr.return_value = 1
        
        self.limiter.check_limit("user_y", 5, 60)
        
        # Verify expire called
        self.mock_redis.expire.assert_called_once()
        args, _ = self.mock_redis.expire.call_args
        self.assertEqual(args[1], 65) # window + 5

    def test_expiry_not_set_on_subsequent_incr(self):
        """Test that EXPIRE is NOT called when count > 1"""
        self.mock_redis.incr.return_value = 2
        
        self.limiter.check_limit("user_z", 5, 60)
        
        self.mock_redis.expire.assert_not_called()

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_resilience.py
```py

from game_logic import Game
import unittest
import logging

# Mute logging for test
logging.basicConfig(level=logging.CRITICAL)

class TestGameResilience(unittest.TestCase):
    def setUp(self):
        self.game = Game("test_room")
        self.p0 = self.game.add_player("p0", "Player 0")
        self.p1 = self.game.add_player("p1", "Player 1")
        self.p2 = self.game.add_player("p2", "Player 2")
        self.p3 = self.game.add_player("p3", "Player 3")
        self.game.start_game()

    def test_invalid_bid_action(self):
        """Test sending garbage action to handle_bid"""
        res = self.game.handle_bid(self.game.current_turn, "GARBAGE_ACTION")
        # Should return error, NOT crash
        self.assertIn('error', res)
        print(f"Invalid Bid Result: {res}")

    def test_bid_out_of_turn(self):
        """Test bidding when not turn"""
        wrong_player = (self.game.current_turn + 1) % 4
        res = self.game.handle_bid(wrong_player, "PASS")
        self.assertIn('error', res)
        print(f"Out of Turn Bid Result: {res}")

    def test_play_card_invalid_index(self):
        """Test playing card with index out of bounds"""
        # Fast forward to playing phase
        # Everyone pass -> Round 2 -> Everyone Pass -> Redeal (Reset)
        # Force phase
        self.game.phase = "PLAYING"
        self.game.current_turn = 0
        self.game.players[0].hand = [1, 2, 3] # Mock hand
        
        # Try index 100
        res = self.game.play_card(0, 100)
        self.assertIn('error', res)
        print(f"Invalid Card Index Result: {res}")

    def test_play_card_wrong_phase(self):
        self.game.phase = "BIDDING"
        res = self.game.play_card(0, 0)
        self.assertIn('error', res)

    def test_declare_project_invalid(self):
        res = self.game.handle_declare_project(0, "SUPER_SECRET_PROJECT")
        self.assertIn('error', res)
        print(f"Invalid Project Result: {res}")

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_room_manager_redis.py
```py
import unittest
from unittest.mock import MagicMock, patch
import pickle
import sys
import os

# Ensure root import
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from server.room_manager import RoomManager
from game_engine.logic.game import Game

class TestRoomManagerRedis(unittest.TestCase):
    def setUp(self):
        # Mock Redis
        self.redis_patcher = patch('server.room_manager.redis_store')
        self.mock_redis = self.redis_patcher.start()
        
        # Reset Singleton
        RoomManager._instance = None
        self.rm = RoomManager()

    def tearDown(self):
        self.redis_patcher.stop()

    def test_save_game_redis(self):
        game = Game("ROOM_TEST")
        # Ensure ID is set
        game.room_id = "ROOM_TEST"
        
        self.rm.save_game(game)
        
        # Assert Redis setex called
        self.mock_redis.setex.assert_called()
        args, _ = self.mock_redis.setex.call_args
        self.assertEqual(args[0], "game:ROOM_TEST") # Key
        self.assertEqual(args[1], 3600) # Expiry

    def test_get_game_redis_hit(self):
        # Setup Redis Hit
        game = Game("ROOM_HIT")
        pickled_game = pickle.dumps(game)
        self.mock_redis.get.return_value = pickled_game
        
        # Action
        retrieved_game = self.rm.get_game("ROOM_HIT")
        
        # Assert
        self.assertIsNotNone(retrieved_game)
        self.assertEqual(retrieved_game.room_id, "ROOM_HIT")
        self.mock_redis.get.assert_called_with("game:ROOM_HIT")
        
    def test_get_game_redis_miss(self):
        # Setup Redis Miss
        self.mock_redis.get.return_value = None
        
        # Action
        retrieved_game = self.rm.get_game("ROOM_MISS")
        
        # Assert
        self.assertIsNone(retrieved_game)

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_rules_output.txt
```txt
============================= test session starts =============================
platform win32 -- Python 3.12.10, pytest-7.4.3, pluggy-1.6.0 -- C:\Users\MiEXCITE\AppData\Local\Programs\Python\Python312\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\MiEXCITE\Downloads\py4web\examples\react-py4web
configfile: pytest.ini
plugins: anyio-3.7.1
collecting ... collected 6 items

tests/test_bidding_rules.py::test_ashkal_ace_constraint PASSED           [ 16%]
tests/test_bidding_rules.py::test_ashkal_success_non_ace PASSED          [ 33%]
tests/test_bidding_rules.py::test_kawesh_success PASSED                  [ 50%]
tests/test_bidding_rules.py::test_kawesh_fail_with_points PASSED         [ 66%]
tests/test_bidding_rules.py::test_kawesh_post_bid_rotation PASSED        [ 83%]
tests/test_bidding_rules.py::test_round_2_hukum_restriction PASSED       [100%]

============================== warnings summary ===============================
..\..\..\..\AppData\Local\Programs\Python\Python312\Lib\site-packages\ombott\request_pkg\props_mixin.py:2
  C:\Users\MiEXCITE\AppData\Local\Programs\Python\Python312\Lib\site-packages\ombott\request_pkg\props_mixin.py:2: DeprecationWarning: 'cgi' is deprecated and slated for removal in Python 3.13
    import cgi

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
======================== 6 passed, 1 warning in 0.26s =========================

```

### FILE: tests\test_sawa.py
```py

import unittest
from ai_worker.bot_context import BotContext
from ai_worker.agent import bot_agent
from game_engine.models.card import Card

class TestSawaLogic(unittest.TestCase):
    def setUp(self):
        pass
        
    def _create_context(self, hand_strs, mode, trump=None, played_cards=None, sawa_claimer='Left'):
        # Construct Mock State
        if played_cards is None: played_cards = []
        
        # Determine Claimer Index vs My Index
        # Me = 0 (Bottom)
        # Left = 3
        claimer_idx = 3 # Left
        
        state = {
            'players': [
                {'hand': [], 'position': 'Bottom', 'team': 'us', 'name': 'Bot'},
                {'hand': [], 'position': 'Right', 'team': 'them', 'name': 'P2'},
                {'hand': [], 'position': 'Top', 'team': 'us', 'name': 'P3'},
                {'hand': [], 'position': 'Left', 'team': 'them', 'name': 'P4'}
            ],
            'phase': 'PLAYING',
            'gameMode': mode,
            'trumpSuit': trump,
            'dealerIndex': 0,
            'currentRoundTricks': [], # We'll mock played_cards via context override or raw state
            'tableCards': [],
            'sawaState': {
                'active': True,
                'status': 'PENDING',
                'claimer': sawa_claimer,
                'responses': {} # I haven't responded
            }
        }
        
        # Populate my hand
        hand_dicts = []
        for s in hand_strs:
            hand_dicts.append({'rank': s[:-1], 'suit': s[-1]})
        state['players'][0]['hand'] = hand_dicts
        
        # Create Context
        ctx = BotContext(state, 0)
        
        # Inject Played Cards for is_master_card logic
        # BotContext derives this from 'currentRoundTricks' and 'tableCards'.
        # We can just override the set for testing.
        ctx.played_cards = set(played_cards)
        
        return ctx

    def test_sawa_acceptance_weak_hand(self):
        """I have weak cards. Should ACCEPT."""
        # SUN Mode. Hand: 7H, 8D.
        # Played: A, 10, K, Q of H and D are GONE.
        # So 7 and 8 are masters? No. 
        # Wait, if all higher cards are played, then 7 IS Master.
        # Sawa Claim means THEY claim to win everything.
        # If I have a Master, I win.
        # So for ACCEPTANCE, I must NOT have a master.
        # This implies higher cards are Still IN PLAY (held by others).
        # e.g. I have 7H. Ace H is NOT played.
        
        ctx = self._create_context(['7‚ô•', '8‚ô¶'], 'SUN', played_cards=[])
        # A‚ô• is unplayed. So 7‚ô• is NOT master.
        
        decision = bot_agent.referee._evaluate_sawa_refusal(ctx)
        self.assertEqual(decision['response'], 'ACCEPT')

    def test_sawa_refusal_master_sun(self):
        """I have Ace in Sun. Should REFUSE."""
        ctx = self._create_context(['A‚ô•', '7‚ô¶'], 'SUN', played_cards=[])
        # A‚ô• is Master.
        
        decision = bot_agent.referee._evaluate_sawa_refusal(ctx)
        self.assertEqual(decision['response'], 'REFUSE')
        self.assertIn('Master', decision['reasoning'])

    def test_sawa_refusal_master_hokum_trump(self):
        """I have Jack of Trump in Hokum. Should REFUSE."""
        ctx = self._create_context(['J‚ô†', '7‚ô¶'], 'HOKUM', trump='‚ô†', played_cards=[])
        # J‚ô† is Master Trump.
        
        decision = bot_agent.referee._evaluate_sawa_refusal(ctx)
        self.assertEqual(decision['response'], 'REFUSE')

    def test_sawa_refusal_master_hokum_nontrump(self):
        """I have Ace of Hearts (Non-Trump) in Hokum. Should REFUSE (Safe Strategy)."""
        ctx = self._create_context(['A‚ô•', '7‚ô¶'], 'HOKUM', trump='‚ô†', played_cards=[])
        # A‚ô• is Master Non-Trump.
        
        decision = bot_agent.referee._evaluate_sawa_refusal(ctx)
        self.assertEqual(decision['response'], 'REFUSE')

    def test_integration_sawa_response(self):
        """Test the full get_decision flow"""
        # Mock Sawa State
        hand = ['A‚ô•']
        ctx = self._create_context(hand, 'SUN')
        
        # Inject context into bot call?
        # bot_agent.get_decision takes (game_state, player_index).
        # We need to construct the state.
        
        state = ctx.raw_state
        idx = 0
        
        # Bot Agent creates its own context. We need to ensure logic holds.
        # Since logic depends on is_master_card which depends on played_cards...
        # We need to populate currentRoundTricks in state to match played_cards logic?
        # Default create_context leaves played_cards empty. 
        # A‚ô• is Master if played_cards empty.
        
        decision = bot_agent.get_decision(state, idx)
        
        self.assertEqual(decision['action'], 'SAWA_RESPONSE')
        self.assertEqual(decision['response'], 'REFUSE')

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_scan.py
```py

import sys
import os

# Mock classes
class Card:
    def __init__(self, suit, rank):
        self.suit = suit
        self.rank = rank
    def __repr__(self):
        return f"{self.rank}{self.suit}"

# Constants from game_logic.py
ORDER_PROJECTS = ['A', 'K', 'Q', 'J', '10', '9', '8', '7']

def scan_hand_for_projects(hand, game_mode):
    projects = []
    ranks = [c.rank for c in hand]
    rank_counts = {r: ranks.count(r) for r in set(ranks)}
    
    # 1. 4 of a kind
    for r, count in rank_counts.items():
        if count == 4:
            if r == 'A' and game_mode == 'SUN':
                projects.append({'type': 'FOUR_HUNDRED', 'rank': 'A', 'score': 40})
            elif r in ['K', 'Q', 'J', '10', 'A']:
                score = 20 if game_mode == 'SUN' else 10
                t = 'HUNDRED'
                if r == 'A' and game_mode != 'SUN': t = 'HUNDRED'
                projects.append({'type': t, 'rank': r, 'score': score})

    # 2. Sequences
    suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£']
    for s in suits:
        suit_cards = sorted([c for c in hand if c.suit == s], key=lambda x: ORDER_PROJECTS.index(x.rank))
        if not suit_cards: continue
        
        current_seq = [suit_cards[0]]
        for i in range(1, len(suit_cards)):
            prev = suit_cards[i-1]
            curr = suit_cards[i]
            idx_prev = ORDER_PROJECTS.index(prev.rank)
            idx_curr = ORDER_PROJECTS.index(curr.rank)
            
            if idx_curr == idx_prev + 1:
                current_seq.append(curr)
            else:
                if len(current_seq) >= 3:
                    add_sequence_project(projects, current_seq, game_mode)
                current_seq = [curr]
        
        if len(current_seq) >= 3:
            add_sequence_project(projects, current_seq, game_mode)
            
    return projects

def add_sequence_project(projects_list, cards, game_mode):
    length = len(cards)
    high_rank = cards[0].rank
    if length >= 5:
        score = 20 if game_mode == 'SUN' else 10
        projects_list.append({'type': 'HUNDRED', 'rank': high_rank, 'score': score})
    elif length == 4:
        score = 10 if game_mode == 'SUN' else 5
        projects_list.append({'type': 'FIFTY', 'rank': high_rank, 'score': score})
    elif length == 3:
        score = 4 if game_mode == 'SUN' else 2
        projects_list.append({'type': 'SIRA', 'rank': high_rank, 'score': score})

# Test Case
hand = [
    Card('‚ô†', 'A'), Card('‚ô†', 'K'), Card('‚ô†', 'Q'), # Sira Spades
    Card('‚ô•', '10'), Card('‚ô•', '9'), Card('‚ô•', '8'), # Sira Hearts
    Card('‚ô¶', '7'), Card('‚ô¶', '8') 
]

print("Test Hand:", hand)
projs = scan_hand_for_projects(hand, "SUN")
print("Projects Found:", projs)

```

### FILE: tests\test_scenarios.py
```py
"""
Test Scenarios - Predefined test scenarios for Baloot game testing

Provides various test scenarios including full games, bidding tests, project tests,
edge cases, and stress testing.
"""

from typing import Dict, List, Optional, Callable
from server.game_logic import Game, SUITS, RANKS
from game_engine.models.card import Card
import random


class ScenarioBase:
    """Base class for test scenarios"""
    
    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
    
    def setup(self, game: Game) -> bool:
        """
        Setup the scenario (e.g., deal specific hands)
        Returns True if setup successful
        """
        return True
    
    def validate(self, game: Game) -> Dict:
        """
        Validate the scenario outcome
        Returns dict with 'success' and 'message'
        """
        return {'success': True, 'message': 'No validation defined'}


class FullGameScenario(ScenarioBase):
    """Complete game from start to finish"""
    
    def __init__(self):
        super().__init__(
            name="Full Game",
            description="Complete game with random hands, plays until FINISHED or GAMEOVER"
        )
    
    def validate(self, game: Game) -> Dict:
        """Validate game completed"""
        if game.phase in ['FINISHED', 'GAMEOVER']:
            return {
                'success': True,
                'message': f"Game completed in phase {game.phase}"
            }
        else:
            return {
                'success': False,
                'message': f"Game did not complete, stuck in phase {game.phase}"
            }


class BiddingTestScenario(ScenarioBase):
    """Test various bidding strategies"""
    
    def __init__(self, bid_type: str = 'SUN'):
        super().__init__(
            name=f"Bidding Test - {bid_type}",
            description=f"Test {bid_type} bidding with strong hands"
        )
        self.bid_type = bid_type
    
    def setup(self, game: Game) -> bool:
        """Give first player a strong hand for the bid type"""
        if self.bid_type == 'SUN':
            # Strong SUN hand: Multiple Aces and Tens
            strong_hand = [
                Card('S', 'A'),
                Card('H', 'A'),
                Card('S', '10'),
                Card('H', '10'),
                Card('D', 'K'),
            ]
            game.players[0].hand = strong_hand
        
        elif self.bid_type == 'HOKUM':
            # Strong HOKUM hand: Jack, 9, Ace in one suit
            strong_hand = [
                Card('S', 'J'),
                Card('S', '9'),
                Card('S', 'A'),
                Card('S', '10'),
                Card('H', 'A'),
            ]
            game.players[0].hand = strong_hand
        
        elif self.bid_type == 'ASHKAL':
            # Very strong SUN hand for ASHKAL
            strong_hand = [
                Card('S', 'A'),
                Card('H', 'A'),
                Card('D', 'A'),
                Card('S', '10'),
                Card('H', '10'),
            ]
            game.players[0].hand = strong_hand
        
        return True
    
    def validate(self, game: Game) -> Dict:
        """Validate bid was made"""
        if game.bid.get('type'):
            return {
                'success': True,
                'message': f"Bid made: {game.bid['type']}"
            }
        else:
            return {
                'success': False,
                'message': "No bid was made"
            }


class ProjectTestScenario(ScenarioBase):
    """Test project declarations"""
    
    def __init__(self, project_type: str = 'FOUR'):
        super().__init__(
            name=f"Project Test - {project_type}",
            description=f"Test {project_type} project declaration"
        )
        self.project_type = project_type
    
    def setup(self, game: Game) -> bool:
        """Give players hands with projects"""
        if self.project_type == 'FOUR':
            # Four of a kind
            project_hand = [
                Card('S', 'K'),
                Card('H', 'K'),
                Card('D', 'K'),
                Card('C', 'K'),
                Card('S', '7'),
            ]
            game.players[0].hand = project_hand
        
        elif self.project_type == 'SEQUENCE':
            # Sequence of 3+ cards
            project_hand = [
                Card('S', 'A'),
                Card('S', 'K'),
                Card('S', 'Q'),
                Card('S', 'J'),
                Card('H', '7'),
            ]
            game.players[0].hand = project_hand
        
        elif self.project_type == 'BALOOT':
            # K and Q of trump (only valid in HOKUM)
            project_hand = [
                Card('S', 'K'),
                Card('S', 'Q'),
                Card('S', 'J'),
                Card('S', '9'),
                Card('H', 'A'),
            ]
            game.players[0].hand = project_hand
            # Force HOKUM bid with Spades as trump
            game.bid = {'type': 'HOKUM', 'suit': 'S', 'playerIndex': 0}
            game.phase = 'PLAYING'
        
        return True
    
    def validate(self, game: Game) -> Dict:
        """Validate project was declared"""
        # Check if any player has declared projects
        for player in game.players:
            if hasattr(player, 'declared_projects') and player.declared_projects:
                return {
                    'success': True,
                    'message': f"Project declared: {player.declared_projects}"
                }
        
        return {
            'success': False,
            'message': "No projects were declared"
        }


class SawaTestScenario(ScenarioBase):
    """Test Sawa (Continue) - claiming all remaining tricks"""
    
    def __init__(self):
        super().__init__(
            name="Sawa Test",
            description="Test Sawa (Continue) claim functionality"
        )
    
    def setup(self, game: Game) -> bool:
        """Setup a scenario where Sawa is likely"""
        # Give player very strong hand
        strong_hand = [
            Card('S', 'A'),
            Card('H', 'A'),
            Card('D', 'A'),
            Card('C', 'A'),
            Card('S', '10'),
        ]
        game.players[0].hand = strong_hand
        return True


class DoubleTestScenario(ScenarioBase):
    """Test doubling functionality"""
    
    def __init__(self):
        super().__init__(
            name="Double Test",
            description="Test game doubling by opponents"
        )
    
    def setup(self, game: Game) -> bool:
        """Setup scenario for doubling"""
        # Give bidder a moderate hand, opponents strong hands
        return True


class StressTestScenario(ScenarioBase):
    """Stress test - multiple consecutive games"""
    
    def __init__(self, num_games: int = 10):
        super().__init__(
            name=f"Stress Test ({num_games} games)",
            description=f"Run {num_games} consecutive games to test stability"
        )
        self.num_games = num_games
        self.completed_games = 0
    
    def validate(self, game: Game) -> Dict:
        """Validate all games completed"""
        self.completed_games += 1
        
        if self.completed_games >= self.num_games:
            return {
                'success': True,
                'message': f"All {self.num_games} games completed successfully"
            }
        else:
            return {
                'success': True,
                'message': f"Game {self.completed_games}/{self.num_games} completed"
            }


class EdgeCaseScenario(ScenarioBase):
    """Test edge cases and unusual situations"""
    
    def __init__(self, case_type: str = 'all_pass'):
        super().__init__(
            name=f"Edge Case - {case_type}",
            description=f"Test edge case: {case_type}"
        )
        self.case_type = case_type
    
    def setup(self, game: Game) -> bool:
        """Setup edge case scenario"""
        if self.case_type == 'all_pass':
            # Give all players weak hands to encourage passing
            weak_hand = [
                Card('S', '7'),
                Card('H', '8'),
                Card('D', '7'),
                Card('C', '8'),
                Card('H', '7'),
            ]
            for player in game.players:
                player.hand = weak_hand.copy()
        
        return True


# === Scenario Registry ===

SCENARIOS = {
    'full_game': FullGameScenario(),
    'bidding_sun': BiddingTestScenario('SUN'),
    'bidding_hokum': BiddingTestScenario('HOKUM'),
    'bidding_ashkal': BiddingTestScenario('ASHKAL'),
    'project_four': ProjectTestScenario('FOUR'),
    'project_sequence': ProjectTestScenario('SEQUENCE'),
    'project_baloot': ProjectTestScenario('BALOOT'),
    'sawa_test': SawaTestScenario(),
    'double_test': DoubleTestScenario(),
    'stress_test': StressTestScenario(10),
    'edge_all_pass': EdgeCaseScenario('all_pass'),
}


def get_scenario(name: str) -> Optional[ScenarioBase]:
    """Get a scenario by name"""
    return SCENARIOS.get(name)


def list_scenarios() -> List[str]:
    """List all available scenario names"""
    return list(SCENARIOS.keys())


def get_scenario_info(name: str) -> Optional[Dict]:
    """Get scenario information"""
    scenario = get_scenario(name)
    if scenario:
        return {
            'name': scenario.name,
            'description': scenario.description
        }
    return None

```

### FILE: tests\test_scoring_comprehensive.py
```py
import unittest
import sys
import os

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from game_engine.logic.game import Game

class TestScoringComprehensive(unittest.TestCase):
    def setUp(self):
        self.game = Game("comp_test_room")
        self.game.add_player("p1", "Player 1") # Bottom (US) - Dealer 0
        self.game.add_player("p2", "Player 2") # Right (THEM)
        self.game.add_player("p3", "Player 3") # Top (US)
        self.game.add_player("p4", "Player 4") # Left (THEM)

    def test_sun_project_scoring(self):
        """Test SUN Game with 400 Project for US"""
        self.game.game_mode = 'SUN'
        self.game.bid = {"type": "SUN", "bidder": "Bottom", "doubled": False} # US Bidder

        # Mock Declarations using Dict (not objects, for simplicity in test setup if possible, or simple dicts as game.py handles dicts)
        # Note: game.py expects list of dicts: {'type': '400', 'rank': 'A', 'suit': 'H', 'priority': 1, 'score': 400}
        self.game.declarations = {
            'Bottom': [{'type': '400', 'rank': 'A', 'suit': 'H', 'priority': 1, 'score': 400}],
            'Right': [], 'Top': [], 'Left': []
        }

        # Mock Tricks: Split points evenly 65 - 65 + 10 Last -> 75, 65? 
        # Total Card Points in SUN: 130 + 10 (Last) = 140?? No, standard counting.
        # Let's say US gets 100 raw points, THEM gets 30.
        
        self.game.round_history = [
            {'winner': 'Right', 'points': 30, 'cards': [], 'playedBy': []}, # THEM gets some points
            {'winner': 'Bottom', 'points': 100, 'cards': [], 'playedBy': []}  # US Last trick
        ]
        # Last trick bonus logic needs round_history[-1]
        
        # end_round calculates card abnat. 
        # Raw: US=100 (+10 Last) = 110. THEM=0.
        # US Project: 400.
        # SUN: Project 400 -> 80 pts. Card 110 -> 22 pts. Total 102.
        
        self.game.end_round()
        
        res_us = self.game.past_round_results[-1]['us']
        
        # Expected:
        # Aklat (Pure Card): 100
        # Ardh (Last Trick): 10
        # ProjectPoints: 400
        # Result (Game Points): 
        #   Card: 110 * 2 / 10 = 22.
        #   Project: 400 * 2 / 10 = 80.
        #   Total: 102.
        
        self.assertEqual(res_us['projectPoints'], 400)
        self.assertEqual(res_us['result'], 102)

    def test_kaboot_with_projects(self):
        """Test Kaboot (All Tricks) in HOKUM with Projects"""
        self.game.game_mode = 'HOKUM'
        self.game.bid = {"type": "HOKUM", "bidder": "Bottom"} # US

        # US wins ALL tricks
        self.game.round_history = [
             {'winner': 'Bottom', 'points': 152, 'cards': [], 'playedBy': []}
        ] # Just one entry enough to trigger logic if other team has 0 count

        # US has 100 project
        self.game.declarations = {
            'Top': [{'type': '100', 'rank': 'A', 'suit': 'S', 'priority': 1, 'score': 100}],
             'Bottom': [], 'Right': [], 'Left': []
        }
        
        self.game.end_round()
        
        res_us = self.game.past_round_results[-1]['us']
        res_them = self.game.past_round_results[-1]['them']

        # HOKUM KABOOT = 25 Points.
        # Project 100 in HOKUM = 100 / 10 = 10 Points.
        # Total US = 35.
        # THEM = 0.
        
        self.assertTrue(res_us['isKaboot'])
        self.assertEqual(res_us['result'], 35, f"Expected 35 (25 Kaboot + 10 Proj), got {res_us['result']}")
        self.assertEqual(res_them['result'], 0)

    def test_khasara_scenario(self):
        """Test Khasara: Bidder fails to score > half"""
        self.game.game_mode = 'HOKUM'
        self.game.bid = {"type": "HOKUM", "bidder": "Bottom"} # US Bid

        # US gets 40, THEM gets 122.
        self.game.round_history = [
             {'winner': 'Right', 'points': 112, 'cards': [], 'playedBy': []}, # THEM
             {'winner': 'Bottom', 'points': 40, 'cards': [], 'playedBy': []}, # US
             {'winner': 'Right', 'points': 0, 'cards': [], 'playedBy': []}  # THEM Last trick -> +10
        ]
        
        self.game.end_round()
        
        res_us = self.game.past_round_results[-1]['us']
        res_them = self.game.past_round_results[-1]['them']
        
        # Raw US: 40 -> 4 pts.
        # Raw THEM: 112 + 10 = 122 -> 12 pts.
        # Total 16.
        # Bidder (US) needs > 8. Has 4. -> Khasara.
        # Result: US=0, THEM=16.
        
        self.assertEqual(res_us['result'], 0)
        self.assertEqual(res_them['result'], 16)
        
    def test_doubling_sun(self):
        """Test Doubling (x2) in SUN"""
        self.game.game_mode = 'SUN'
        self.game.bid = {"type": "SUN", "bidder": "Right"} # THEM Bid
        self.game.doubling_level = 2 # Doubled
        
        # Split scores evenly
        self.game.round_history = [
            {'winner': 'Bottom', 'points': 55, 'cards': [], 'playedBy': []}, # US
            {'winner': 'Right', 'points': 65, 'cards': [], 'playedBy': []},  # THEM (+10 Last = 75)
        ]
        # Raw US: 55 -> 11 pts.
        # Raw THEM: 65 + 10 = 75 -> 15 pts.
        # Total 26.
        
        # Doubled:
        # US: 11 * 2 = 22.
        # THEM: 15 * 2 = 30.
        
        self.game.end_round()
        
        res_us = self.game.past_round_results[-1]['us']
        res_them = self.game.past_round_results[-1]['them']
        
        self.assertEqual(res_us['result'], 22)
        self.assertEqual(res_them['result'], 30)


if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_scoring_debug.py
```py
import unittest
import sys
import os

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from game_logic import Game, Player

class TestScoringDebug(unittest.TestCase):
    def setUp(self):
        self.game = Game("debug_room")
        self.game.add_player("p1", "Player 1") # Bottom (US)
        self.game.add_player("p2", "Player 2") # Right (THEM)
        self.game.add_player("p3", "Player 3") # Top (US)
        self.game.add_player("p4", "Player 4") # Left (THEM)
        
        self.game.game_mode = 'HOKUM'
        self.game.bid = {"type": "HOKUM", "bidder": "Bottom", "doubled": False} # US Bidder

    def test_hokum_split_scoring(self):
        """
        Simulate a game where US (Bidder) gets 122 points and THEM gets 40 points.
        Expected: US gets 12, THEM gets 4. (Total 16).
        Bug Risk: If system thinks THEM bid, it sees 40 < 81, so THEM Khasara -> US 16, THEM 0.
        """
        
        # Simulate tricks summing to 122 and 40
        # Total 162.
        
        self.game.round_history = []
        
        # US (Bottom) takes big tricks. Total 112 + 10 (Last) = 122.
        # THEM (Right) takes small tricks. Total 40.
        
        # Trick 1: THEM. Points 40.
        self.game.round_history.append({'winner': 'Right', 'points': 40, 'cards': [], 'playedBy': []})
        # Trick 2: US. Points 50.
        self.game.round_history.append({'winner': 'Bottom', 'points': 50, 'cards': [], 'playedBy': []})
        # Trick 3: US. Points 62. (Last Trick -> Bonus to US)
        self.game.round_history.append({'winner': 'Bottom', 'points': 62, 'cards': [], 'playedBy': []})
        
        # US needs last trick for +10 bonus to reach 122 from 112?
        # Trick 2 was last? No need many tricks.
        # Just ensure last item in list is winner Bottom.
        
        self.game.end_round()
        
        print(f"Match Scores: {self.game.match_scores}")
        print(f"Past Round Results: {self.game.past_round_results[-1]}")
        
        # Check raw points
        raw_us = self.game.past_round_results[-1]['us']['abnat']
        raw_them = self.game.past_round_results[-1]['them']['abnat']
        
        print(f"Raw US: {raw_us} (Expected 122)")
        print(f"Raw THEM: {raw_them} (Expected 40)")
        
        
        # Check game points
        score_us = self.game.past_round_results[-1]['us']['result']
        score_them = self.game.past_round_results[-1]['them']['result']
        
        print(f"DEBUG RESULTS: US={score_us} THEM={score_them}")
        print(f"Raw US: {raw_us} Raw THEM: {raw_them}")
        print(f"Bid: {self.game.bid}")
        
        self.assertEqual(score_us, 12, f"US should have 12 points. Got {score_us}")
        self.assertEqual(score_them, 4, f"THEM should have 4 points. Got {score_them}")

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_screenshot_analysis.py
```py
import requests
import os

# Configuration
API_URL = "http://127.0.0.1:3005/react-py4web/analyze_screenshot"
# Use the existing image found in the dataset
IMAGE_PATH = os.path.join(os.getcwd(), "uploads", "dataset", "img_1316ba734ed74dcca50c3ca943bd988e.jpg")

def test_analyze_screenshot():
    target_path = IMAGE_PATH
    
    if not os.path.exists(target_path):
        print(f"Image not found at {target_path}")
        # Try to find any jpg in the folder
        dataset_dir = os.path.dirname(target_path)
        if os.path.exists(dataset_dir):
            files = [f for f in os.listdir(dataset_dir) if f.endswith('.jpg')]
            if files:
                target_path = os.path.join(dataset_dir, files[0])
                print(f"Found alternative image: {target_path}")
            else:
                print("No images found in dataset folder.")
                return
        else:
             print(f"Dataset dir {dataset_dir} does not exist.")
             return

    print(f"Testing Screenshot Analysis with {target_path}...")
    
    try:
        with open(target_path, 'rb') as f:
            files = {'screenshot': f}
            response = requests.post(API_URL, files=files)
            
        print(f"Status Code: {response.status_code}")
        if response.status_code == 200:
            data = response.json()
            print("Response Data:", data)
            if 'data' in data:
                print("SUCCESS: AI returned analysis data.")
                print("Players Detected:", len(data['data'].get('players', [])))
            else:
                print("FAILURE: No 'data' field in response.")
        else:
            print("Error Response:", response.text)

    except Exception as e:
        print(f"Test Execution Failed: {e}")

if __name__ == "__main__":
    test_analyze_screenshot()

```

### FILE: tests\test_serialization.py
```py
import pytest
from server.schemas.game import GameStateModel
from server.schemas.base import GamePhase, Team

def test_gamestate_serialization():
    # Mock data representing a typical game state dict
    mock_state = {
        "roomId": "test_room",
        "phase": "PLAYING",
        "biddingPhase": "FINISHED",
        "players": [
            {
                "id": "p1", "name": "User1", "avatar": "av1", "index": 0,
                "hand": [{"suit": "‚ô†", "rank": "7", "id": "7‚ô†", "value": 0}],
                "score": 0, "team": "us", "position": "Bottom",
                "isDealer": True, "actionText": "", "lastReasoning": "", "isBot": False
            }
        ],
        "tableCards": [],
        "currentTurnIndex": 0,
        "gameMode": "SUN",
        "trumpSuit": "‚ô†",
        "bid": {"type": "SUN", "playerIndex": 0},
        "teamScores": {"us": 0, "them": 0},
        "matchScores": {"us": 0, "them": 0},
        "analytics": {"winProbability": [0.5], "blunders": []},
        "floorCard": None,
        "dealerIndex": 0,
        "biddingRound": 1,
        "declarations": {"Bottom": []},
        "timer": {"remaining": 10, "duration": 30, "elapsed": 20, "active": True},
        "isProjectRevealing": False,
        "doublingLevel": 1,
        "isLocked": False,
        "dealingPhase": "FINISHED",
        "lastTrick": None,
        "roundHistory": [],
        "currentRoundTricks": [],
        "sawaState": None,
        "qaydState": None,
        "challengeActive": False,
        "timerStartTime": 0,
        "turnDuration": 30,
        "serverTime": 1234567890,
        "akkaState": None,
        "gameId": "test_room",
        "settings": {}
    }

    # Validate
    model = GameStateModel(**mock_state)
    assert model.roomId == "test_room"
    assert model.phase == GamePhase.PLAYING
    assert model.players[0].team == Team.US
    assert model.players[0].hand[0].suit == "‚ô†"

    # Export
    output = model.model_dump(mode='json', by_alias=True)
    assert output['roomId'] == "test_room"
    assert output['players'][0]['team'] == "us"
    
    print("Serialization Test Passed!")

if __name__ == "__main__":
    test_gamestate_serialization()

```

### FILE: tests\test_signals.py
```py

import unittest
from unittest.mock import MagicMock
from game_engine.models.card import Card
from ai_worker.bot_context import BotContext
from ai_worker.strategies.playing import PlayingStrategy
from ai_worker.signals.manager import SignalManager
from ai_worker.signals.definitions import SignalType

class TestSignals(unittest.TestCase):
    def setUp(self):
        self.strategy = PlayingStrategy()
        self.ctx = MagicMock(spec=BotContext)
        self.ctx.mode = 'SUN'
        self.ctx.trump = None
        self.ctx.is_master_card = lambda c: c.rank == 'A' # Mock master check

    def test_manager_encourage_logic(self):
        mgr = SignalManager()
        
        # Case 1: Strong Hand (A, K, 10) -> Signal YES
        hand = [Card('‚ô•', 'A'), Card('‚ô•', 'K'), Card('‚ô•', '10')]
        self.assertTrue(mgr.should_signal_encourage(hand, '‚ô•'))
        
        # Case 2: Weak Hand (Q, 9, 7) -> Signal NO
        hand = [Card('‚ô•', 'Q'), Card('‚ô•', '9'), Card('‚ô•', '7')]
        self.assertFalse(mgr.should_signal_encourage(hand, '‚ô•'))
        
        # Case 3: Ace but weak (A, 7) -> Signal NO (Too risky to discard A or 7 isn't a signal)
        hand = [Card('‚ô•', 'A'), Card('‚ô•', '7')]
        # This depends on implementation details. A+7 might not trigger "Ten/King" signal logic.
        self.assertFalse(mgr.should_signal_encourage(hand, '‚ô•'))

    def test_manager_select_signal_card(self):
        mgr = SignalManager()
        
        # Case 1: Standard Strong Hand (A, K, 10) -> Should Prioritize ACE (User Rule: "A means I have the rest")
        # Run: A, 10, K is a solid run.
        hand = [Card('‚ô•', 'A'), Card('‚ô•', 'K'), Card('‚ô•', '10'), Card('‚ô•', '7')]
        sig_card = mgr.get_discard_signal_card(hand, '‚ô•')
        self.assertEqual(sig_card.rank, 'A')
        
        # Case 2: Good Hand but not "The Rest" (A, 10, 8) -> Should Prioritize 10
        # If we discard Ace here, we lose master and might not win tricks.
        # Run check: A, 10... no K, no Q. Not solid.
        hand2 = [Card('‚ô•', 'A'), Card('‚ô•', '10'), Card('‚ô•', '8')]
        sig_card2 = mgr.get_discard_signal_card(hand2, '‚ô•')
        self.assertEqual(sig_card2.rank, '10')

    def test_playing_strategy_emission(self):
        # Setup Context: Void in Spades (Lead), Strong in Hearts.
        # Hand: A H, 10 H, 7 H, 7 D.
        self.ctx.hand = [
            Card('‚ô•', 'A'), 
            Card('‚ô•', '10'), 
            Card('‚ô•', '7'), 
            Card('‚ô¶', '7')
        ]
        self.ctx.lead_suit = '‚ô†' # Spades led
        self.ctx.hand_suits = {'‚ô•', '‚ô¶'} # No Spades
        
        # Mock _get_trash_card call (simulating void logic inside _play_sun_follow usually calls this)
        # But we can call _get_trash_card directly to test the hook.
        
        decision = self.strategy._get_trash_card(self.ctx)
        
        self.assertEqual(decision['action'], 'PLAY')
        # Expecting index 1 (10 H)
        # Card at 1 is 10 H.
        idx = decision['cardIndex']
        card = self.ctx.hand[idx]
        
        self.assertIn("Collaborative Signal", decision['reasoning'])
        self.assertEqual(card.rank, '10')
        self.assertEqual(card.suit, '‚ô•')

    def test_detection_logic(self):
        # Setup: Bot is Player 0. Partner is Player 2.
        self.ctx.player_index = 0
        
        # Create a mock trick history
        # Trick 1: Lead Spades. Partner discards 10 Hearts (Signal!)
        mock_trick = {
            'leadSuit': '‚ô†',
            'cards': [
                {'suit': '‚ô†', 'rank': '7', 'playerIndex': 1}, # Right (Lead)
                {'suit': '‚ô•', 'rank': '10', 'playerIndex': 2}, # Partner (Discard Signal)
                {'suit': '‚ô†', 'rank': '9', 'playerIndex': 3}, # Left
                {'suit': '‚ô†', 'rank': 'A', 'playerIndex': 0}  # Me (Win?)
            ],
            'winner': 0
        }
        
        self.ctx.raw_state = {'currentRoundTricks': [mock_trick]}
        
        # Test Detection
        signal = self.strategy._check_partner_signals(self.ctx)
        self.assertIsNotNone(signal)
        self.assertEqual(signal['type'], 'ENCOURAGE')
        self.assertEqual(signal['suit'], '‚ô•')
        
    def test_detection_ignore_follow(self):
        # Setup: Partner follows suit (No signal)
        self.ctx.player_index = 0
        mock_trick = {
            'leadSuit': '‚ô†',
            'cards': [
                {'suit': '‚ô†', 'rank': '7', 'playerIndex': 1}, 
                {'suit': '‚ô†', 'rank': '10', 'playerIndex': 2}, # Partner Follows Spades
                {'suit': '‚ô†', 'rank': '9', 'playerIndex': 3}, 
                {'suit': '‚ô†', 'rank': 'A', 'playerIndex': 0} 
            ],
            'winner': 0
        }
        self.ctx.raw_state = {'currentRoundTricks': [mock_trick]}
        
        signal = self.strategy._check_partner_signals(self.ctx)
        self.assertIsNone(signal)

    def test_reaction_to_signal(self):
        # Setup: Signal detected (Hearts), Bot has Hearts.
        # Ensure Bot leads Hearts.
        self.ctx.player_index = 0
        
        # Inject Mock Signal Detection (to avoid setting up full trick history again)
        self.strategy._check_partner_signals = MagicMock(return_value={'type': 'ENCOURAGE', 'suit': '‚ô•'})
        
        # Hand has Hearts
        self.ctx.hand = [Card('‚ô£', '7'), Card('‚ô•', '7')]
        
        decision = self.strategy._get_sun_lead(self.ctx)
        
        self.assertEqual(decision['action'], 'PLAY')
        self.assertIn("Answering Partner", decision['reasoning'])
        self.assertEqual(decision['cardIndex'], 1) # Should pick the Heart (Index 1)

    def test_opposite_color_detection(self):
        # Setup: Partner discards 7 Hearts (Red) -> Signals interest in BLACK suits (Spades/Clubs)
        self.ctx.player_index = 0
        mock_trick = {
            'leadSuit': '‚ô†',
            'cards': [
                {'suit': '‚ô†', 'rank': 'A', 'playerIndex': 1}, # Enemy
                {'suit': '‚ô•', 'rank': '7', 'playerIndex': 2}, # Partner discards 7H (Red Low) -> Signal Black
                {'suit': '‚ô†', 'rank': '9', 'playerIndex': 3}, 
                {'suit': '‚ô†', 'rank': '7', 'playerIndex': 0} 
            ],
            'winner': 0 # Assume we get lead next somehow, or just testing detection logic
        }
        self.ctx.raw_state = {'currentRoundTricks': [mock_trick]}
        
        # 1. Verify Detection
        signal = self.strategy._check_partner_signals(self.ctx)
        self.assertIsNotNone(signal)
        self.assertEqual(signal['type'], 'PREFER_OPPOSITE')
        self.assertIn('‚ô†', signal['suits'])
        self.assertIn('‚ô£', signal['suits'])
        self.assertNotIn('‚ô•', signal['suits'])
        
        # 2. Verify Reaction (Lead)
        # Give bot a good Club (Black) and a good Heart (Red)
        self.ctx.hand = [Card('‚ô£', '10'), Card('‚ô•', 'A')]
        
        # Inject signal mock to persist state for lead check
        self.strategy._check_partner_signals = MagicMock(return_value=signal)
        
        decision = self.strategy._get_sun_lead(self.ctx)
        
        self.assertEqual(decision['action'], 'PLAY')
        self.assertEqual(decision['cardIndex'], 0) # Should pick Club 10 (Black)
        self.assertIn("Prefer Opposite Color", decision['reasoning'])

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_sira.py
```py

import unittest
import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from game_logic import Game, Card, scan_hand_for_projects
# Make sure helper is available or use Game method if wrapper exists.
# scan_hand_for_projects is standalone in game_logic.py

class TestSiraLogic(unittest.TestCase):
    def test_sequence_7_cards(self):
        """Test a sequence of 7 cards (A..8) is identified as HUNDRED, not 7 Siras."""
        # 7 Cards: A, K, Q, J, 10, 9, 8
        hand = [
            Card('‚ô†', 'A'), Card('‚ô†', 'K'), Card('‚ô†', 'Q'), Card('‚ô†', 'J'),
            Card('‚ô†', '10'), Card('‚ô†', '9'), Card('‚ô†', '8')
        ]
        
        projects = scan_hand_for_projects(hand, 'SUN')
        print(f"Projects found: {projects}")
        
        # Should be ONE project of type HUNDRED
        self.assertEqual(len(projects), 1)
        self.assertEqual(projects[0]['type'], 'HUNDRED')
        self.assertEqual(len(projects[0]['cards']), 7)
        
    def test_sequence_broken(self):
        """Test A, K, Q (Sira) and 10, 9, 8 (Sira) - broken by Jack missing"""
        hand = [
            Card('‚ô†', 'A'), Card('‚ô†', 'K'), Card('‚ô†', 'Q'),
            Card('‚ô†', '10'), Card('‚ô†', '9'), Card('‚ô†', '8')
        ]
        
        projects = scan_hand_for_projects(hand, 'SUN')
        print(f"Projects found (broken): {projects}")
        
        # Should be TWO Siras
        self.assertEqual(len(projects), 2)
        self.assertEqual(projects[0]['type'], 'SIRA')
        self.assertEqual(projects[1]['type'], 'SIRA')

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_socket_flow.py
```py
import socketio
import time
import pytest

def test_dealer_randomness_via_socket():
    """
    Connects to the running game server 20 times.
    Creates a room, joins, and checks the dealer index in the 'game_start' event.
    """
    
    counts = {0: 0, 1: 0, 2: 0, 3: 0}
    
    for i in range(20):
        sio = socketio.Client()
        results = {}

        @sio.event
        def connect():
            print("Connected")

        @sio.event
        def game_start(data):
            dealer = data['gameState']['dealerIndex']
            results['dealer'] = dealer
            sio.disconnect()

        try:
            sio.connect('http://localhost:3005')
            
            # 1. Create Room
            # We need to simulate the events. 
            # Looking at socket_handler.py:
            # create_room(sid, data) -> returns roomId
            # But standard checks are usually callbacks.
            
            # Simple flow: 
            # Client emits 'create_room', gets callback with roomId.
            # Client emits 'join_room'.
            
            room_id_container = {}
            
            def on_create(data):
                room_id_container['id'] = data['roomId']
                
            sio.emit('create_room', {}, callback=on_create)
            
            # Wait for callback
            start_wait = time.time()
            while 'id' not in room_id_container and time.time() - start_wait < 2:
                time.sleep(0.1)
                
            room_id = room_id_container.get('id')
            assert room_id is not None
            
            # 2. Join Room (Triggers Bot Auto-Join and Game Start)
            sio.emit('join_room', {'roomId': room_id, 'playerName': 'TestUser'})
            
            # Wait for game_start event
            start_wait = time.time()
            while 'dealer' not in results and time.time() - start_wait < 2:
                time.sleep(0.1)
                
            if 'dealer' in results:
                counts[results['dealer']] += 1
                print(f"Run {i}: Dealer is {results['dealer']}")
            else:
                print(f"Run {i}: Timeout waiting for game start")
                
        except Exception as e:
            print(f"Run {i} failed: {e}")
        finally:
            if sio.connected:
                sio.disconnect()
                
    print("Final Counts:", counts)
    # Check if we have variance. If counts[0] == 20, BUG CONFIRMED.
    unique_dealers = [k for k, v in counts.items() if v > 0]
    assert len(unique_dealers) > 1, f"Dealer is not random! Counts: {counts}"

if __name__ == "__main__":
    test_dealer_randomness_via_socket()

```

### FILE: tests\test_socket_handler.py
```py
import unittest
from unittest.mock import MagicMock, patch
import sys
import os

# Ensure we can import from root
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

class TestSocketHandler(unittest.TestCase):
    def setUp(self):
        # Patch dependencies BEFORE importing socket_handler
        # This prevents side efffects or requires us to patch the module attributes after import
        self.room_manager_patcher = patch('server.socket_handler.room_manager')
        self.mock_room_manager = self.room_manager_patcher.start()
        
        self.sio_patcher = patch('server.socket_handler.sio')
        self.mock_sio = self.sio_patcher.start()

        # Import the module now
        from server import socket_handler
        self.socket_handler = socket_handler

    def get_mock_game_state(self):
        return {
            "roomId": "ROOM_123",
            "phase": "PLAYING",
            "players": [
                {
                    "id": "sid_1", "name": "TestPlayer", "avatar": "av1", "index": 0,
                    "hand": [], "score": 0, "team": "us", "position": "Bottom",
                    "isDealer": True, "actionText": "", "lastReasoning": "", "isBot": False
                }
            ],
            "tableCards": [],
            "currentTurnIndex": 0,
            "gameMode": "SUN",
            "teamScores": {"us": 0, "them": 0},
            "matchScores": {"us": 0, "them": 0},
            "analytics": {"winProbability": [], "blunders": []},
            "floorCard": None,
            "dealerIndex": 0,
            "biddingRound": 1,
            "declarations": {},
            "timer": {"remaining": 10, "duration": 30, "elapsed": 0, "active": True},
            "isProjectRevealing": False,
            "doublingLevel": 1,
            "isLocked": False,
            "dealingPhase": "FINISHED",
            "challengeActive": False,
            "timerStartTime": 0,
            "turnDuration": 30,
            "serverTime": 1000,
            "gameId": "ROOM_123",
            "settings": {}
        }


    def tearDown(self):
        self.room_manager_patcher.stop()
        self.sio_patcher.stop()

    def test_create_room(self):
        # Setup
        self.mock_room_manager.create_room.return_value = 'ROOM_123'
        
        # Test
        result = self.socket_handler.create_room('sid_1', {})
        
        # Assert
        self.mock_room_manager.create_room.assert_called_once()
        self.assertEqual(result, {'success': True, 'roomId': 'ROOM_123'})

    def test_join_room_success(self):
        # Setup
        room_id = 'ROOM_123'
        sid = 'sid_1'
        player_name = 'TestPlayer'
        
        mock_game = MagicMock()
        mock_player = MagicMock()
        mock_player.to_dict.return_value = {'name': player_name, 'index': 0}
        
        self.mock_room_manager.get_game.return_value = mock_game
        mock_game.add_player.return_value = mock_player
        mock_game.players = [mock_player] # Just one player

        # Test
        response = self.socket_handler.join_room(sid, {'roomId': room_id, 'playerName': player_name})

        # Assert
        # Assert
        print("Checking enter_room call...")
        self.mock_sio.enter_room.assert_called_with(sid, room_id)
        
        print("Checking emit call...")
        # We expect at least player_joined for the user
        # And potentially bots
        self.mock_sio.emit.assert_called() 
        self.assertTrue(response['success'])

    def test_join_room_not_found(self):
        # Setup
        self.mock_room_manager.get_game.return_value = None

        # Test
        response = self.socket_handler.join_room('sid', {'roomId': 'INVALID'})

        # Assert
        self.assertFalse(response['success'])
        self.assertEqual(response['error'], 'Room not found')

    def test_game_action_bid(self):
        # Setup
        room_id = 'ROOM_123'
        sid = 'sid_1'
        action_data = {'roomId': room_id, 'action': 'BID', 'payload': {'action': 'SUN'}}
        
        mock_game = MagicMock()
        mock_player = MagicMock()
        mock_player.id = sid
        mock_player.index = 0
        mock_game.players = [mock_player]
        self.mock_room_manager.get_game.return_value = mock_game
        
        mock_game.handle_bid.return_value = {'success': True}
        mock_game.get_game_state.return_value = self.get_mock_game_state()

        # Test
        result = self.socket_handler.game_action(sid, action_data)

        # Assert
        mock_game.handle_bid.assert_called_with(0, 'SUN', None)
        mock_game.handle_bid.assert_called_with(0, 'SUN', None)
        # Verify emit was called. Arguments are transformed by Pydantic dump so strict equality on dictionary is fragile here without replicating dump logic.
        self.mock_sio.emit.assert_called()
        args, kwargs = self.mock_sio.emit.call_args
        self.assertEqual(args[0], 'game_update')
        self.assertEqual(kwargs['room'], room_id)
        self.assertIn('gameState', args[1])
        self.assertTrue(result['success'])

    def test_game_action_play(self):
        # Setup
        room_id = 'ROOM_123'
        sid = 'sid_1'
        action_data = {'roomId': room_id, 'action': 'PLAY', 'payload': {'cardIndex': 2}}
        
        mock_game = MagicMock()
        mock_player = MagicMock()
        mock_player.id = sid
        mock_player.index = 0
        mock_game.players = [mock_player]
        self.mock_room_manager.get_game.return_value = mock_game
        
        mock_game.play_card.return_value = {'success': True}
        mock_game.get_game_state.return_value = self.get_mock_game_state()

        # Test
        result = self.socket_handler.game_action(sid, action_data)

        # Assert
        mock_game.play_card.assert_called_with(0, 2, metadata={})
        self.mock_sio.emit.assert_called()
        args, kwargs = self.mock_sio.emit.call_args
        self.assertEqual(args[0], 'game_update')

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_socket_handler_coverage.py
```py
import pytest
from unittest.mock import MagicMock, patch, ANY
import sys
import importlib

# We do NOT patch sys.modules globally to avoid breaking other tests
# instead we will import and patch in fixtures

class TestSocketHandler:
    
    @pytest.fixture(scope="class", autouse=True)
    def module_setup(self):
        """Ensure module is loaded with mocked dependencies where strictly necessary"""
        # Patch socketio before import if strictly needed, or just allow import
        # Here we allow import, assuming socketio is installed.
        # But we patch the 'sio' object on the module after import.
        import server.socket_handler
        # We reload to ensure a fresh state if previous tests messed it up
        importlib.reload(server.socket_handler)
        
    @pytest.fixture(autouse=True)
    def setup_mocks(self):
        """Setup common mocks for all tests"""
        self.mock_sio = MagicMock()
        
        # Configure the decorator pass-through behavior on the mock
        def event_decorator(func=None, *args, **kwargs):
            if func is None:
                return lambda f: f
            return func
        self.mock_sio.event = event_decorator
        self.mock_sio.emit = MagicMock()
        self.mock_sio.enter_room = MagicMock()
        self.mock_sio.start_background_task = MagicMock()
        
        # Patch the sio instance in the module
        with patch('server.socket_handler.sio', self.mock_sio):
            # Patch room_manager
            with patch('server.socket_handler.room_manager') as mock_rm:
                self.mock_rm = mock_rm
                # Patch bot_agent to avoid importing ai_worker logic
                with patch('server.socket_handler.bot_agent') as mock_bot_agent:
                    self.mock_bot_agent = mock_bot_agent
                    yield

    def test_create_room(self):
        from server.socket_handler import create_room
        
        self.mock_rm.create_room.return_value = "ROOM_123"
        res = create_room("sid_1", {})
        
        assert res['success'] is True
        assert res['roomId'] == "ROOM_123"

    def test_join_room_success(self):
        from server.socket_handler import join_room
        
        mock_game = MagicMock()
        mock_player = MagicMock()
        mock_player.index = 0
        mock_player.to_dict.return_value = {'id': 'sid_1', 'index': 0}
        
        mock_game.add_player.return_value = mock_player
        mock_game.players = [mock_player]
        mock_game.get_game_state.return_value = {'phase': 'WAITING'}
        self.mock_rm.get_game.return_value = mock_game
        
        data = {'roomId': 'ROOM_123', 'playerName': 'TestUser'}
        
        res = join_room('sid_1', data)
        
        assert res['success'] is True
        self.mock_sio.enter_room.assert_called_with('sid_1', 'ROOM_123')
        self.mock_sio.emit.assert_called()

    def test_game_action_play(self):
        from server.socket_handler import game_action
        
        mock_game = MagicMock()
        mock_player = MagicMock()
        mock_player.id = 'sid_1'
        mock_player.index = 0
        
        # Mock finding player
        mock_game.players = [mock_player]
        
        # Mock play result
        mock_game.play_card.return_value = {'success': True}
        mock_game.get_game_state.return_value = {'phase': 'PLAYING', 'currentTurnIndex': 0}
        self.mock_rm.get_game.return_value = mock_game
        
        data = {
            'roomId': 'R1', 
            'action': 'PLAY', 
            'payload': {'cardIndex': 5}
        }
        
        res = game_action('sid_1', data)
        
        print(f"DEBUG: SIO Emit Calls: {self.mock_sio.emit.mock_calls}")
        
        assert res['success'] is True
        mock_game.play_card.assert_called_with(0, 5, None)
        
        # Verify call arguments
        # We expect ('game_update', {'gameState': ...}, room='R1')
        args, kwargs = self.mock_sio.emit.call_args
        assert args[0] == 'game_update'
        assert kwargs['room'] == 'R1'

    def test_bot_loop_safety(self):
        from server.socket_handler import bot_loop
        
        mock_game = MagicMock()
        with patch('server.socket_handler.logger') as mock_logger:
            bot_loop(mock_game, 'R1', recursion_depth=501)
            mock_logger.warning.assert_called_with("Bot Loop Safety Break (Depth 501)")

```

### FILE: tests\test_stress_game.py
```py

import unittest
from game_logic import Game, GamePhase
from ai_worker.agent import bot_agent
import time
import random

class TestStressGame(unittest.TestCase):
    def setUp(self):
        self.game = Game("stress_test_room")
        # Add 4 players
        self.players = []
        for i in range(4):
            # Pos sequence: Bottom, Right, Top, Left
            # indices: 0, 1, 2, 3
            p = self.game.add_player(f"bot_{i}", f"Bot {i}")
            p.is_bot = True # Mark all as bots
            self.players.append(p)
            
    def test_full_round_simulation(self):
        """Simulate a FULL round with random valid actions"""
        print("\n--- Starting Stress Test Simulation ---")
        
        # Start Game
        self.assertTrue(self.game.start_game())
        
        # Limit loop to prevent infinite hang
        max_steps = 1000
        step = 0
        
        while self.game.phase != GamePhase.FINISHED.value and step < max_steps:
            step += 1
            current_idx = self.game.current_turn
            current_player = self.game.players[current_idx]
            
            # Simple Bot Decision
            decision = bot_agent.get_decision(self.game.get_game_state(), current_idx)
            
            # Execute Action
            if self.game.phase == GamePhase.BIDDING.value:
                action = decision.get('action') or 'PASS'
                suit = decision.get('suit')
                res = self.game.handle_bid(current_idx, action, suit)
                if not res.get('success'):
                     # Fallback to PASS if logic failed
                     self.game.handle_bid(current_idx, 'PASS')
                     
            elif self.game.phase == GamePhase.PLAYING.value:
                card_idx = decision.get('cardIndex')
                if card_idx is None:
                     # Fallback random
                     pass # Should handle invalid via game logic
                
                res = self.game.play_card(current_idx, card_idx)
                if not res.get('success'):
                     print(f"Bot {current_idx} failed to play {card_idx}: {res.get('error')}")
                     # Try finding ANY valid card
                     valid_indices = []
                     for i, c in enumerate(current_player.hand):
                          # Check validity manually? Or just try all
                          valid_indices.append(i)
                     
                     played = False
                     for idx in valid_indices:
                          r = self.game.play_card(current_idx, idx)
                          if r['success']: 
                               played = True
                               break
                     
                     if not played:
                          # This implies Bot has NO valid moves or bug.
                          # Check if hand empty?
                          if not current_player.hand:
                               print("Hand Empty but turn active??")
                          else:
                               self.fail(f"Bot {current_idx} STUCK with hand {current_player.hand}")
            
            # Check if game finished
            if self.game.phase == GamePhase.FINISHED.value:
                 print("\n--- Round Finished Successfully ---")
                 print(f"Scores: Us={self.game.match_scores['us']}, Them={self.game.match_scores['them']}")
                 print(f"Bid: {self.game.bid}")
                 break
                 
        if step >= max_steps:
             self.fail("Game Loop Timeout / Infinite Loop")

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_sun_kaboot.py
```py
import unittest
import sys
import os

# Add parent directory to path to import game_logic
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from game_logic import Game, Player, Card

class TestSunKaboot(unittest.TestCase):
    def setUp(self):
        self.game = Game("test_room")
        self.game.add_player("p1", "Player 1") # Bottom (US) - Index 0
        self.game.add_player("p2", "Player 2") # Right (THEM) - Index 1
        self.game.add_player("p3", "Player 3") # Top (US) - Index 2
        self.game.add_player("p4", "Player 4") # Left (THEM) - Index 3
        
        self.game.game_mode = 'SUN'
        self.game.bid = {"type": "SUN", "bidder": "Bottom", "doubled": False} # US Bidder

    def test_sun_kaboot_us_wins(self):
        """Test that if US team takes ALL tricks in SUN, they get 44 points."""
        
        # Simulate 8 tricks all won by Player 1 (Bottom, US)
        # We don't need real cards, just the structure that end_round expects in round_history
        # round_history items: {'winner': position, 'points': int}
        
        self.game.round_history = []
        
        # 8 Tricks
        for _ in range(8):
            self.game.round_history.append({
                'winner': 'Bottom', # US Team
                'points': 15, # Arbitrary points, sun total is 260 usually but Kaboot ignores raw points
                'cards': [],
                'playedBy': []
            })
            
        # Call end_round
        self.game.end_round()
        
        # Check match scores
        # US should have 44
        # THEM should have 0
        print(f"Match Scores: {self.game.match_scores}")
        self.assertEqual(self.game.match_scores['us'], 44, "US Team should have 44 points for Sun Kaboot")
        self.assertEqual(self.game.match_scores['them'], 0, "THEM Team should have 0 points")

    def test_sun_kaboot_them_wins(self):
        """Test that if THEM team takes ALL tricks in SUN, they get 44 points."""
        
        self.game.round_history = []
        for _ in range(8):
            self.game.round_history.append({
                'winner': 'Right', # THEM Team
                'points': 10,
                'cards': [],
                'playedBy': []
            })
            
        self.game.end_round()
        
        print(f"Match Scores: {self.game.match_scores}")
        self.assertEqual(self.game.match_scores['them'], 44, "THEM Team should have 44 points for Sun Kaboot")
        self.assertEqual(self.game.match_scores['us'], 0, "US Team should have 0 points")

    def test_sun_kaboot_with_projects(self):
        """Test Sun Kaboot + Projects."""
        # US Wins Kaboot (44) + Has 20 (100) project
        
        # Mock a project for Bottom
        self.game.declarations = {
            'Bottom': [{'valid': True, 'score': 20, 'type': 'HUNDRED', 'rank': 'A', 'suit': 'S'}]
        }
        
        self.game.round_history = []
        for _ in range(8):
            self.game.round_history.append({
                'winner': 'Bottom',
                'points': 10,
                'cards': [],
                'playedBy': []
            })
            
        self.game.end_round()
        
        expected_score = 44 + 20
        print(f"Match Scores with Project: {self.game.match_scores}")
        self.assertEqual(self.game.match_scores['us'], expected_score, f"US Team should have {expected_score} (44 + 20)")

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\test_timers.py
```py

import pytest
import time
from unittest.mock import MagicMock, patch
from game_logic import Game, Player, GamePhase, Card

class TestTimers:
    @pytest.fixture
    def game(self):
        g = Game("test_room")
        # Add 4 players
        for i in range(4):
            g.add_player(f"p{i}", f"Player {i}")
        g.start_game()
        g.turn_duration = 2 # Short duration for testing
        return g

    def test_timer_initialization(self, game):
        assert game.timer_active == True
        assert game.timer_start_time > 0
        assert game.turn_duration == 2

    def test_bidding_timeout(self, game):
        # Phase is BIDDING
        game.phase = GamePhase.BIDDING.value
        game.current_turn = 1
        game.reset_timer()
        
        # Simulate time passing (mock time.time would be better for precision, but integration style here)
        # We can just manually set start time to past
        game.timer_start_time = time.time() - 3 
        
        res = game.check_timeout()
        
        assert res is not None
        assert res['success'] == True
        # Check if player passed
        assert game.players[1].action_text == "PASS"
        # Turn should adhere to next logic (1 -> 2)
        assert game.current_turn == 2

    def test_playing_timeout_auto_play(self, game):
        # Setup PLAYING phase
        game.phase = GamePhase.PLAYING.value
        game.current_turn = 0
        p0 = game.players[0]
        # Give specific hand
        p0.hand = [Card('‚ô†', 'A'), Card('‚ô•', '7')] # Ace (11 pts), 7 (0 pts)
        game.reset_timer()
        
        # Determine expected weakest card: 7 Hearts (Points 0)
        # Ace is 11 points.
        
        # Mock timeout
        game.timer_start_time = time.time() - 3
        
        res = game.check_timeout()
        
        assert res is not None
        assert res['success'] == True
        
        # Check that a card was played
        assert len(p0.hand) == 1
        assert len(game.table_cards) == 1
        
        played_card = game.table_cards[0]['card']
        # Should be the 7 (weakest)
        assert played_card.rank == '7'
        assert played_card.suit == '‚ô•'

    def test_auto_play_obeys_rules(self, game):
        # Case: Must follow suit
        game.phase = GamePhase.PLAYING.value
        game.current_turn = 1
        p1 = game.players[1]
        
        # Lead card is Hearts
        game.table_cards = [{'playerId': 'p0', 'card': Card('‚ô•', '10'), 'playedBy': 'Bottom'}]
        
        # Player has Hearts and Spades
        p1.hand = [Card('‚ô†', 'K'), Card('‚ô•', '9'), Card('‚ô•', 'A')] 
        # Must play Hearts. 9 is weaker than Ace.
        
        game.timer_start_time = time.time() - 3
        res = game.check_timeout()
        
        played = game.table_cards[1]['card'] # 2nd card on table
        assert played.suit == '‚ô•'
        assert played.rank == '9' # Weakest legal card

```

### FILE: tests\test_variant_selection.py
```py
import pytest
from game_engine.models.card import Card
from game_engine.logic.bidding_engine import BiddingEngine, BiddingPhase, BidType

# Mocks
class MockPlayer:
    def __init__(self, index):
        self.index = index
        self.hand = []
        self.position = ['Bottom', 'Right', 'Top', 'Left'][index]
        self.team = 'us' if index % 2 == 0 else 'them'
        self.name = f"Player {index}"

def test_variant_selection_flow():
    """Test flow: Hokum Bid -> Doubling Pass -> Variant Selection -> Finished"""
    players = [MockPlayer(i) for i in range(4)]
    engine = BiddingEngine(dealer_index=3, floor_card=Card('‚ô†', '7'), players=players, match_scores={})

    # 1. P0 Bids HOKUM (Must match floor suit in R1)
    res = engine.process_bid(0, "HOKUM", suit='‚ô†')
    assert res['success'] == True
    assert engine.contract.type == BidType.HOKUM
    
    # 2. Transition to Checking Gablak/Turn...
    # In standard engine, bidding might continue.
    # We need to finalize the bid.
    # Assuming standard flow where everyone else passes
    engine.process_bid(1, "PASS")
    engine.process_bid(2, "PASS")
    res = engine.process_bid(3, "PASS")
    
    # After everyone passes, it should go to DOUBLING
    assert engine.phase == BiddingPhase.DOUBLING
    
    # 3. Doubling Phase: Opponent Passes (Waives right)
    # Turn is P1 (Left of Bidder P0)
    res = engine.process_bid(1, "PASS")
    
    # 4. Check Phase Transition
    # Should be VARIANT_SELECTION because contract is HOKUM
    assert res['phase_change'] == "VARIANT_SELECTION"
    assert engine.phase == BiddingPhase.VARIANT_SELECTION
    assert engine.current_turn == 0 # Back to Bidder (P0)
    
    # 5. Variant Selection
    res = engine.process_bid(0, "OPEN")
    assert res['success'] == True
    assert engine.contract.variant == "OPEN"
    assert engine.phase == BiddingPhase.FINISHED

def test_sun_variant_flow():
    """Test flow: Sun Bid -> Doubling Pass -> Finished (No Variant Selection)"""
    players = [MockPlayer(i) for i in range(4)]
    engine = BiddingEngine(dealer_index=3, floor_card=Card('‚ô†', '7'), players=players, match_scores={})

    # 1. P0 Bids SUN (Ends Auction Immediately)
    engine.process_bid(0, "SUN")
    assert engine.contract.type == BidType.SUN
    assert engine.phase == BiddingPhase.DOUBLING
    
    # 2. Doubling Phase Pass (P1 passes)
    res = engine.process_bid(1, "PASS")
    
    # 3. Check Phase
    # Should be FINISHED (No open/closed for Sun, Doubling ended)
    assert engine.phase == BiddingPhase.FINISHED
    assert res['phase_change'] == "FINISHED"

```

### FILE: tests\test_video_analysis.py
```py
import requests
import os
import time

# Configuration
API_URL = "http://127.0.0.1:3005/react-py4web/analyze_screenshot"
# Use the known video file
VIDEO_PATH = os.path.join(os.getcwd(), "kamelnna_desktop.mp4")

def test_analyze_video():
    if not os.path.exists(VIDEO_PATH):
        print(f"Video not found at {VIDEO_PATH}")
        return

    print(f"Testing Video Analysis with {VIDEO_PATH}...")
    print("This may take 10-20 seconds for upload and processing...")
    
    try:
        start_time = time.time()
        with open(VIDEO_PATH, 'rb') as f:
            files = {'screenshot': ('game_video.mp4', f, 'video/mp4')}
            response = requests.post(API_URL, files=files)
            
        print(f"Response Time: {time.time() - start_time:.2f}s")
        print(f"Status Code: {response.status_code}")
        
        if response.status_code == 200:
            data = response.json()
            if 'data' in data:
                print("SUCCESS: AI returned analysis data.")
                print("Game State Summary:")
                print(str(data['data'])[:500])
            else:
                print("FAILURE: No 'data' field in response.")
        else:
            print("Error Response:", response.text)

    except Exception as e:
        print(f"Test Execution Failed: {e}")

if __name__ == "__main__":
    test_analyze_video()

```

### FILE: tests\test_waste_ace.json
```json
{
    "phase": "PLAYING",
    "gameMode": "SUN",
    "trumpSuit": null,
    "players": [
        {
            "index": 0,
            "hand": [
                {
                    "rank": "A",
                    "suit": "‚ô†"
                },
                {
                    "rank": "10",
                    "suit": "‚ô†"
                }
            ],
            "position": "Bottom",
            "team": "Team A"
        },
        {
            "index": 1,
            "hand": [],
            "position": "Right",
            "team": "Team B"
        },
        {
            "index": 2,
            "hand": [],
            "position": "Top",
            "team": "Team A"
        },
        {
            "index": 3,
            "hand": [],
            "position": "Left",
            "team": "Team B"
        }
    ],
    "tableCards": [
        {
            "playedBy": "Right",
            "card": {
                "rank": "7",
                "suit": "‚ô†"
            }
        },
        {
            "playedBy": "Top",
            "card": {
                "rank": "K",
                "suit": "‚ô†"
            }
        },
        {
            "playedBy": "Left",
            "card": {
                "rank": "8",
                "suit": "‚ô†"
            }
        }
    ],
    "currentRoundTricks": [],
    "dealerIndex": 1
}
```

### FILE: tests\verify_sherlock_logic.py
```py

import logging
import sys
import unittest
from unittest.mock import MagicMock

# Adjust path to include project root
sys.path.append('.')

# Mock Logger to avoid errors if server utils not found or configured
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("SherlockTest")

# Mock classes to simulate Game Infrastructure
class MockContext:
    def __init__(self, position, phase, table_cards):
        self.position = position
        self.phase = phase
        self.table_cards = table_cards
        self.decision_timer = 0

class TestSherlockBot(unittest.TestCase):
    
    def test_referee_trigger(self):
        """
        Test 1: verify RefereeObserver detects the 'is_illegal' flag 
        and returns QAYD_TRIGGER.
        """
        from ai_worker.referee_observer import RefereeObserver
        
        observer = RefereeObserver()
        
        # Scenario: 
        # Round Logic: Hearts led.
        # Player 'Right' plays Diamonds (Illegal).
        # We (Bottom) should detect it.
        
        game_state = {
            'phase': 'PLAYING',
            'tableCards': [
                {'playerId': 'p1', 'card': {'suit': 'H', 'rank': 'A'}, 'playedBy': 'Top', 'metadata': {}},
                # The Illegal Move:
                {'playerId': 'p2', 'card': {'suit': 'D', 'rank': '9'}, 'playedBy': 'Right', 'metadata': {'is_illegal': True}} 
            ]
        }
        
        ctx = MockContext(position='Bottom', phase='PLAYING', table_cards=game_state['tableCards'])
        
        print("\n--- Test 1: Referee Detection ---")
        decision = observer.check_qayd(ctx, game_state)
        
        self.assertIsNotNone(decision, "RefereeObserver should return a decision")
        self.assertEqual(decision['action'], 'QAYD_TRIGGER', "Action should be QAYD_TRIGGER")
        print("‚úÖ RefereeObserver correctly returned QAYD_TRIGGER")

    def test_sherlock_accusation(self):
        """
        Test 2: Verify BotAgent calls the Sherlock logic when Qayd is Active
        and it is the Reporter.
        """
        # We need to test the logic block inside BotAgent.get_decision
        # Since we can't easily instantiate the full BotAgent with all dependencies without mocking,
        # we will extract the logic or mock the dependencies heavily.
        
        # Let's try to simulate the specific condition in agent.py
        
        print("\n--- Test 2: Sherlock Accusation Logic ---")
        
        # Mock State: Qayd is Active, Bottom is Reporter
        game_state = {
            'roomId': 'test_room',
            'phase': 'PLAYING',
            'qaydState': {
                'active': True,
                'reporter': 'Bottom', # We are Bottom
                'reason': 'MANUAL_TRIGGER' 
            },
            'tableCards': [
                 {'playerId': 'p1', 'card': {'suit': 'H', 'rank': 'A'}, 'playedBy': 'Top', 'metadata': {}},
                 {'playerId': 'p2', 'card': {'suit': 'D', 'rank': '9'}, 'playedBy': 'Right', 'metadata': {'is_illegal': True}} 
            ],
            'fullMatchHistory': []
        }
        
        # We will manually execute the logic block we added to agent.py check
        # because importing BotAgent might trigger connection logic.
        
        # Simplified logic replica from agent.py:
        ctx = MockContext(position='Bottom', phase='PLAYING', table_cards=game_state['tableCards'])
        decision = self.sherlock_logic(ctx, game_state)
        
        self.assertEqual(decision['action'], 'QAYD_ACCUSATION', "Should accuse")
        self.assertEqual(decision['accusation']['crime_card']['suit'], 'D', "Should identify illegal card")
        print("‚úÖ Sherlock Logic correctly returned QAYD_ACCUSATION")

    def sherlock_logic(self, ctx, game_state):
        """
        Direct copy of the logic implemented in agent.py for testing.
        """
        import time
        # Mock logger
        
        qayd_state = game_state.get('qaydState')
        if qayd_state and qayd_state.get('active'):
            reporter_pos = qayd_state.get('reporter')
            
            if reporter_pos == ctx.position:
                 # Skip sleep for test
                 # time.sleep(15) 
                 
                 table_cards = game_state.get('tableCards', [])
                 crime_card = None
                 proof_card = None
                 
                 if table_cards:
                     for tc in reversed(table_cards):
                         # Handle dict access for 'card' object structure in simulation
                         # In real game, 'card' might be Card object or dict depending on serializer
                         # Here we assume dict for Sim
                         
                         meta = tc.get('metadata') or {}
                         if meta.get('is_illegal'):
                             crime_card = tc['card']
                             if table_cards:
                                 proof_card = table_cards[0]['card']
                             break
                 
                 if crime_card:
                    return {
                        "action": "QAYD_ACCUSATION",
                        "accusation": {
                            "crime_card": crime_card,
                            "proof_card": proof_card or crime_card,
                            "violation_type": "REVOKE"
                        }
                    }
        return None

if __name__ == '__main__':
    unittest.main()

```

### FILE: tests\__init__.py
```py

```

### FILE: tests\ai_iq\iq_test_cases.json
```json
[
    {
        "id": "strategy_sahn_1",
        "category": "PLAYING",
        "description": "Smart Sahn: Lead Trump when opponents might have them (Standard Sahn).",
        "setup": {
            "mode": "HOKUM",
            "trump": "‚ô†",
            "my_hand": [
                "J‚ô†",
                "9‚ô†",
                "A‚ô•"
            ],
            "table": [],
            "my_pos": "Bottom",
            "bidder": "Bottom",
            "history": []
        },
        "expected_action": "PLAY",
        "expected_card": "J‚ô†",
        "reasoning_keyword": "Sahn"
    },
    {
        "id": "strategy_sahn_void_avoid",
        "category": "PLAYING",
        "description": "Smart Sahn: Do NOT lead Trump if opponents are known void. Avoid leading dangerous suit.",
        "setup": {
            "mode": "HOKUM",
            "trump": "‚ô†",
            "my_hand": [
                "J‚ô†",
                "9‚ô†",
                "A‚ô•"
            ],
            "table": [],
            "my_pos": "Bottom",
            "bidder": "Bottom",
            "history": [
                {
                    "winner": "Bottom",
                    "cards": [
                        {
                            "rank": "7",
                            "suit": "‚ô†",
                            "playedBy": "Bottom"
                        },
                        {
                            "rank": "K",
                            "suit": "‚ô•",
                            "playedBy": "Right"
                        },
                        {
                            "rank": "8",
                            "suit": "‚ô†",
                            "playedBy": "Top"
                        },
                        {
                            "rank": "Q",
                            "suit": "‚ô¶",
                            "playedBy": "Left"
                        }
                    ]
                }
            ]
        },
        "expected_action": "PLAY",
        "expected_card": "A‚ô•",
        "reasoning_keyword": "Master"
    },
    {
        "id": "strategy_cut_enemy",
        "category": "PLAYING",
        "description": "Cutting: Enemy winning with Master non-trump. Must cut with Trump.",
        "setup": {
            "mode": "HOKUM",
            "trump": "‚ô¶",
            "my_hand": [
                "7‚ô¶",
                "J‚ô£"
            ],
            "table": [
                {
                    "rank": "A",
                    "suit": "‚ô†",
                    "playedBy": "Right"
                }
            ],
            "my_pos": "Bottom",
            "bidder": "Right",
            "history": []
        },
        "expected_action": "PLAY",
        "expected_card": "7‚ô¶",
        "reasoning_keyword": "Trumping"
    },
    {
        "id": "strategy_duck_winner",
        "category": "PLAYING",
        "description": "Ducking: Partner Winning with Master. Do not overtake. Play points if safe, or trash.",
        "setup": {
            "mode": "SUN",
            "trump": null,
            "my_hand": [
                "K‚ô†",
                "7‚ô†"
            ],
            "table": [
                {
                    "rank": "A",
                    "suit": "‚ô†",
                    "playedBy": "Top"
                }
            ],
            "my_pos": "Bottom",
            "bidder": "Top",
            "history": []
        },
        "expected_action": "PLAY",
        "expected_card": "K‚ô†",
        "reasoning_keyword": "Feed"
    },
    {
        "id": "bid_strong_sun",
        "category": "BIDDING",
        "description": "Bidding: Strong Sun Hand (Aces/Tens) should bid SUN.",
        "setup": {
            "mode": null,
            "trump": null,
            "my_hand": [
                "A‚ô†",
                "10‚ô†",
                "A‚ô•",
                "10‚ô•",
                "K‚ô¶",
                "Q‚ô¶",
                "7‚ô£",
                "8‚ô£"
            ],
            "table": [],
            "my_pos": "Bottom",
            "bidder": null,
            "history": [],
            "phase": "BIDDING",
            "bidding_round": 1
        },
        "expected_action": "ASHKAL",
        "reasoning_keyword": "Strong Sun"
    },
    {
        "id": "bid_strong_hokum",
        "category": "BIDDING",
        "description": "Bidding: Strong Hokum Hand (J/9/A of Suit) should bid HOKUM.",
        "setup": {
            "mode": null,
            "trump": null,
            "my_hand": [
                "J‚ô†",
                "9‚ô†",
                "A‚ô†",
                "7‚ô†",
                "K‚ô•",
                "Q‚ô¶",
                "7‚ô£",
                "8‚ô£"
            ],
            "table": [],
            "my_pos": "Bottom",
            "bidder": null,
            "history": [],
            "phase": "BIDDING",
            "bidding_round": 1,
            "floor_card": {
                "rank": "7",
                "suit": "‚ô†"
            }
        },
        "expected_action": "HOKUM",
        "expected_suit": "‚ô†",
        "reasoning_keyword": "Good ‚ô† Suit"
    },
    {
        "id": "bid_pass_trash",
        "category": "BIDDING",
        "description": "Bidding: Weak Hand should PASS.",
        "setup": {
            "mode": null,
            "trump": null,
            "my_hand": [
                "7‚ô†",
                "8‚ô†",
                "7‚ô•",
                "8‚ô•",
                "7‚ô¶",
                "8‚ô¶",
                "7‚ô£",
                "8‚ô£"
            ],
            "table": [],
            "my_pos": "Bottom",
            "bidder": null,
            "history": [],
            "phase": "BIDDING",
            "bidding_round": 1
        },
        "expected_action": "PASS",
        "reasoning_keyword": "Weak"
    }
]
```

### FILE: tests\unit\test_qayd_trigger.py
```py
import pytest
from unittest.mock import MagicMock, patch
from game_engine.logic.game import Game, GamePhase
from game_engine.models.player import Player

class TestQaydTrigger:
    @pytest.fixture
    def game(self):
        g = Game("test_room")
        for i in range(4):
            g.add_player(f"p{i}", f"Player{i}")
        g.start_game()
        g.phase = GamePhase.PLAYING.value
        # Ensure hand is not empty
        g.players[0].hand = [MagicMock(rank='A', suit='‚ô†')] 
        return g

    def test_auto_play_card_triggers_qayd_on_accusation_in_playing_phase(self, game):
        """
        When bot decides QAYD_ACCUSATION in PLAYING phase, 
        it should TRIGGER investigation first (transition to CHALLENGE), 
        not confirm immediately.
        """
        with patch('ai_worker.agent.bot_agent') as mock_bot:
            # Mock bot decision to be ACCUSATION
            mock_bot.get_decision.return_value = {
                'action': 'QAYD_ACCUSATION',
                'accusation': {'reason': 'test'}
            }
            
            # Mock handle_qayd_trigger to verify it is called
            # We can also check if phase changes if we don't mock it, 
            # but mocking ensures we hit the right code path.
            # However, Game.handle_qayd_trigger delegates to ChallengePhase.
            # Let's spy on ChallengePhase.trigger_investigation
            
            with patch.object(game.challenge_phase, 'trigger_investigation', return_value={'success': True}) as mock_trigger:
                result = game.auto_play_card(0)
                
                # Assertions
                mock_trigger.assert_called_once()
                assert result == {'success': True}
                
    def test_auto_play_card_processes_accusation_in_challenge_phase(self, game):
        """
        When bot decides QAYD_ACCUSATION in CHALLENGE phase,
        it should process the accusation (confirm/verify).
        """
        game.phase = GamePhase.CHALLENGE.value
        
        with patch('ai_worker.agent.bot_agent') as mock_bot:
            mock_bot.get_decision.return_value = {
                'action': 'QAYD_ACCUSATION',
                'accusation': {'reason': 'test'}
            }
            
            with patch.object(game, 'process_accusation', return_value={'success': True}) as mock_process:
                game.auto_play_card(0)
                mock_process.assert_called_once()

    def test_auto_play_card_triggers_qayd_explicitly(self, game):
        """
        When bot decides QAYD_TRIGGER, it should call trigger_investigation.
        """
        with patch('ai_worker.agent.bot_agent') as mock_bot:
            mock_bot.get_decision.return_value = {'action': 'QAYD_TRIGGER'}
            
            with patch.object(game.challenge_phase, 'trigger_investigation', return_value={'success': True}) as mock_trigger:
                game.auto_play_card(0)
                mock_trigger.assert_called_once()

```

### FILE: tests\unit\test_sherlock.py
```py
import pytest
from ai_worker.memory import CardMemory
from game_engine.models.card import Card

class TestSherlockMemory:
    @pytest.fixture
    def memory(self):
        return CardMemory()

    def test_void_tracking(self, memory):
        """Test that memory correctly infers voids from game events"""
        # Scenario: Player fails to follow suit
        # Led: Hearts, Player plays: Spades
        memory.mark_played("AH") # Ace Hearts Led
        memory.mark_void("Player1", "‚ô•") # Player 1 couldn't follow hearts
        
        assert memory.is_void("Player1", "‚ô•") == True
        assert memory.is_void("Player1", "‚ô†") == False

    def test_contradiction_detection(self, memory):
        """Test Sherlock's ability to catch a liar"""
        # 1. Player 1 shows void in Hearts
        memory.mark_void("Player1", "‚ô•")
        
        # 2. Player 1 tries to play Hearts (illegal if they have it, but here we test the detection of the lie)
        # Wait, if they show void, they shouldn't have it. 
        # But if they play it later, that proves the PREVIOUS void claim was a lie (or this play is illegal if they really are void).
        # In Baloot "Liar's Protocol":
        # Turn 1: Lead H. Player plays S (Claims Void H). Memory marks Void H.
        # Turn 2: Player plays H. Contradiction! 
        
        card = Card("‚ô•", "K")
        contradiction = memory.check_contradiction("Player1", card)
        
        assert contradiction is not None
        assert "previously showed VOID" in contradiction

    def test_no_false_positive(self, memory):
        """Ensure honest plays don't trigger accusation"""
        memory.mark_void("Player1", "‚ô•")
        
        # Player plays Spades (Consistent with void in Hearts)
        card = Card("‚ô†", "K")
        contradiction = memory.check_contradiction("Player1", card)
        
        assert contradiction is None

    def test_reset_memory(self, memory):
        """Memory should clear between rounds"""
        memory.mark_void("Player1", "‚ô•")
        memory.reset()
        assert memory.is_void("Player1", "‚ô•") == False

```

